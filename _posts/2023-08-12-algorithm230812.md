---
layout: post
title: "230812 알고리즘 문제풀이"
subtitle:   " 백준 18352, 백준 2178 "
catalog: true
category: study
subcategory: algorithm
tags:
    - 백준
    - algorithm
    - study
    - 2178
    - 18352
    - bfs


---

# 2023년 8월 12일 알고리즘 문제풀이

## 문제 1 백준 18352

[문제 링크](https://www.acmicpc.net/problem/18352)

### 1차 시도

#### 나의 생각

도시까지의 최단거리만 생각해야 하므로, bfs를 통해 도착한 도시에 얼마나 걸렸는지를 표시하고, 이를 방문표시로 이용하면 되겠다는 생각을 했다. 출발한 도시 와 도착지가 같을때는 0으로 표시하게 되는데, 이것 때문에 아직 방문처리하지 않은 것으로 취급되어 여러가지로 헷갈렸다. 따라서 제자리 거리를 1로 표시하여 모든 도시의 거리를 구하고 모두 1 만큼 감소시켜주었다.

#### 결과

정답

#### 코드

```python
import sys
from collections import deque

n, m, k, x = map(int, sys.stdin.readline().split())
graph = [[]for _ in range(n+1)]
for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    graph[a].append(b)

ans = []
visited = [0 for _ in range(n+1)]

def bfs(s):
    visited[s] = 1
    arr = deque()
    arr.append(s)
    while arr:
        now = arr.popleft()
        for next in graph[now]:
            if not visited[next]:
                arr.append(next)
                visited[next] = visited[now]+1

bfs(x)
ans = []
if k == 0:
    print(x)
else:
    for i in range(1, n+1):
        visited[i] -= 1
        if i == x:
            continue
        if visited[i] == k:
            print(i)
            ans.append(i)
            
if not ans:
    print(-1)
```

---

## 문제 2 백준 2178

[문제 링크](https://www.acmicpc.net/problem/2178)

### 1차 시도

#### 나의 생각

위 문제와 결이 비슷하다고 생각했다. 갈 수있는 조건을 나타내는 `graph`에 거리를 더해서 표시하도록 하였다. 행렬 좌표와 index 값의 차이가 있으니 -1 해주는 것에 신경썼다. 또한 입력값을 받을 때 `str`로 받았으니 비교할 때도 1이 아닌 '1'로 비교하였다. 이 조건들만 유의한채 bfs를 이용하여 풀었다.

#### 결과

정답

#### 코드

```python
import sys
from collections import deque

n,m = map(int,sys.stdin.readline().split())
graph = []
for _ in range(n):
    tmp = list(sys.stdin.readline().rstrip())
    graph.append(tmp)
    
dx = [0,-1,0,1]
dy = [1,0,-1,0]
def bfs(n,m):
    arr = deque()
    arr.append([0,0])
    while arr:
        x,y = arr.popleft()
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if nx >= 0 and nx <= n-1 and ny >= 0 and ny <= m-1 and graph[nx][ny] == '1':
                arr.append([nx,ny])
                graph[nx][ny] = int(graph[x][y]) + 1
                if nx == n-1 and ny == m-1:
                    return
bfs(n,m)
print(graph[n-1][m-1])
```

