---
layout: post
title: "Synchronization"
subtitle:   " Pintos 1주차 "
catalog: true
tags:
    - article
    - PintOS
    - synchronization
    - lock
    - interrupt
    - disableing interrupt
    - monitor
    - optimization barriers

---

# Synchronization

쓰레드간 자원 분배 : 조심히 다뤄야 한다.



## Disabling Interrupts

가장 기초적인 방법 : CPU가 interrupts에게 반응하는 것을 일시적으로 막는 것



interrupts off : 다른 쓰레드는 작동중인 쓰레드를 선점(preempt)못한다 => 선점은 'timer interrupts'가 관리하니까

interrupts on : 작동중인 쓰레드는 언제든 선점당할 수 있다. => 2개의 C statements 중 하나에게, 심지어 하나한테도..



Pintos 는 "preemptible kernel" 이다. => 커널 쓰레드는 언제든 선점당할 수 있다.

전통적인 UNIX 시스템에서는 "nonpreemptible"이다. => 커널쓰레드는 스케쥴러에게 명시적으로 호출당할때만 선점된다?

원문 : (kernel threads can only be preempted at points where they explicitly call into the scheduler)

preemptible kernels는 좀더 명시적인 synchronization이 요구된다.



위에 것 쓸일 거의없음.

외부(external) interrupt handlers : 잠들수 없고(sleep) 대다수의 다른 synchronization을 사용할수 없음



어떤 외부 interrupts는 disabling interrupts로도 지연될 수 없는데(postponed) 이것들은 **non_maskable interrupts**(NMIs)

라고 함.

컴퓨터 불 붙거나 응급상황에만 쓴다.. -> pintos에서 안다룸 



```c
enum intr_level; //One of INTR_OFF or INTR_ON, interrupts의 enabled,disabled 나타냄
enum intr_level intr_get_level (void) // 최근 interrupt 상태 반환
enum intr_level intr_set_level (enum intr_level level); // interrupts on/off 바꿈, 이전 상태 반환
enum intr_level intr_enalbe (void); // interrupts 킴. 이전 상태 반환
enum intr_level intr_disable (void); // interrupts 끔. 이전 상태 반환
```



## Semaphores(세마포어)

semaphores는 자동적으로 조작하는 두 오퍼레이터와 함께 있는 음이 아닌 실수다. 다음과 같다.

-  "Down" or "P" : 양수(positive)가 될 값을 기다리다가, 감소시킨다.
- "Up" or "V" : 값을 증가시킨다(그리고 쓰레드를 기다리는 한개를 깨운다(wake up))



0으로 초기화 된 세마포어는 정확히 한번 발생할 event를 기다리기 위해 사용될 지도 모른다.

예를 들어, 쓰레드 A가 다른 쓰레드 B를 시작시킨다고 가정하자. 또,  B가 보낼 어떤 활동(activity)이 완성되었다는 신호를 기다린다고 가정하자. A는 0으로 초기화된 세마포어를 만들수 있고 B를 시작시킬 때 그 세마포어를 B에게 보낼 수 있다. 그리고 세마포어를 "Down"한다. B가 활동을 끝낼때는 세마포어를 'Up'한다. 이건  A가 먼저 "Down"했는지, B가 먼저 "Up"했는지와는 무관하게 작동한다.



예시

```c
struct semaphore sema;

/* Thread A */
void threadA (void) {
    sema_down (&sema);
}

/* Thread B */
void threadB (void) {
    sema_up (&sema);
}

/* main function */
void main (void) {
    sema_init (&sema, 0);
    thread_create("threadA", PRI_MIN, threadA, NULL);
    thread_create("threadB", PRI_MIN, threadB, NULL);
}
```

이 예시에서 ,threadA는 threadB가 `sema_up ()`를 호출하기 전에 `sema_down()`에서 실행을 멈춘다.

1로 초기화 된 세마포어는 전형적으로 자원으로의 접근을 조절하기 위해 사용된다. 코드 블록이 자원을 사용하기 시작하기 전에, 세마포어를 "Down"하고 자원을 다 쓰면 자원을 "up"시킨다. 

물론 세마포어는 1보다 큰 값으로 초기화 될 수도 있다. 근데 거의 쓰이지 않는다. Pintos의 세마포어 타입과 오퍼레이션은 `include/threads/synch.h`에서 선언된다.

```c
struct semaphore; // 세마포어 선언
void sema_init (struct semaphore *sema, unsigned value); //  sema를 주어진 초기값의 새로운 세마포어로 초기화
void sema_down (struct semaphore *sema); // sema에 "down"이나 "p" 실행, positive되길 기다리다가 1만큼 떨군다.
bool sema_try_down (struct semaphore *sema); // 기다리지 않고 "down"이나 "p" 실행
void sema_up (struct semaphore *sema); // sema에 "up" 이나 "V" 실행
```

line 4 : sema가 성공적으로 감소되면 TRUE를 반환하고, 이미 0이거나 기다리지 않고 감소시킬 수 없으면 FALSE 반환한다. tight loop에서 이 함수를 호출하는 것은 CPU time을 낭비시키니, `sema_down()`를 사용하거나 다른 접근방식을 찾아라.

(tight loop : 코드가 어떤 지연이나 방해 없이 반복적으로 실행되는 프로그래밍 구조를 뜻함)

line 5 : 어떤 쓰레드들이 sema를 기다리고 있으면, 하나를 깨운다. 대부분의 동기화 원리와 다르게, `sema_up()`는 external interrupt handler 내부에서 호출될지도 모른다.

세마포어는 내부적으로 disabling interrupt(위 참고)와 thread blocking과 unblocking(`thread_block()` 과 `thread_unblock()`)으로 만들어 졌다. 각 세마포어는 `lib/kernel/list.c`에서 linked list 실행에 사용되는 대기 쓰레드 리스트를 가진다.



## Locks

록은 1의 초기 값을 가진 세마포어 같다. 록에서 "up"은 "release"라 불리고, "down"은 "acquire"로 불린다.

세마포어와 비교해서, 록은 제한을 하나 더 가진다. 록의 "owner(소유자)"라고 불리는 [lock을 얻은? /'acquire'한?] 유일한 쓰레드는 그것을 release하게 된다.(원문 : only the thread that acquires a lock, called the lock's "owner", is allowed to release it.) 이 제한이 문제라면, 록 대신 세마포어가 사용되어야 한다는 좋은 소식이다.

pintos에서 록은 "재귀적"이지 않다. 즉, 그 lock을 acquire하기를 시도하는 록을 가진 쓰레드에 대한 에러다.(원문 : Locks in Pintos are not "recursive." that is, it is an error for the thread currently holding a lock to try to acquire that lock.) 록 타입과 함수는 `include/threads/synch.h`에서 선언된다.

```c
struct lock; // lock 선언
void lock_init (struct lock *lock); // lock을 새 lock으로 초기화한다. 초기에는 누구에게 소유되지 않는다.
void lock_acquire (struct lock *lock); // 최근(current) 쓰레드를 위해 lock을 acquire한다.
bool lock_try_acquire (struct lock *lock); // 기다리지 않고 최근 쓰레드에게 사용될 lock을 acquire하려고 시도.
void lock_release (struct lock *lock); // 최근 쓰레드가 반드시 소유해야하는 lock을 release한다.
bool lock_held_by_current_thread (const struct lock *lock):
```

line 3: 우선 필요하다면 release할 아무 최근 소유자를 기다린다.

line 4 : 성공적이면 TRUE를 반환하고, lock이 이미 소유되면 FALSE를 반환한다. tight loop에서 이 함수를 호출하는 것은 CPU time 낭비 때문에 나쁜 생각이므로, `lock_acquire()`를 대신 사용하라.

line 6 : 실행중인 쓰레드가 lock을 소유하고 있으면 TRUE를 반환한다. 임의의 쓰레드가 lock이 있는지 test하는 기능은 없다. 호출자(caller)가 실행하기 전에 답이 바뀔 수 있기 때문이다.



## Monitors

모니터는 세마포어나 록보다 높은 형태의 동기화이다. 모니터는 동기화되는 data와 모니터 록이라 부르는 lock, 그리고 하나 이상의 condition variables(조건 변수)로 이루어져 있다. 보호된 데이터에 접근하기 전에, 쓰레드는 우선 모니터 록을 얻어야한다. 이건 "모니터 안에 있다(in the monitor)"라고 불린다. 모니터 안에 있을 때, 쓰레드는 모든 보호받는 데이터에 대해 제어권을 가져서, 자유롭게 조사(examine), 수정(modify) 할 지도 모른다. 보호된 데이터로 접근이 완료되면, 모니터 록을 푼다(release)



조건 변수(condition variables)는 모니터에 있는 코드가 조건이 TRUE가 되길 기다리도록 만든다. 각 조건 변수는 추상적인 조건과 관련되어있다. 예를 들어, "어떤 데이터는 processing에 도착했다" 거나 " 유저의 마지막 입력(keystroke) 이후 10초가 지나갔다". 모니터 안에 있는 코드가 조건이 TRUE가 되길 기다릴때, 록을 풀고 조건에 신호가 가길 기다리는 연관된 조건 변수를 "기다린다." 반면에, 만약 이 조건들중 하나가 TRUE가 되면, 그것은 대기자(waiter) 하나를 깨울 조건에 "신호를 보내거나(signals)" 조건들에게 모두 일어나라고 "방송(broadcast)"한다.



모니터에 대한 이론적인 프레임워크는 C.A.R.Hoare(영국의 컴퓨터학자)가 구성했다. 그들의 실용적인 사용은 후에 Mesa OS에서 정교해졌다. 조건 변수 타입과 함수는 `include/threads/synch.h`에서 선언된다.

```c
struct condition; // 조건 변수를 선언
void cond_init (struct condition *cond); // 새로운 조건변수로 cond를 초기화
void cond_wait (struct condition *cond, struct lock *lock);
void cond_signal (struct condition *cond, struct lock *lock);
void cond_broadcast (struct condition *cond, struct lock *lock);
```

line 3 : atomically(원자적으로..? 자동적으로..?) 모니터 록을 풀고 cond가 어떤 다른 코드에게 신호를 받길 기다린다. cond가 신호를 받으면 반환하기 전에 록을 reacquire한다. 록은 이 함수를 호출하기 전에 hold 되야한다. 신호를 보내고 대기자를 깨우는 것은 atomic(?) operation이 아니다. 따라서 전형적으로 `cond_wait()`의 호출자(caller)는 대기가 끝나면 조건을 재확인하고, 필요하다면, 다시 기다려야 한다. 예시로 다음 section을 보면 된다.

line 4 : 만약 monitor lock lock에 보호받는 cond에 대기중인 어떤 쓰레드가 있다면, 이 함수는 그들중 하나를 깨운다. 기다리는 스레드가 없다면 아무 일 없이 리턴한다. lock는 이 함수 호출 전에 이뤄져야한다.

line 5 : monitor lock lock에 보호받는 cond에 대기중인 모든 쓰레드를 꺠운다. lock은 이 함수 호출 전에 이뤄져야 한다.



### Monitor Example

monitor의 고전적인 예시는 하나 이상의 "제작자(producer)" 스레드가 characters(글자)를 쓰고 하나 이상의 "소비자(consumer)" 스레드가 characters(글자)를 읽는 buffer를 다루는 것이다. 이걸 실행하기 위해, 우리는 monitor lock에다가 `not_full`, `not_empty`라고 부르는 두 condition variables가 필요하다.

```c
// lock과 condition variables 초기화
char buf[BUF_SIZE]; 			/* Buffer */
size_t n = 0; 					/* 0 <= n <= BUF SIZE : 버퍼 안 글자들 크기 범위 */
size_t head = 0; 				/* 다음 쓸 글자의 buf index */
size_t tail = 0; 				/* 다음 읽을 글자의 buf index */
struct lock lock; 				/* Monitor lock */
struct condition not_empty; 	/* buffer가 비어있지 않을 때 신호 */
struct condition not_full; 		/* buffer가 꽉 차있지 않을 때 신호 */

void put (char ch) {
    lock_acquire (&lock);
    while (n == BUF_SIZE) 				/* buffer가 꽉 차있으면 넣을 수 없음 */
        cond_wait (&not_full, &lock);
    buf[head++ % BUF_SIZE] = ch; 		/* buffer에 ch 넣기 */
    n++;
    cond_signal (&not_empty, &lock); 	/* buffer는 이제 비어있다고 할 수 없음 */
    lock_release (&lock);
}

char get (void) {
    char ch;
    lock_acquire (&lock);
    while (n == 0) 						/* buffer가 비어있다면 읽을 수 없음 */
        cond_wait (&not_empty, &lock);
    ch = buf[tail++ % BUF_SIZE]; 		/* buffer에서 ch 꺼내기 */
    n--;
    cond_signal (&not_full, &lock); 	/* buffer는 이제 꽉 차있다고 할 수 없음 */
    lock_release (&lock);
}
```

위 코드가 완전히 올바르기 위해서 `BUF_SIZE`가 반드시 evenly(짝수로) 나누어져서 `SIZE_MAX + 1` 이 되는 것을 주목해라.

그렇지 않으면, `head`가 0 근처에서 처음 wrap하다가 실패할 것이다.

실제로, `BUF_SIZE`는 보통 2의 제곱 형태이다.

(원문 : Note that `BUF_SIZE` must divide evenly into `SIZE_MAX + 1` for the above code to be completely correct. Otherwise, it will fail the first time `head` wraps around to 0. In practice, `BUF_SIZE` would ordinarily be a power of 2.)



### Optimization Barriers(최적화 장벽)

최적화장벽은 특별한 statement다.(statement는 실행가능한 최소의 독립적인 코드조각. 컴파일러가 이해하고 실행할 수 있는 모든 구문.) 최적화장벽은 컴파일러가 방벽 너머 메모리의 상태에 대해 가정하는 것을 방지한다. 컴파일러는 장벽 너머의 변수에 대해 또 다시 쓰거나 읽도록 요구하지 않을 것이고, 주소가 발생하지 않은 지역 변수를 제외하고는 장벽을 넘어서 변수의 값을 수정 불가능 하다고 가정하지 않을 것이다. Pintos에서, `include/threads/synch.h`는 optimization barrier로 `barrier()`매크로를 정의한다.



최적화 장벽을 사용하는 이유는 또다른 스레드나 interrupt handler 같이 컴파일러의 knowledge(지식?) 없이 데이터가 비동기적으로 변화할 수 있을 때에 있다. `devices/timer.c`안에 있는 `too_many_loops()`함수가 예시이다. 이 함수는 시간 측정(timer tick)이 발생하기 전까지 루프(loop)에서 busy-wating에 의해 발생한다.

```c
/* timer tick 기다림 */
int64_t start = ticks;
while (ticks == start)
    barrier();
```

루프에 최적화 장벽 없으면 컴파일러는 `start`와 `ticks`동시에 시작하고 루프가 둘을 절대 직접 바꿀 수 없기 때문에 루프가 절대 종결되지 않을 것이라고 결론짓는다. 그러면 컴파일러는 바람직하지 않게 정의된 무한 루프 안으로 함수를 "최적화(optimize)"한다.

최적화 장벽은 다른 컴파일러의 최적화(optimization)를 피하기 위해 사용될 수 있다. 마찬가지로 `devices/timer.c`안에 있는 `busy_wait()` 함수가 예시다. 이 함수는 이 루프를 갖고 있다. 

```c
while (loops--> 0)
    barrier ();
```

이 루프의 목표는 원래 값에서 0으로 점차 계산해 내려감으로서 busy-wait하는 것이다. 장벽 없이, 컴파일러는 이 루프를 전체적으로 삭제할 수도 있다. 왜냐하면 루프가 유용한 output도, 부작용도 없기 때문이다. 장벽은 컴파일러에게 루프 body가 중요한 효과를 가지고 있음을 세뇌시킨다.(The barrier forces the compiler to pretend that the loop body has an important effect.)

마지막으로, 최적화 장벽은 메모리의 읽거나 쓰는 순서를 강제하기 위해 사용될 수 있다.(Finally, optimization barriers can be used to force the ordering of memory reads or writes.) 예를 들어, timer interrupt가 발생할 때마다 global Boolean variable(전역 불리언 변수)`timer_do_put`이 true라면  전역 변수 `timer_put_char`안의 글자(character)가 콘솔에 출력된다고 가정해보자. 출력할 `x`를 설정하는 최고의 방법은 최적화 방벽을 사용하는 것이다. 다음과 같다.

```c
timer_put_char = 'x';
barrier ();
timer_do_put = true;
```

장벽 없이, 코드는 컴파일러가 operation이 똑같은 순서로 둬야 하는 이유를 찾지 못하면 자유롭게 재조정하기 때문에, buggy(수레?카트?)이다. 이 경우, 컴파일러는 과제(assignment)의 순서가 중요해서 optimizer가 그들의 순서를 바꾸길 허락받은 것을 모른다.그게 실제로 이걸 하는지에 관한 얘기는 없고, 다른 최적화 깃발이나 다른 버전의 컴파일러를 지나치는 것은 다른 동작(behavior)을 만들어 낼 것이다.

또 다른 해결책은 과제(assignment)주위로 disable interrupts 하는 것이다. 이것은 재조정을 방지하진 않지만, interrupt handler가 assignment 사이를 지나는 것은 막는다. 또한 disabling, re-enabling interrupts 에 대한 추가적인 실행 비용도 있다.

```c
enum intr_level old_level = intr_disable ();
timer_put_char = 'x';
timer_do_put = true;
intr_set_level (old_level);
```



두번째 해결책은 `timer_put_char`와 `timer_do_put`을 `volatile`로 선언하는 것을 표시하는 것이다. 이 키워드는 컴파일러에게 변수들이 외부에서 보일 수 있고  최적화(optimization)의 latitude(구역)을 제한한다. 그러나 `volatile`는 의미론적으로(semantics) 잘 정의되지 않아서 일반적이고 좋은 방책은 아니다. 기초 Pintos 코드는 `volatile`을 전혀 사용하지 않는다.

다음 나오는 것은 록(locks)이 interrupts도, 컴파일러가 락이 있는(held) 지역에서 코드를 재조정(reordering) 하는 것도 막지 못했기 때문에 해결책인 코드가 아니다. 

```c
lock_acquire (&timer_lock); /* 부정확한 코드임 */
timer_put_char = 'x';
timer_do_put = true;
lock_release (&timer_lock);
```

컴파일러는 또 다른 소스 파일에서 최적화 장벽의 제한된 형태로써 외부적으로 정의된 어떤 함수의 발동을 treat한다.(다룬다? 치료한다?) 구체적으로, 컴파일러는 외부적으로 정의된 어떤 함수가 정적•동적 할당된 데이터와 주소가 발생한(taken) 어떤 지역 변수들에 접근할지도 모른다고 가정한다. 이것은 보통 명시적(explicit) 장벽이 생략될 수 있다는 것을 의미한다. Pintos가 명시적 장벽이 거의 없는 이유다.

 같은 소스파일이나 소스파일이 포함시킨 헤더에서 정의된 함수는 최적화 장벽에 의존할 수 없다. 이것은 정의 전에 함수의 발동에도 적용되는데, 컴파일러가 최적화(optimization) 수행 전에 전체 소스 파일을 읽고 분석(parse)할지도 모르기 때문이다.
