---

layout: post
title: "PintOS Alarm Clock êµ¬í˜„"
subtitle:   " ê° ë‹¨ê³„ë³„ í•¨ìˆ˜  "
catalog: true
tags:

   - article
   - PintOS

---

# 1. **struct thread ìš”ì†Œ ì¶”ê°€ o**

include/threads/thread.h

- ì •ë‹µ

    ```c
    struct thread
      {
        ...
        int init_priority;
        
        struct lock *wait_on_lock;
        struct list donations;
        struct list_elem donation_elem;
    	...
      };
    ```

- êµ¬í˜„ = ìµœì¢…ì½”ë“œ

    ```c
    struct thread
    {
    	/* Owned by thread.c. */
    	tid_t tid;				   /* Thread identifier. */
    	enum thread_status status; /* Thread state. */
    	char name[16];			   /* Name (for debugging purposes). */
    	int priority;			   /* Priority. */
    
    	/* Shared between thread.c and synch.c. */
    	struct list_elem elem; /* List element. */
    	/*----------------[project1]-------------------*/
    	/* local tick */
    	int64_t wake_up_tick;
    
    	/* priority donaion ê´€ë ¨ element ì¶”ê°€ */
    	int init_priority;					// donationì´í›„ ìš°ì„ ìˆœìœ„ë¥¼ ì´ˆê¸°í™”í•˜ê¸° ìœ„í•´ ì´ˆê¸°ê°’ ì €ì¥
    	struct lock *wait_on_lock;			// í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°í•˜ê³  ìˆëŠ” lockìë£Œêµ¬ì¡° ì£¼ì†Œ ì €ì¥
    	struct list donations;				// multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
    	struct list_elem donation_elem;		// multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
    	/*----------------[project1]-------------------*/
    #ifdef USERPROG
    	/* Owned by userprog/process.c. */
    	uint64_t *pml4; /* Page map level 4 */
    #endif
    #ifdef VM
    	/* Table for whole virtual memory owned by thread. */
    	struct supplemental_page_table spt;
    #endif
    
    	/* Owned by thread.c. */
    	struct intr_frame tf; /* Information for switching */
    	unsigned magic;		  /* Detects stack overflow. */
    };
    ```

# 2. ì¶”ê°€í•œ ìš”ì†Œ ì´ˆê¸°í™” o

thread/thread.c

- ì •ë‹µ

    ```c
    static void
    init_thread (struct thread *t, const char *name, int priority)
    {
      ...
      t->init_priority = priority;
      t->wait_on_lock = NULL;
      list_init (&t->donations);
      ...
    }
    ```

- êµ¬í˜„ = ìµœì¢…ì½”ë“œ

    ```c
    static void
    init_thread(struct thread *t, const char *name, int priority)
    {
    	ASSERT(t != NULL);
    	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
    	ASSERT(name != NULL);
    
    	memset(t, 0, sizeof *t);
    	t->status = THREAD_BLOCKED;
    	strlcpy(t->name, name, sizeof t->name);
    	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
    	t->priority = priority;
    	t->magic = THREAD_MAGIC;
    	/*----------------[project1]-------------------*/
    	t->init_priority = priority;
    	t->wait_on_lock = NULL;
    	list_init(&t->donations);
    	/*----------------[project1]-------------------*/
    }
    ```

# 3. **lock_acquire ()í•¨ìˆ˜ ìˆ˜ì •**

threads/synch.c

- default

    ```c
    void
    lock_acquire (struct lock *lock)
    {
      ASSERT (lock != NULL);
      ASSERT (!intr_context ());
      ASSERT (!lock_held_by_current_thread (lock));
    
      sema_down (&lock->semaphore);
      lock->holder = thread_current ();
    }
    ```

- ì •ë‹µ

    ```c
    void
    lock_acquire (struct lock *lock)
    {
      ASSERT (lock != NULL);
      ASSERT (!intr_context ());
      ASSERT (!lock_held_by_current_thread (lock));
    
      struct thread *cur = thread_current ();
      if (lock->holder) {
        cur->wait_on_lock = lock;
        list_insert_ordered (&lock->holder->donations, &cur->donation_elem, 
        			thread_compare_donate_priority, 0);
        donate_priority ();
      }
    
      sema_down (&lock->semaphore);
      
      cur->wait_on_lock = NULL;
      lock->holder = cur;
    }
    ```

- êµ¬í˜„1

    ```c
    void lock_acquire(struct lock *lock)
    {
    	ASSERT(lock != NULL);
    	ASSERT(!intr_context());
    	ASSERT(!lock_held_by_current_thread(lock));
    
    	if (lock->holder) //lock->holderê°€ ìˆë‹¤ë©´,
    	{
    		struct thread *cur_t = thread_current();
    
    		cur_t->wait_on_lock = &lock; //ë‚´ê°€ í•„ìš”í•œ lockì„ ê¸°ë¡
    		cur_t->init_priority = cur_t->priority; //donationë°›ê¸° ì „, ë‚´ ì›ë˜ priorityê¸°ë¡
    		donate_priority(); //ë„ë„¤ì´ì…˜ í•´ì„œ lockë¹¨ë¦¬ì¨ì„œ ë‚´ë†”ë¼.
    	}
    
    	sema_down(&lock->semaphore); 			// lockì“°ê¸°
    	thread_current()->wait_on_lock = NULL;  //ê¸°ë‹¤ë¦¬ëŠ” lockì—†ìœ¼ë¯€ë¡œ wait_on_lock ì´ˆê¸°í™”
    	lock->holder = thread_current();		// í˜„ì¬ threadê°€ lock->holderê°€ ë˜ëŠ” ê²ƒ
    }
    ```

    ì°¨ì´: donate_priority()í•¨ìˆ˜ì—ì„œ list_insert_ordered()ë¥¼ ì‚¬ìš©

- ìµœì¢…ì½”ë“œ

    ```c
    void lock_acquire(struct lock *lock)
    {
    	ASSERT(lock != NULL);
    	ASSERT(!intr_context());
    	ASSERT(!lock_held_by_current_thread(lock));
    
    	struct thread *cur_t = thread_current();
    
    	if (lock->holder != NULL)
    	{
    		cur_t->wait_on_lock = lock;
    		// cur_t->init_priority = cur_t->priority; ğŸ¤”
    		list_insert_ordered(&lock->holder->donations, &cur_t->donation_elem,
    							donate_priority_less, 0); // ì¶”ê°€ ğŸ¤”
    		donate_priority();
    	}
    
    	sema_down(&lock->semaphore);
    	cur_t->wait_on_lock = NULL;
    	lock->holder = thread_current();
    }
    ```

# 4. thread_compare_donate_priority()êµ¬í˜„ x

thread/thread.c

- ì •ë‹µ

    ```c
    bool
    thread_compare_donate_priority (const struct list_elem *l, 
    				const struct list_elem *s, void *aux UNUSED)
    {
    	return list_entry (l, struct thread, donation_elem)->priority
    		 > list_entry (s, struct thread, donation_elem)->priority;
    }
    ```

- êµ¬í˜„1

    ```c
    ë‹¤ë¥¸ í•¨ìˆ˜ì—ì„œ ë¹„êµí•˜ê¸´ í–ˆìœ¼ë‚˜, ì´ì „ì— êµ¬í˜„í•œ priority_lessí•¨ìˆ˜ ì‚¬ìš©.
    ```

- ìµœì¢…ì½”ë“œ

    ```c
    bool donate_priority_less(struct list_elem *a, struct list_elem *b,
    						  void *aux UNUSED)
    {
    	struct thread *t_a = list_entry(a, struct thread, elem);
    	struct thread *t_b = list_entry(b, struct thread, elem);
    	return (t_a->priority) > (t_b->priority);
    }
    ```

# 5. donate_priority() êµ¬í˜„ x

threads/synch.c

- ì •ë‹µ

    ```c
    void
    donate_priority (void)
    {
      int depth;
      struct thread *cur = thread_current ();
    
      for (depth = 0; depth < 8; depth++){
        if (!cur->wait_on_lock) break;
          struct thread *holder = cur->wait_on_lock->holder;
          holder->priority = cur->priority;
          cur = holder;
      }
    }
    ```

- êµ¬í˜„(ì§„êµ)

    ```c
    void donate_priority(void)
    {
    	struct lock *need_lock = thread_current()->wait_on_lock;
    	struct thread *lock_holder_t = need_lock->holder; // ì–˜ê°€ lockì„ 2ê°œ ê°€ì§€ê³  ìˆìœ¼ë©´ multi
    	struct list donation_list = lock_holder_t->donations;
    
    	// donation_listì— current()ë¥¼ ë„£ì–´.
    	list_push_front(&donation_list, &(thread_current()->donation_elem));
    	// ê·¸ë‹¤ìŒ donation_listê°€ ë¹Œë•Œê¹Œì§€...?
    	for (struct list_elem *find = list_begin(&donation_list); find != NULL; find = list_next(find))
    	{
    		lock_holder_t->priority = list_entry(list_front(&donation_list), struct thread, donation_elem)->priority;
    	}
    }
    ```

- êµ¬í˜„(ì„¸ë ¹)

    ```c
    void donate_priority(void)
    {
    	struct thread *cur = thread_current();	 // í˜„ì¬ ìŠ¤ë ˆë“œ
    	struct lock *lock = (cur->wait_on_lock); // ê¸°ë‹¤ë¦¬ê³  ìˆëŠ” ë½
    	int depth = 0;							 // ì¤‘ì²© ê¸°ë¶€ì˜ ê¹Šì´
    	while (lock != NULL && depth < 8)
    	{ // ìµœëŒ€ 8ë‹¨ê³„ê¹Œì§€ ìˆ˜í–‰
    		depth++;
    		struct thread *holder = lock->holder; // ë½ì˜ ì†Œìœ ì
    		if (holder == NULL)
    		{
    			break;
    		}
    		if (holder->priority < cur->priority)
    		{									  // ìš°ì„ ìˆœìœ„ê°€ ë” ë†’ì€ ê²½ìš°
    			holder->priority = cur->priority; // ìš°ì„ ìˆœìœ„ ê¸°ë¶€ ìˆ˜í–‰
    			if (holder->wait_on_lock != NULL)
    			{								   // ë½ì„ ê¸°ë‹¤ë¦¬ëŠ” ìŠ¤ë ˆë“œê°€ ìˆë‹¤ë©´
    				lock = (holder->wait_on_lock); // ë‹¤ìŒ ë½ìœ¼ë¡œ ì´ë™
    			}
    			else
    			{
    				break;
    			}
    		}
    		else
    		{
    			break;
    		}
    	}
    }êµ¬í˜„
    ```

- êµ¬í˜„(ì¤€ìˆ˜)

    ```c
    void lock_acquire(struct lock *lock)
    {
    	ASSERT(lock != NULL);
    	ASSERT(!intr_context());
    	ASSERT(!lock_held_by_current_thread(lock));
    
    	if (lock->holder)
    	{
    		thread_current()-> wait_on_lock = lock;
    		thread_current()->init_priority = thread_current()->priority;
    		list_push_front(&lock->holder->donations, &lock->holder->elem);
    		if (lock->holder->wait_on_lock){
    			lock_acquire(lock->holder->wait_on_lock);
    		}
    	};
    	sema_down(&lock->semaphore);
    	thread_current()->wait_on_lock = NULL;
    	lock->holder = thread_current();
    }
    ```

- ìµœì¢…ì½”ë“œ

    ```c
    /* í˜„ì¬ ìŠ¤ë ˆë“œê°€ lockì„ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ” ê²½ìš°, lockì„ ë³´ìœ í•˜ê³  ìˆëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ìš°ì„ ìˆœìœ„ë¥¼ í˜„ì¬ ìŠ¤ë ˆë“œì˜ ìš°ì„ ìˆœìœ„ë¡œ ì—…ë°ì´íŠ¸(donation)í•˜ëŠ” í•¨ìˆ˜ */
    void donate_priority(void)
    {
    	struct thread *cur = thread_current();
    	int depth;
    	for (depth = 0; depth < 8; depth++) /* nested donationì˜ ì œí•œ */
    	{
    		if (!cur->wait_on_lock) /* í˜„ì¬ íƒìƒ‰ ì¤‘ì¸ ìŠ¤ë ˆë“œê°€ í•„ìš”ë¡œ í•˜ëŠ” ë½ì´ ì—†ìœ¼ë©´(ì¢…ë£Œ ì§€ì ) */
    			break;
    
    		struct thread *holder = cur->wait_on_lock->holder;
    		holder->priority = cur->priority; /* priority donation */
    		cur = holder;					  /* í•„ìš”í•œ lockì˜ holderë¥¼ íƒìƒ‰ ìŠ¤ë ˆë“œë¡œ ì„¤ì • */
    	}
    }
    ```

# 6. remove_with_lock()

threads/synch.c

- ì •ë‹µ

    ```c
    void
    remove_with_lock (struct lock *lock)
    {
      struct list_elem *e;
      struct thread *cur = thread_current ();
    
      for (e = list_begin (&cur->donations); e != list_end (&cur->donations); e = list_next (e)){
        struct thread *t = list_entry (e, struct thread, donation_elem);
        if (t->wait_on_lock == lock)
          list_remove (&t->donation_elem);
      }
    }
    ```

- êµ¬í˜„

    ```c
    void remove_with_lock(struct lock *lock)
    {
    	if (lock->holder != NULL)
    	{
    		struct list *donation_list = &lock->holder->donations;
    		struct list_elem *find;
    		for (find = list_begin(donation_list); find != list_end(donation_list); find = list_next(find))
    		{
    			if (list_entry(find, struct thread, donation_elem)->wait_on_lock == lock)
    			{
    				list_remove(find);
    			}
    		}
    	}
    }
    ```

```c

```

# 6. refresh_priority()í•¨ìˆ˜ êµ¬í˜„

- ì •ë‹µ

    ```c
    void
    refresh_priority (void)
    {
      struct thread *cur = thread_current ();
    
      cur->priority = cur->init_priority;
      
      if (!list_empty (&cur->donations)) {
        list_sort (&cur->donations, thread_compare_donate_priority, 0);
    
        struct thread *front = list_entry (list_front (&cur->donations), struct thread, donation_elem);
        if (front->priority > cur->priority)
          cur->priority = front->priority;
      }
    }
    ```

- êµ¬í˜„

    ```c
    void refresh_priority(void)
    {	
    	int curr_pri = thread_current()->priority;
    	curr_pri = thread_current()->init_priority;
    
    	int don_max_pri = list_entry(list_begin(&(thread_current()->donations)), struct thread, elem)->priority;
    	if (don_max_pri > curr_pri)
    	{
    		curr_pri = don_max_pri;
    	};
    }
    ```

- ìµœì¢…ì½”ë“œ

    ```c
    void refresh_priority(void)
    {
    	struct thread *curr = thread_current();
    	curr->priority = curr->init_priority;
    
    	if (!list_empty(&curr->donations))
    	{
    		list_sort(&curr->donations, donate_priority_less, 0);
    
    		struct thread *front = list_entry(list_front(&curr->donations), struct thread, donation_elem);
    
    		if (front->priority > curr->priority)
    			curr->priority = front->priority;
    	}
    
    	// ğŸ¤”
    	// int don_max_pri = 0;
    	// if (!list_empty(&curr->donations))
    	// {
    	// 	list_entry(list_max(&(thread_current()->donations), priority_less, NULL), struct thread, elem)->priority;
    	// }
    	// if (don_max_pri > curr->priority)
    	// {
    	// 	curr->priority = don_max_pri;
    	// };
    }
    ```

# 7. lock_release() êµ¬í˜„

thread/synch.c

- ì •ë‹µ

    ```c
    void
    lock_release (struct lock *lock) 
    {
      ASSERT (lock != NULL);
      ASSERT (lock_held_by_current_thread (lock));
    
      remove_with_lock (lock);
      refresh_priority ();
      
      lock->holder = NULL;
      sema_up (&lock->semaphore);
    }
    ```

- êµ¬í˜„

    ```c
    void lock_release(struct lock *lock)
    {
    	ASSERT(lock != NULL);
    	ASSERT(lock_held_by_current_thread(lock));
    
    	lock->holder = NULL;
    	remove_with_lock(lock);
    	refresh_priority();
    	sema_up(&lock->semaphore);
    }
    ```

- ìµœì¢…ì½”ë“œ

    ```c
    void lock_release(struct lock *lock)
    {
    	ASSERT(lock != NULL);
    	ASSERT(lock_held_by_current_thread(lock));
    
    	lock->holder = NULL;
    	remove_with_lock(lock);
    	refresh_priority();
    	sema_up(&lock->semaphore);
    }
    
    bool lock_held_by_current_thread(const struct lock *lock)
    {
    	ASSERT(lock != NULL);
    
    	return lock->holder == thread_current();
    }
    ```

# 8. thread_set_priority()ìˆ˜ì •

threads/thread.c

- ì •ë‹µ

    ```c
    void
    thread_set_priority (int new_priority) 
    {
      thread_current ()->init_priority = new_priority;
      
      refresh_priority ();
      thread_test_preemption ();
    }
    ```

- êµ¬í˜„

    ```c
    void thread_set_priority(int new_priority)
    {
    	thread_current()->priority = new_priority;
    	thread_current()->init_priority = new_priority;
    
    	refresh_priority();
    	donate_priority();
    	test_max_priority();
    }
    ```

- ìµœì¢…ì½”ë“œ

    ```c
    void thread_set_priority(int new_priority)
    {
    	thread_current()->init_priority = new_priority;
    
    	refresh_priority();
    	test_max_priority();
    }
    ```