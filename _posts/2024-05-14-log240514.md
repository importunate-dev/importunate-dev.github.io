---
layout: post
title: ' QA 지옥 '
subtitle: ' 2024년 5월 14일 화요일 '
catalog: true
category: log
subcategory: weekly
tags:
  - log
  - weekly
  - may
  - 2024
  - shopify

---

# Today I Learned

## 날짜

2024년 5월 14일 화요일

## 내용

### QA

제법, 아니 꽤 많이 미완성인채로 일정대로 QA가 진행됐다. 자질구레한 것 여러가지를 뜯어고쳤고, 앞으로도 뜯어 고칠게 참 많다.

### 앱 삭제 기능

쇼피파이에서 고객이 앱을 삭제하면 웹훅을 이용해 우리 서비스에 호출을 보낸다. 그럼 우리 서버 내에 데이터들을 삭제해주어야 한다. 이 기능이 작동을 안하고 있다. 따로 엔드포인트를 이용하면 기가막히게 삭제가 되는데… 주소가 잘못 되어있는 것 같아 수정하고, 기능이 새 앱에서는 작동되지 않도록 설정되어 있어 그 부분도 손봤는데 여전히 작동하지 않는다. elastic apm을 홗인해보니 웹훅을 처리하는 라우터 자체가 호출된 흔적이 없었다. 기존에 있던 웹훅 조회하는 함수를 조금 손봐서 새 앱에도 쓸 수 있게 해봤는데, 웹훅 조회자체가 안된다. 없을 거라 예상했는데 조회가 안되는건 예상 못했는데..  

### 데이터 업데이트

브라우저 부스터 앱의 설정을 수정하였을 때, 데이터가 업데이트 되지 않는다. 500 에러가 뜨고있었다. 코드를 확인해보니 데이터베이스의 필드가 문제였다. 두 앱은 각자 별개로 상품 데이터를 받고 있다. 따라서 데이터를 각자의 테[이블로 담고있는데, 먼저 있던 것은 `product`고 새로 만든 테이블은 `secondary_product`다.  데이터를 업데이트할 때, 이벤트에 추가되어야 할 상품 데이터도 포함되는데 이 상품을 지정하는데 문제가 있었다. 프론트에선 `product_ids`이름으로 보내고, 우리 데이터에는 `secondary_product_ids` 필드에 저장해야 한다. 스키마와 데이터베이스를 orm_mode로 처리하다보니, 필요한 필드가 없어 문제가 생겼다. orm_mode가 True일때는 스키마의 필드 이름과 데이터베이스 필드 이름이 일치해야한다. 프론트 쪽을 바꾸면 여러가지로 복잡해질 것이라 생각해서 데이터베이스의 필드 이름도 product_ids로 바꿔주었다. 어차피 브라우저 부스터 앱 내에서만 사용될 테이블이고 기존 테이블과는 전혀 의존성을 맺지 않도록 설정할 것이기 때문에 오류의 가능성은 없다고 생각했다.

### 메타필드

브라우저 부스터 앱이 실행되어 스토어 화면에 표시될 때, 디자인 값들 (표시 위치, 색깔 등)은 메타필드에 저장한 값을 불러온다. 따라서 브라우저 부스터 이벤트 데이터가 업데이트되면, DB에 저장한 후 메타필드에도 업로드해줘야 한다. 메타필드가 설정되지 않는 문제가 있었다. 2번 문제로 인해, 데이터 업데이트 함수가 500 에러를 내면서 그 내부에서 동작해야할 메타필드 업로드 함수가 작동하지 않은 문제였다. 2번을 해결하니 자연스레 해결되었다. 다만, 알파 플러스 앱에서만 쓰는 리뷰 레이팅 모듈을 위한 메타필드도 삽입되고 있어서, 이 부분은 삭제했다.

### 회원의 쿠폰 상태값

백엔드의 로직으로 생각했을 때, 나는 회원에게 쿠폰을 제공하는 라우터와 회원의 쿠폰 사용 상태를 말해주는 라우터를 구분했다. 어떤 유저가 브라우저 부스터 미션을 완료해서 쿠폰을 요청해야 할 때, 미션을 완료하지 않은 상태(아직 재참여 기간이 도래하지 않았거나, 이미 참여 횟수를 초과)에서 최근 발급받은 쿠폰의 상태만 반환하는 함수를 나누었다는 의미다. 하나로 합치면 한 엔드포인트 내에서 너무 많은 로직이 발생할 거라고 우려했기 떄문이다. 프론트의 입장을 간과했는데, 내 방식대로 처리하려면 프론트가 언제 어떤 요청을 보내야할 지를 알고 있어야 한다. 이 유저는 쿠폰 코드를 요청해야 하는가? 혹은 최근 발급된 쿠폰의 상태만 발급되야 하는가? 를 저장하고 있어야 한다. 프론트의 데이터보단 서버의 데이터를 신뢰하는 것이 바람직하다고 생각하고, 이미 내 나름대로 유저의 참여 가능 여부를 검증하는 로직을 구현해 놨기 떄문에 두 요청을 하나로 합칠 수 있었다. 프론트는 항상 한 엔드포인트로만 요청을 보내면 된다. 서버가 요청을 보낸 고객의 재참여 가능성 여부를 검토하고 가능하면 새 할인 쿠폰을, 불가능하면 최근 발급된 쿠폰과 그 상태를 반환해주면 된다. 항상 책에 나온대로, 깔끔한 로직과 구성만 따르기 보단 서비스 전체의 흐름을 따지는게 필요하다.

### ngrok

앱을 설치할 때 처음에 502 오류가 뜬다. 새로고침 하면 잘 작동하지만 그냥 냅둘 순없다. 사실 내가 회사에 처음들어와서 테스트 앱을 설치할 때도 떴던 오류긴 한데.. 이참에 고치고 싶었다. 어제 설명한대로, 앱을 설치할 때는 쇼피파이와 앱 서버(테스트 서버)가 이것 저것 주고받지만 ngrok을 통해 나와 주고받도록 설정해 줄 수 있다. 이떄 프론트로도 통신이 오고가는데 localhost다보니 https 가 아닌 http고, 그래서 SSL 에러가 반환된다. 프론트도 localhost가 아닌 ngrok을 이용한 포트포워딩을 사용하면 된다고 배웠다. 서버와 프론트 둘다 처리하기 위해선 ngrok 유료플랜이 필요하다. 무료플랜은 한번에 한 세션밖에 처리하지 못한다. 꼭 고치겠다는 마음에 1달 10달러 짜리를 결제했다. 근데 포트만 2곳이 열린다..

9000 port로 오는것과 2500 port로 오는것을 모두 80port르 오게만 된다… 내가 원하는건 9000 port로 오는것은 8002 port, 2500 port로 오는 것은 80 port로 각각 포워딩 하길 원했는데.. 이러기 위해선 추가적인 설정이 필요해보이는데 되게 복잡해보인다. 어쩌겠어.. 해봐야지…

## 회고

고쳐도 고쳐도 끝이 없구만