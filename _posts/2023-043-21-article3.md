---
layout: post
title: "PintOS thread.c 내용 알아보기"
subtitle:   " Pintos 1주차 "
catalog: true
tags:
    - article
    - PintOS
    - thread

---

# PintOS 파일 내 해석



## 1. thread.c

- ### `thread_start`

```c
/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) {
    /* Create the idle thread. */
	//스케쥴러 시작하기위해 호출
	// ready상태인 스레드가 없으면 스케쥴 될수있는 idle thread만듬
	// main()이나 intr_yield_on_return()을 사용하는 인터럽트 가능하게 만듬
	struct semaphore idle_started;
	sema_init (&idle_started, 0);
	thread_create ("idle", PRI_MIN, idle, &idle_started);

	/* Start preemptive thread scheduling. */
	intr_enable ();

	/* Wait for the idle thread to initialize idle_thread. */
	sema_down (&idle_started);
}
```



- ### `thread_tick`

```c
/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) {
	struct thread *t = thread_current ();
	//timer tick의 timer interrupt 호출
	// time slice가 만료되었을때, 스케쥴러를 가동
	// 스레드 통계 가짐
```



- ### `thread_print_stats`

```c
/* Prints thread statistics. */
void
thread_print_stats (void) {
	printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
			idle_ticks, kernel_ticks, user_ticks);
}
//스레드가 shutdown일 때 호출, 통계 출력
```



- ### `thread_func`

```c
// 인자 name으로 스레드 만들고 시작. 만들어진 스레드의 tid 반환 -> 스레드가 인자 func를 실행 -> 인자 *aux는 func의 인자 나타냄
// 밑에 것은 스레드의 페이지를 할당, 스레드의 멤버 초기화, 스레드 스택 할당
// 스레드는 blocked state 상태에서 초기화, 반환 직전 unblock됨 => 스레드가 스케쥴 할 수 있도록 하기 위함

// void thread_func (void *aux); : 스레드로 실행되는 함수의 type, 인자*aux는 이 함수의 인자를 나타냄
tid_t
thread_create (const char *name, int priority,
		thread_func *function, void *aux) {
	struct thread *t;
	tid_t tid;

	ASSERT (function != NULL);

	/* Allocate thread. */
	t = palloc_get_page (PAL_ZERO);
	if (t == NULL)
		return TID_ERROR;

	/* Initialize thread. */
	init_thread (t, name, priority);
	tid = t->tid = allocate_tid ();
```





- ### `thread_unblock`

```c
// blocked 쓰레드를 READY로
void
thread_unblock (struct thread *t)
```



- ### `thread_exit`

```c
// 현재 스레드 나가게함, 비가역적
void
thread_exit (void) {
	ASSERT (!intr_context ());

#ifdef USERPROG
	process_exit ();
#endif

	/* Just set our status to dying and schedule another process.
	   We will be destroyed during the call to schedule_tail(). */
	intr_disable ();
	do_schedule (THREAD_DYING);
	NOT_REACHED ();
}
```



- ### `thread_yield`

```c
// 스케쥴러가 새로운 스레드를 가동할 수 있도록 스케쥴러에 CPU 할당
// 새로운 스레드가 current 쓰레드로 바귐
// 그래서 스레드를 잠깐 runnig상태 못벗어나게 만들려고 쓰는건 안됨

void
thread_yield (void) {
	struct thread *curr = thread_current ();
	enum intr_level old_level;

	ASSERT (!intr_context ());

	old_level = intr_disable ();
	if (curr != idle_thread)
		list_push_back (&ready_list, &curr->elem);

	do_schedule (THREAD_READY);
	intr_set_level (old_level);
}
```



