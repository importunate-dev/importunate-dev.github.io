---
layout: post
title: "230904 알고리즘 문제풀이"
subtitle: " 백준 1167 "
catalog: true
category: study
subcategory: algorithm
tags:
  - 백준
  - algorithm
  - study
  - 1167

---

# 2023년 9월 4일 알고리즘 문제풀이

## 문제 1 백준 1167

[문제 링크](https://www.acmicpc.net/problem/1167)

### 1차 시도

#### 나의 생각

입력값을 list로 받은 후 가장 앞인 0번 index는 어떤 정점의 정보인지를 나타낸다고 생각하였고 그 이후 둘 씩 짝지어서 도착 정점과 거리로 설정하였다. 이를 바탕으로 인접리스트를 만들고 index를 2씩 뛰어넘어 -1이 나오면 더이상 정보가 없으므로 다음 줄로 넘어갔다.

이후에는 두 점간의 거리를 bfs를 통해 탐색하도록 하였다. 모든 점간의 거리를 찾아 최댓값을 도출하였다. 하지만 메모리,시간초과가 뜬다... 다찾아보면 안되나보다.

#### 결과

오답(메모리, 시간 초과)

#### 코드

```python
import sys
from heapq import heappop, heappush
v = int(sys.stdin.readline())
tmp = []
for _ in range(v):
    tmp.append(list(map(int,sys.stdin.readline().split())))
    
graph = [[] for _ in range(v+1)]
for l in tmp:
    x = 1
    while x < len(l):
        if l[x] == -1:
            break
        graph[l[0]].append([l[x],l[x+1]])
        x += 2

def bfs(a,b):
    visited = [False for _ in range(v+1)]
    visited[a] = True
    arr = []
    heappush(arr,[0,a])
    while arr:
        cnt, now = heappop(arr)
        cnt *= -1
        if now == b:
            return cnt
        for next in graph[now]:
            if not visited[next[0]]:
                visited[next[0]] = True
                heappush(arr,[-1*(cnt+next[1]),next[0]])
                
ans = 0
for start in range(1,v+1):
    for arrive in range(1,v+1):
        ans = max(ans,bfs(start,arrive))
print(ans)
```

### 2차 시도

#### 나의 생각

문제를 계속 읽다가 **트리**에 꽂혔다. 트리에서 아무 점이나 골랐을 때, 가장 멀리 있는 점은 루프노트를 기준으로 반대쪽에 가장 끝에 있는 정점일 것이다. 물론 거리는 그때 그때 다르겠지만.. 어쩄든 확실한건 임의의 점을 고른 후 거기서 가장 멀리 있는 점을 찾으면 트리의 한쪽 끝에 있는 정점을 찾을 수 있다! 그 점에서 다시 가장 멀리 있는 점을 구하면? 문제에서 말하는 트리의 지름을 구할 수 있다.

기존 코드에서는 정점간의 거리를 구했지만, 이렇게 하면 한 정점에서 다른 정점까지의 거리를 구하는 것을 2번만 하면 되니 리소스 문제도 해결된다!

#### 결과

정답

#### 코드

```python
import sys
from heapq import heappop, heappush
v = int(sys.stdin.readline())
tmp = []
for _ in range(v):
    tmp.append(list(map(int, sys.stdin.readline().split())))

graph = [[] for _ in range(v+1)]
for arr in tmp:
    x = 1
    while x < len(arr):
        if arr[x] == -1:
            break
        graph[arr[0]].append([arr[x], arr[x+1]])
        graph[arr[x]].append([arr[0], arr[x+1]])
        x += 2


def bfs(a):
    visited = [0 for _ in range(v+1)]
    q = []
    heappush(q, [0, a])
    while q:
        cnt, now = heappop(q)
        cnt *= -1
        for next in graph[now]:
            if not visited[next[0]] and next[0] != a:
                visited[next[0]] = cnt+next[1]
                heappush(q, [-1*(cnt+next[1]), next[0]])
    max_val = max(visited)
    return [max_val, visited.index(max_val)]


tmp = bfs(1)[1]
ans = bfs(tmp)
print(ans[0])

```

