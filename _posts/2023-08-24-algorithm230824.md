---
layout: post
title: "230824 알고리즘 문제풀이"
subtitle: " 백준 1916, 백준 2665, 백준 7569"
catalog: true
category: study
subcategory: algorithm
tags:
  - 백준
  - algorithm
  - study
  - 1916
  - 2665
  - 7569
  - 다익스트라
---

# 2023년 8월 17일 알고리즘 문제풀이

## 문제1 백준 1916

[문제 링크](https://www.acmicpc.net/problem/1916)

### 1차 시도

#### 나의 생각

이전에 공부한 다익스트라로 풀면 되겠다고 생각했다. 출발지부터 각 도착지까지 비용을 표시하는 배열을 만들고 최소값으로 업데이트하였다. 그런데 이상하게 오답처리가 된다. 이유를 찾아봐야겠다.

#### 결과

오답

#### 코드

```python
import sys
from heapq import heappop, heappush

n = int(sys.stdin.readline())
m = int(sys.stdin.readline())

graph = [[0 for _ in range(n+1)] for _ in range(n+1)]
for _ in range(m):
    s, a, c = map(int, sys.stdin.readline().split())
    graph[s][a] = c
start, arrive = map(int, sys.stdin.readline().split())


def search(x):
    cost = [10**9 for _ in range(n+1)]
    cost[x] = 0
    arr = []
    heappush(arr,[0, x])
    while arr:
        price, now = heappop(arr)
        if price > cost[now]:
            continue
        for i in range(1, n+1):
            if not graph[now][i]:
                continue
            new_money = price + graph[now][i]
            if new_money < cost[i]:
                cost[i] = new_money
                heappush(arr,[new_money, i])
    return cost


ans = search(start)
print(ans[arrive])
```

### 2차 시도

#### 나의 생각

원인을 찾아냈다. 나는 두 도시간의 비용을 인접행렬로 표현했다. 즉 행렬의 값이 두 도시의 이동 비용이다. 하지만 문제에서 각 도시 간의 노선이 하나라는 보장이 없다.. 그래서 두 도시간의 버스 비용이 중복해서 주어진다면 내 코드는 가장 마지막에 입력된 것만 나타내게 된다. 하지만 먼저 입력된 버스비용이 더 작다면? 내 코드에선 정답을 도출할 수 없었다.

따라서 인접 리스트로 표현했다.

#### 결과

정답

#### 코드

```python
import sys
from heapq import heappop, heappush

n = int(sys.stdin.readline())
m = int(sys.stdin.readline())

graph = [[] for _ in range(n+1)]
for _ in range(m):
    s, a, c = map(int, sys.stdin.readline().split())
    graph[s].append([c, a])
start, arrive = map(int, sys.stdin.readline().split())


def search(x):
    cost = [10**9 for _ in range(n+1)]
    cost[x] = 0
    arr = []
    heappush(arr, [0, x])
    while arr:
        price, now = heappop(arr)
        if price > cost[now]:
            continue
        for money, next in graph[now]:
            new_money = price + money
            if new_money < cost[next]:
                cost[next] = new_money
                heappush(arr, [new_money, next])
    return cost


ans = search(start)
print(ans[arrive])

```

---

## 문제 2 백준 2665

[문제 링크](https://www.acmicpc.net/problem/2665)

### 1차 시도

#### 나의 생각

계속되는 다익스트라! 이번엔 다음 탐색할 곳이 검은색일때마다 이전보다 비용을 1 더해주고, 하얀색이면 유지되도록 하였다.

#### 결과

정답

#### 코드

```python
import sys
from heapq import heappop, heappush

n = int(sys.stdin.readline())
board = []
for _ in range(n):
    board.append(list(sys.stdin.readline().rstrip()))

da = [0, -1, 0, 1]
db = [1, 0, -1, 0]


def search(p, q):
    cnt = [[10**9 for _ in range(n)] for _ in range(n)]
    cnt[p][q] = 0
    arr = []
    heappush(arr, [0, p, q])
    while arr:
        cost, a, b = heappop(arr)
        for i in range(4):
            na = a + da[i]
            nb = b + db[i]
            if na < 0 or na > n-1 or nb < 0 or nb > n-1:
                continue
            if board[na][nb] == '0':
                new_value = cost + 1
            else:
                new_value = cost
                
            if cnt[na][nb] == 10**9:
                cnt[na][nb] = new_value
                heappush(arr, [new_value, na, nb])
            else:
                if new_value < cnt[na][nb]:
                    cnt[na][nb] = new_value
                    heappush(arr, [new_value, na, nb])
    return cnt


ans = search(0, 0)
print(ans[n-1][n-1])

```

---

