---
layout: post
title: " 파이썬 알고리즘 : 점프와 순간 이동 "
subtitle: " 수학적 사고 "
catalog: true
category: study
subcategory: algorithm
tags:
  - 프로그래머스
  - algorithm
  - study
  - python
  - dp

---

# 2024년 3월 4일 알고리즘 문제풀이

## 문제

- [점프와 순간 이동](https://school.programmers.co.kr/learn/courses/30/lessons/12980)

### 난이도

Lv.2

### 코드

일반적인 DP문제라고 생각했다. 조금 어려운 편이긴 하지만, 기존에 충분히 풀어봤던 유형이라 금방 풀 수 있었다. 도착지로 이동하는 마지막 방법을 **점프**라고 고정하고 생각했다. 

#### 1차

```python
def solution(n):
    # 3칸까지는 고려할 필요 없음
    if n <= 3:
        dp = [0, 1, 1, 2]
        return dp[n]
    
    # 그 이상일 때는 DP 준비
    # 가장 최대일때는 그곳까지 점프로만 도달했을 때.
    dp = []
    for i in range(n + 1):
        dp.append(i)
    dp[2] = 1
    dp[3] = 2

    for i in range(4, n + 1):
        k = i // 2
        # 홀수여서 딱 절반인 곳이 존재하지 않을 때
        if i % 2:
            for j in range(k, i):
                dp[i] = min(dp[i], dp[j] + i - j)
        # 짝수여서 절반인 곳이 존재할 때
        else:
            # 절반일 ㄸ
            dp[i] = min(dp[i], dp[k])
            for j in range(k + 1, i):
                dp[i] = min(dp[i], dp[j] + i - j)
    return dp[n]
```

 n칸 까지 갈 때, 절반인 n//2를 기준으로 생각하면 된다. 절반도 오지 못했을 떄 점프를 하는 것은 거기서 순간이동 하는 것보다 더 건전지 사용량이 소모될 것이기 때문이다. 예를 들어, 10 칸을 이동한다고 했을 때 

1. 4칸 + (6칸을 점프) = 10칸 도착

이라는 시나리오는 고려할 필요가 없다는 의미이다.

1. 4칸 + (순간이동하여 8번째 칸으로 이동) = 8칸도착

2. 8칸 + (2칸을 점프) = 10칸

목적지의 절반을 도달하지 못했을 때는 항상 이 경우가 존재하기 떄문에 반복에서 제외했다. 따라서 목적지의 절반 이상일 때만 고려했다. 하지만 딱 절반일 때가 존재할때는 특별한 분기로 처리했다. 딱 절반인 지점에서 순간이동하면 곧바로 도착하기 떄문에, 절반 까지의 건전지 소모량으로 도착할 수 있기 떄문이다.

 정확도에선 모두 맞았으나, 효율성에서 모두 시간초과되어 60/100점 처리되었다.

#### 1차

#### 2차

```python
def solution2(n):
    while True:
        if not n % 2:
            n //= 2
        else:
            break
    if n <= 3:
        dp = [0, 1, 1, 2]
        return dp[n]
    dp = []
    for i in range(n + 1):
        dp.append(i)
    dp[2] = 1
    dp[3] = 2

    for i in range(4, n + 1):
        k = i // 2
        if i % 2:
            for j in range(k, i):
                dp[i] = min(dp[i], dp[j] + i - j)
        else:
            dp[i] = min(dp[i], dp[k])
            for j in range(k + 1, i):
                dp[i] = min(dp[i], dp[j] + i - j)
    return dp[n]
```



#### 3차

```python
def solution3(n):
    while True:
        if not n % 2:
            n //= 2
        else:
            break
    if n <= 3:
        dp = [0, 1, 1, 2]
        return dp[n]
    dp = []
    for i in range(n + 1):
        dp.append(i)
    dp[2] = 1
    dp[3] = 2

    for i in range(4, n + 1):
        if i % 2:
            dp[i] = dp[i - 1] + 1
        else:
            dp[i] = dp[i // 2]
    return dp[n]
```



#### 최종

```python
def solution(n):
    cnt = 0
    while n > 3:
        if not n % 2:
            n //= 2
        else:
            cnt += 1
            n -= 1
    if n <= 3:
        dp = [0, 1, 1, 2]
        return dp[n] + cnt
```

