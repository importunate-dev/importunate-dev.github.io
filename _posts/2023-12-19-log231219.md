---
layout: post
title: ' SQL은 어려워 '
subtitle: ' 2023년 12월 19일 화요일 '
catalog: true
category: log
subcategory: weekly
tags:
  - log
  - December
  - 2023
  - demo
  - PostgreSQL
  - joinedload
  - SQL
  - eager loading
  - subqueryload
---

# Today I Learned

## 날짜

2023년 12월 19일 화요일

## 내용

너무 힘들다. 흑흑

### SQL

 데모 로그인은 로그인의 로직을 이용해 만들었다. 로그인 함수가 호출되면, 해당 계정 정보가 관계를 갖고 있는 shop들을 불러와 `shops` 라는 배열에 담는다. 데모 로그인 때는, 가져온 후 데모로 설정한 shop_id와 일치하는 것만 남기도록 처리하였다. 이 과정이 DB에 영향을 끼치지 않도록 하기 위해, DB에 최근 접근 시간을 업데이트하고 commit하는 이후에 해당 로직을 추가하였다.

 shop들을 가져와 배열에 담는 joinedload에 특정한 조건을 추가하는 코드를 작성해야 했다. 사실 이 부분에서도 많이 헷갈렸는데, joinedload가 일반 join과 다른 점은 eager loading이라느 것이다. 간단히 말하자면 lazy-loading은 레코드를 조회할 때 연관관계가 있는 데이터들의 조회를 필요한 순간까지 미루는 것이고 eager-loading은 레코드를 조회할 때 연관이 있으면 다 가져와놓는 것이다. 지금 고민하는 부분과는 다른 이야기이니 차치하고, join과는 언제 연관된 데이터를 갖고 오느냐만 다르다는 의미이다.

 join으로 연관된 데이터를 가져올 때 당연히 조건을 설정할 수 있듯이, joinedload도 가능할 것이라고 생각했는데, 아무리 찾아봐도 직접적으로는 불가능하다고 한다. subqueryload는 다른 목적으로 사용된다고 뜨고, 굳이 할려면 join을 한후 `contains_eager` 의 형태를 쓰는 것 같은데… 아직 정리가 확실히 안되서 그런지 참 어렵다. 이게 왜 아직도 정리가 안되었는지는 다음에 나온 것이 원인…

### db.commit()

 사실 shops에 원하는 shop만 가져오는 것은 굳이 joinedload를 사용하지 않는다면 가능은 하다. 위에서 말했듯 join문을 쓰면 편해지는 문제다. 나에게 핵심은 joinedload 와 subqueryload의 사용으로 원하는 조건을 설정하는 것이다. 열심히 이것저것 시도해봤는데, 계속 화면에는 원하는대로 나타나지 않았다. 그리고 이것의 원인이 쿼리문이 아닐 지도 모른다는 것을 7시간 후에야 알았다.

 (데모) 로그인 함수에는 최근 계정에 접근한 시간을 업데이트해서 DB에 저장하는 함수가 있는데, 여기서 `db.commit()` 이 호출되면 현재 내가 들고있는 계정 객체가 refresh된다… 즉 내가 짠 쿼리문이 제대로 작동하지 않아서 데모 어드민 페이지가 뜨지 않는건지, 제대로 작동은 됐지만 계속 refresh 되서 반영이 안되었던 건지 알 방법이 없다… SQLAlchemy ORM이 객체를 자동 동기화해주는 구나!

 그럼 애초에 제대로 갖고와도 객체가 refresh되면 의미가 없지않나..? 내일은 이 고민을 끝내야 좀 나아갈 수 있겄다.

## 회고

어제 풀려는 고민은 해결 못하고 새로운 골칫거리만 생겼다. 신난당.
