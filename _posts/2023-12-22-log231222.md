---
layout: post
title: ' 좋은 마무리 '
subtitle: ' 2023년 12월 22일 금요일 '
catalog: true
category: log
subcategory: weekly
tags:
  - log
  - weekly
  - December
  - 2023
  - string
  - number
  - SEO
  - robots
  - sitemap
  - python
  - scripts

---

# Today I Learned

## 날짜

2023년 12월 22일 금요일

## 내용

어제 막혔던 부분이 술술 해결됐다. 좋은 기분으로 크리스마스를 보낼듯!

### 구글 SEO

 오늘 아침와서 보니 Google Search Console이 우리 서비스의 robots.txt를 인지하기 시작했다. 시간이 답이였나보다. 해당 URL을 올바르게 크롤링할 수 있는지 검사할 수 있는데 Sitemap도 잘 인지하기 시작했다. 아직 sitemap.xml로 인지하는 건 아니고 그냥 크롤링 할 사이트로 인지하고 있긴한데.. 아마 사이트맵 등록도 시간이 조금 지나면 해결되지 않을까 싶다. 바로바로 피드백이 없으니 참 답답하다. 다음주까지 기다려보고 안되면 다시 건드려봐야겠다.

 SEO를 설정하는 방법은 그리 복잡하지는 않다. 우선 robots.txt는 검색엔진이 긁어갈 때의 정책을 설정하는 파일이다. 우선 크롤링할 대상을 정할 수 있다. `User-agent` 라는 속성인데, 모두에게 허용할 수도 있고 특정 검색엔진에게만 허용할 수도 있고, 구글은 스마트폰 검색이나 이미지 검색 설정까지 가능하고. 구글, 네이버, 다음 등도 각각의 이름이 있다. 또한 특정 디렉토리를 허용(`Allow`)하거나 금지(`Disallow` ) 할 수있다. 이는 겹칠 수도 있어서 예외를 적용할 수 있는데, ‘Home` 이하의 디렉토리를 금지하고 ‘Home/photo’ 라는 특정 하위 디렉토리만 예외로 두는 방식이다. 이후 `Sitemap` 이라는 속성에 사이트맵의 URL을 입력해주면된다. 밑에서도 말하겠지만 사이트맵은 항상 루트 디렉토리에 존재해야 한다. 

 Sitemap.xml은 어떤게 크롤링되는지 볼 수 있다. 예를 들어 내 블로그는 반복문을 통해 게시글들의 제목과 날짜 등을 크롤링하도록 해놨기 떄문에 그 내용들이 나타나고, 게시글을 업로드하면 자동으로 추가된다(RSS를 검색하면 더 자세히 알 수 있음). 우리 서비스는 랜딩 페이지의 하위페이지들 5개 정도만 포함시킬 것이기 떄문에 구체적으로 지정해줬다.

 작성한 예시를 보자면 어느 사이트든 <서비스주소>/sitemap.xml 과 <서비스주소>/robots.txt 로 들어가면 볼 수 있다.

[구글 사이트맵](https://www.google.com/sitemap.xml) 과 [구글 robots](https://www.google.com/robots.txt)

### Notification Email

 이 Task를 처음 파악하기 시작한게 12월 13일이니 벌써 9일이 됐다. 물론 중간중간 데모페이지 건드리랴, SEO 건드리랴 정신 없긴 했지만.. 드디어 오늘에야 이해를 했다. 수요일에 마지막으로 가진 궁금증은 `Messaging_log` 테이블에 WAITING 상태로 등록된 것이 언제 SUCCESS로 변경되냐는 것이었다. 로깅문을 추가하기 위해 스크립트를 이용했다.

 기존의 commands에 메시징과 관련된 스크립트들이 존재해서 수월했다. 서버의 docker 컨테이너에 접속해서 `python3 -m <module_name>` 으로 실행해줬다. 확실히 눈으로 코드 따라가는 것보단 빠르게 파악이 됐는데, `messaging_log`를 만들긴 하지만 저장 후 바로 발송처리된다는 것. 해당 로직에서 이것 저것 호출되다보니 흐름을 놓쳐서 이 부분을 몰랐다. 하지만 코드를 봤어도 확신은 안섰다. 바로 처리한다면, 발송 대기상태인 Notification email이 존재할 수 없다. 한번의 호출로 생성과 처리가 모두 완료되고 발송 대기 상태로 만드는 로직은 없었기 떄문이다.

 이떄가 되서야 내가 모르고 있는 부분, 추가로 해야할 질문이 명확해졌다. 

1. Notification Email의 하나인 Notification Email에 관한 고객의 요청이 정확히 무엇이었는지?
2. Notifiaction Email 3개 중 1개만 활성화 기능이 없는데, 원래 없었던 것인지? 원래 없었다면, 활성화 기능이 존재하는 다른 2가지와 로직이 다르지 않아 적용하는 것은 어렵지 않은데 안 만든 이유가 있는지?
3. 기획 상 비활성화하면 현재 발송 대기중인 상태의 메일들을 처리할건지 고객에게 물어야 하는데, 발송대기중인 메일이 어떻게 존재할 수 있는지? 처리할 것이 없다면 해당 기능은 추가하지 않아도 되는지?

 내가 답을 듣고싶은 부분에 대해 정리하고 물어봤기 떄문에 답변도 금방 받을 수 있었다. 이 Task 할 때 뭔가 찜찜해서 참 답답했는데 이제 좀 속이 뚫린다. 

 기존에 발송 대기 메일의 처리를 묻기 위해 만든 모달창과 관련된 코드들은 모두 삭제하고 활성화 버튼만 추가해줬다. 이제 Messaging 테이블에서 Verification Email의 `use_setting_type_detail` 을 검사하고 알맞게 messaging_log를 처리해주는지 확인만 하면 된다!

## 회고

어제같은 기분이었으면 연휴가 참 꿀꿀했을텐데 껄껄
