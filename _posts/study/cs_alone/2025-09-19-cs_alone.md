---
layout: post
title: "3장 명령어"
subtitle: " 혼자서 공부하는 컴퓨터 구조와 운영체제 "
catalog: true
category: study
subcategory: cs_alone
tags:
  - study
  - cs_alone
  - 언어
  - 명령어
  - 컴파일 언어
  - 인터프리터 언어
  - 주소 지정 방식
---

# 3장 명령어
# 03-1 소스 코드와 명령어

## 고급 언어와 저급 언어

- 고급 언어(high-level programming language): 사람을 위한 언어
    - Python, C, Java, …
- 저급 언어(low-level programming language): 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    - 기계어(machine code): 0과 1의 명령어 비트로 이루어진 언어
    - 어셈블리어(assembly lanaguage): 기계어를 읽기 편한 형태로 번역한 언어
- 고급 언어로 작성된 소스 코드가 실행되려면 저급 언어(명령어)로 변환되어야 함

## 컴파일 언어와 인터프리터 언어

### 컴파일 언어

- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
    - ex) C
- 컴파일(compile): 컴파일 언어로 작성된 소스 코드의 전체가 저급 언어로 변환되는 과정
    - 컴파일러(compiler): 컴파일을 수행해 주는 도구
    - 컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 컴파일에 실패
- 목적 코드(object code): 컴파일러를 통해 저급 언어로 변환된 코드
    - 목적 파일: 목적 코드로 이루어진 파일
- 컴파일러는 소스코드를 컴파일하여 목적 코드를 생성한다.
- 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어라 빠름

### 인터프리티 언어

- 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
    - ex) Python
- 한 줄씩 저급 언어로 변환하여 실행
- 인터프리터(interpreter): 한 줄씩 실행하는 도구
- 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음
- 한 줄씩 실행되어 오류가 발견되기 전까지는 올바르게 수행
- 한 줄씩 저급언어로 해석하며 실행하여 느림

---

- 둘은 명확히 분리된 개념이 아니라 둘 모두에 속하는 언어도 존재함
- 링킹(linking)
    - 컴파일된 목적파일에서 사용하는 기능을 연결
    - 목적 코드 ≠ 실행 파일
    - 어떤 목적파일에서 실행하는 기능이 다른 목적파일에 있다면 두 목적 파일을 연결해야 한다.

# 03-2 명령어의 구조

## 연산 코드와 오퍼랜드

- **명령어** = 연산 코드 + 오퍼랜드
- **연산 코드(operation code, 연산자)**: 명령어가 수행할 연산
    - **연산 코드 필드**: 연산 코드가 담기는 영역
- **오퍼랜드(operand, 피연산자)**: 연산에 사용할 데이터 또는 데이터가 저장된 주소
    - **오퍼랜드 필드(주소 필드)**: 오퍼랜드가 담기는 필드

### 오퍼랜드

- **N-주소 명령어**: 오퍼랜드 N개 (0개 이상)

### 연산 코드

- 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어 등

## 주소 지정 방식

- 오퍼랜드에 데이터를 담을 경우: 오퍼랜드에 할당된 크기 만큼만 데이터를 처리 가능
    - ex) n비트 명령어에 m비트가 연산 코드 필드라면, 오퍼랜드에 담는 데이터의 가짓수는 2^(n-m) 뿐
- 주소를 담으면 주소의 크기만큼 처리 가능한 데이터의 가짓수가 증가
    - ex) 오퍼랜드에 한 주소에 16비트를 저장하는 메모리의 주소를 담으면 데이터 가짓수는 2^16
- **유효 주소(effective address)**: 연산의 대상이 되는 데이터가 저장된 위치
- **주소 지정 방식(addressing mode)**: 연산에 사용할 데이터 위치를 찾는 방법
    - 즉, 유효 주소 찾는 방법
- CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름

### 즉시 주소 지정 방식

- **immediate addressing mode**
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 빠르지만, 표현할 수 있는 데이터의 크기가 작음

### 직접 주소 지정 방식

- **direct addressing mode**
- 오퍼랜드 필드에 유효 주소를 직접 명시
- 오퍼랜드 필드의 길이만큼 표현할 수 있는 주소의 크기가 작아짐

### 간접 주소 지정 방식

- **indirect addressing mode**
- 오퍼랜드 필드에 유효 주소의 주소를 명시
- 표현할 수 있는 유효 주소의 범위는 넓어짐
- 메모리 접근이 2번 필요하여 느림

### 레지스터 주소 지정 방식

- **register addresing mode**
- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
- 직접 주소 지정 방식보다 빠름(레지스터 읽기의 속도 > 메모리 읽기의 속도)

### 레지스터 간접 주소 지정 방식

- **register indirect addressing mode**
- 연산에 사용할 데이터를 메모리에 저장
- 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 저장
- 레지스터 접근 + 메모리 1회 접근이라 간접 주소 지정 방식보다 빠름

## 스택과 큐

### 스택

- **스택(stack)**: LIFO(Last In First Out) 자료구조
- **PUSH**(데이터 저장), **POP**(데이터 추출)

### 큐

- **큐(queue)**: FIFO(First In First Out) 자료구조