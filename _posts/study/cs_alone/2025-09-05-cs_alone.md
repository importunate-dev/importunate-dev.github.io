---
layout: post
title: "2장 데이터"
subtitle: " 혼자서 공부하는 컴퓨터 구조와 운영체제 "
catalog: true
category: study
subcategory: cs_alone
tags:
  - study
  - cs_alone
  - 비트
  - 바이트
  - 인코딩
  - 이진법
---

# 2장 데이터

# 2-1. 0과 1로 숫자를 표현하는 방법

## 정보 단위

비트(bit): 0과 1을 나타내는 가장 작은 정보 단위

8비트 → 1바이트(byte)

1000 바이트 → 1KB(kilobyte)

1024 바이트 → 1KiB

byte -(x1000)→ KB -(x1000)→ MB -(x1000)→ GB → …

byte -(x1024)→ KiB -(x1024) → MiB -(x1000) → GiB → …

1워드(word) → CPU가 한 번에 처리할 수 있는 데이터 크기

## 이진법

이진수 8표기 → 0b 1000 (0b로 이진법인지 십진법인지구분)

16진수 → 0x 붙여 표기

음수표기: 2의 보수(그 수보다 큰 2^n에서 뺸값) + 플래그

16진수 → 2진수 변환: 한글자씩 2진수로 변환

2진수 → 16진수 변환: 4글자씩 끊어서

# 2-2. 0과 1로 문자를 표현하는 방법

## 문자 집합과 인코딩

- 문자 집합(chracter set): 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩(character encoding): 문자(사람이 이해) → 0과 1의 문자코드(컴퓨터가 이해) 변환
- 문자 디코딩(charatger decoding): 0과 1의 문자코드(컴퓨터가 이해) → 문자(사람이 이해) 변환

## 아스키 코드

- 아스키(American Standard Code for Information Interchange): 영어 알파벳 + 아라이바 숫자 + 일부 특수문자로 이루어진 문자집합
- 8비트 = 7비트(문자코드) + 1비트(패리티 비트)
    - 패리티 비트(parity bit): 오류 검출을 위해 사용
    - 따라서 2의 7승인 128개 문자만 표현 가능

## ECU-KR

- 완성형 인코딩: 완성된 하나의 글자에 고유한 코드 부여
- 조합형 인코딩: 초성, 중성, 종성에 각각 비트열 부여
- EUC-KR은 완성형 인코딩
    - 글자당 2바이트 크기 부여 ⇒ 2바이트 = 16비트 = 16진수 4자리
    - 모든 글자가 다 있지 않아 일부 괴상한 글자는 깨짐
    - CP949 ⇒ 확장버전

## 유니코드와 UTF-8

- EUC-KR 같은 방식: 각 나라마다 인코딩이 달라짐 ⇒ 다국어 지원에서 번거로움
- 유니코드가 이를 해결
    - 유니코드 문자집합에서 각 문자마다 고유한 코드 부여
        - ex) D55C(16), AE00(16), U+D55C, U+AE00
        - U+은 16진수라는 의미
    - 글자에 부여된 값을 인코딩 값으로 삼지 않고 이를 인코딩함
    - UTF(Unicode Transformation Format)-8, UTF-16, …: 유니코드를 인코딩하는 방식
    - 1~4바이트 사이로 표현되며 해당 유니코드 문자에 부여된 값의 범위에 따라 달라짐
    - 유니코드 문자에 부여된 값을 2진수로 표현하고 앞에 11110, 1110 등을 붙임

# 개인적 궁금증

한글에서 글자는 정말 많으니 조합형이 더 대응하기 좋아보이는데 왜 완성형 조합으로 간걸까

## **1. 왜 조합형 대신 완성형이 채택된 이유**

1. **당시 기술 한계**
    
    1980~90년대는 PC 성능이 낮았고, 글자 렌더링을 실시간 조합하기 부담스러웠음
    
    → 완성형은 글자가 곧 코드이므로 **폰트 매핑·출력 속도가 빠름**.
    
2. **표준화 문제**
    
    조합형은 이론상 모든 글자를 표현 가능하지만, 표준화된 방식이 부족했음
    
    → 각 회사가 조금씩 다른 조합 규칙을 쓰면 호환성이 깨짐.
    
    → 반대로 완성형은 국가 표준(KS 완성형)으로 정해져서 산업계에 빨리 자리잡음.
    

## **1. 국가 표준(KS 완성형) 제정 연도**

- **1987년**: KS C 5601:1987 (한글 완성형) 제정
    - 초판(1987)에서는 **한글 2,350자 + 한자 4,888자 + 기타 문자** 총 8,836자 수록.
    - 이게 우리가 흔히 말하는 “구(舊)완성형”
- **1992년 개정**: KS C 5601:1992 → 나중에 **KS X 1001**로 명칭 변경 (국가 표준 부호계).
- 즉, 대한민국에서 쓰인 완성형 표준은 **1987년에 처음 등장**했고, 1990년대 초반부터 PC/정부/은행 시스템에서 광범위하게 사용되기 시작
1. **문서 호환성과 호환성 유지**
    
    정부·은행·기업 시스템이 완성형 기반으로 구축되다 보니,
    
    나중에 조합형을 쓰기 어려움
    
    → “호환성” 때문에 완성형 중심 생태계가 굳어버림
    

---

## **3. 유니코드의 등장이 해결책**

- 유니코드는 **완성형과 조합형의 장점을 절충**
- **U+AC00 ~ U+D7A3** 영역에 11,172자 모든 현대 한글을 완성형으로 배치.
- 동시에 **한글 자모 영역**(U+1100 등)을 둬서 조합형 표기도 가능.
    
    → 즉, 유니코드에서는 **완성형 방식으로 통일**하되, 필요하면 조합형 자모를 따로 합성 가능.
    
    - 현대 한글: 항상 완성형 코드 사용 → 호환성·속도
    - 옛한글/학술용: 자모 조합해서 사용 → 확장성

---

## **4. 결론**

- 조합형은 이론적으로는 더 “이상적”이지만,
    
    당시 성능·호환성·표준화 문제 때문에 채택되지 못했습니다.
    
- 완성형은 실무적으로 간단하고 빠르며, 산업계에서 이미 굳어져 있었기 때문에 주류가 됐습니다.
- **유니코드**는 그 한계를 해결하면서 사실상 “완성형 기반 + 자모 조합 지원”이라는 절충안을 제공하여 지금은 사실상 전세계 표준이 된 거예요.

---