---
layout: post
title: " 2.1 네트워크 애플리케이션의 원리 "
subtitle: " 네트워크 애플리케이션이란? "
catalog: true
category: study
subcategory: network
tags:
  - study
  - network
  - network application
  - application architecture
  - client-server architecture
  - process
  - API
  - port
  - socket
  - udp
  - tcp
  - application-layer protocol
  - protocol

---

- 네트워크 애플리케이션 : 다른 위치의 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램
- 웹 애플리케이션에는 서버와 클라어인트라는 두 가지 프로그램이 있다.
    - 클라이언트 : 사용자의 호스트에서 실행되는 브라우저 프로그램
    - 웹 서버 호스트에서 실행되는 웹 서버 프로그램
- 새로운 애플리케이션을 개발할 때, 라우터나 링크 계층 스위치처럼 네트워크 코어 장비에서 실행되는 소프트웨어까지 작성할 필요는 없다.
- 네트워크 코어 장비는 애플리케이션 계층에서 기능하지 않는 대신 네트워크 계층 및 그 하위 계층에서 기능한다.
- 종단 시스템에서만 애플리케이션 소프,트웨어가 존재한다.

## 2.1.1 네트워크 애플리케이션 구조

- 애플리케이션 구조는 네트워크 구조(ex. 1.5장에 나온 프로토콜 스택)와 다르다.
- 개발자 관점에서 네트워크 구조 : 고정되어 있고 해당 애플리케이션에 특정 서비스 집합을 제공
- **애플리케이션 구조(application architecture)** : 개발자가 설계하며 애플리케이션이 다양한 종단 시스템에서 어떻게 조직되어야 하는지를 알려줌.
- 최근 가장 많이 사용하는 애플리케이션 구조가 현대 네트워크 애플리케이션에서 사용되는 “클라이언트-서버” 구조와 P2P 구조
- **클라이언트-서버 구조(client-server architecture)**
    - **서버(server)** : 항상 동작하고 있는 호스트
    - **클라이언트(client)** : 서버에 서비스 요청을 보냄
    - 이 구조에서, 클라이언트는 서로 직접적으로 통신하지 않는다.
    - 서버는 고정 IP 주소를 갖는다.
    - 클라이언트의 요청이 많을 경우 단일 서버 호스트가 모든 요청을 처리하긴 힘들다.
    - 많은 수의 호스트를 갖춘 **데이터 센터(data center)**가 강력한 가상의 서버를 생성하는 역할을 함.
- **P2P 구조**
    - 항상 켜져있는 인프라스트럭처 서버에 최소로 의존하거나 의존하지 않음
    - 대신 **피어(peer)**라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신
    - **피어(peer)** : 서비스 제공자(service provider)가 소유하지 않고 사용자들이 제어하는 데스크톱과 랩톱
    - 한 엔드시스템이 서버 역할을 해준다.
    - 토렌트가 대표적인 P2P 구조
    - P2P구조는 **자가 확장성(self-scalability)**이 있다.
    - 각 피어들이 파일을 요구함으로써 작업 부하를 만들어낸다.
    - 하지만 파일을 다른 피어들에게 분배함으로써 그 시스템에 서비스 능력을 추가함.
    - 토렌트에서 다운로드 받고 업로딩하는 사람이 많을 수록 그 파일은 다운로드 속도가 빨라지는데, 이유가 바로 이것이다.
    - 서버 인프라스트럭처와 서버 대역폭이 필요하지 않아 비용 효율적이다.
    - 보안, 성능, 신뢰성이 단점이다.

### 2.1.2 프로세스 간 통신

- 운영체제 용어에서 실제 통신하는 것은 프로그램이 아니라 **프로세스(process)**다.
- **프로세스(process)**
    - 종단 시스템에서 실행되는 프로그램
    - 통신 프로세스가 같은 종단 시스템에서 실행될 때 그들은 서로 프로세스 간에 통신한다.
    - 프로세스 간의 통신을 위한 규칙은 종단 시스템의 운영체제에 의해 좌우된다.
    - 여기서 다룰 통신은 같은 호스트에서 프로세스가 통신하는 방법이 아닌, 다른 호스트에서 실행되어 통신할 때이다.
- 2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 **메시지(message)** 교환으로 통신한다.
- 송신 프로세스 : 메시지를 만들어서 네트워크를 보낸다.
- 수신 프로세스 : 메시지를 받고 역으로 메시지를 보내 응답한다.

### 클라이언트와 서버 프로세스

- 네트워크 애플리케이션 : 서로 메시지를 보내는 두 프로세스로 구성
- 통신하는 프로세스 각 쌍은 **클라이언트**의 프로세스와 **서버**의 프로세스로 이름 짓는다.
    - ex1. 웹 애플리케이션
        - 브라우저 프로세스(클라이언트 프로세스)
        - 웹 서버 프로세스(서버 프로세스)
    - ex2. P2P
        - 파일을 내려받는 피어(클라이언트)
        - 파일을 올리는 피어(서버)
        - 물론 P2P의 특성상 프로세스가 클라이언트와 서버 둘 다 가능하다.
- 클라이언트와 서버 프로세스를 다음과 같이 정의한다.
    
    > 두 프로세스 간의 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스를 클라이언트라 하고, 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.
    > 

### 프로세스와 컴퓨터 네트워크 사이의 인터페이스

- 위에서 말했듯, 하나의 프로세스로부터 다른 프로세스로 보내는 메시지는 네트워크를 통해 움직인다.
- 프로세스는 **소켓(socket)**을 통해 네트워크로 메시지를 보내고 받는다.
- 프로세스가 집이라면, 소켓이 문이다.
- 소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스다.
- 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, 애플리케이션과 네트워크 사이의 **API(Application Programming Interface)**라고도 한다.
- 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖는다.
- 하지만 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못한다.
    - 트랜스포트 프로토콜의 선택
    - 최대 버퍼와 최대 세그먼트 크기
    - 이와 같은 트랜스포트 계층 매개변수 일부에 대한 설정만 갖는다.

### 프로세스 주소 배정

- 프로세스가 패킷을 다른 호스트에서 수행되고 있는 프로세스로 패킷을 보내기 위해서는 수신 프로세스가 주소를 갖고 있어야 한다.
- 여기에는 (1) 호스트의 주소, (2) 그 목적지 호스트 내의 수신 프로세스를 명시하는 식별자 가 포함되야 한다.
    - 호스트의 주소 : **IP 주소(32비트)**
    - 수신 프로세스 식별자 : **포트 번호(port number)**

### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스

- 소켓은 애플리케이션 프로세스와 트랜스포트 프로토콜 간의 인터페이스이다.
- 송신측의 애플리케이션은 소켓을 통해 메시지를 보낸다.
- 송신측의 트랜스포트 프로토콜은 그 메시지를 수신 프로세스의 소켓으로 보낸다.
- 인터넷에는 다양한 트랜스포트 프로토콜이 있고, 각기 다른 서비스를 제공한다.

### 신뢰적 데이터 전송

- 패킷은 버퍼가 오버플로(overflow)되거나 비트가 잘못되는 등 다양한 이유로 손실될 수 있다.
- **신뢰적 데이터 전송(reliable data transfer)**은 프로토콜이 보장된 데이터 전송 서비스를 제공한다는 의미이다.
- 송신 프로세스는 소켓으로 보낸 데이터가 오류 없이 수신 프로세스에 도달할 것이라는 확신을 갖는다.
- 반면, 손실 허용 애플리케이션(loss-tolerant application)은 어느정도의 데이터 손실은 감수한다. ****

### 처리율

- 두 프로세스간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
- 다른 세션들이 대역폭을 공유하고, 이 세션들이 생기고 사라지기 때문에 처리율은 변동한다.
- 따라서 어떤 트랜스포트 프로토콜은 명시된 속도에서 보장된 가용 처리율을 제공한다.
- 보장된 처리율을 제공할 수 없다면 낮은 속도로 인코딩하거나 포기해야 한다.
- **대역폭 민감 애플리케이션(bandwidth-sensitive application)**은 필요한 처리율보다 낮게 수신하는 것이 무의미하다.
- 반면 탄력적 애플리케이션(elastic application)은 처리율에 대한 융통성이 있다.

### 시간

- 시간 보장(timing guarantee) 제공 가능.
- 특히 실시간 애플리케이션(통화, 게임)에 유리

### 보안

- 기밀성(confidentiality), 데이터 무결성(integrity), 종단 인증(authentication) 등

## 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

- 일반적인 TCP/IP 네트워크(인터넷)은 2개의 전송 프로토콜을 제공한다.
    - UDP(User Datagram Protocol)
    - TCP(Transmission COntrol Protocol)

### TCP 서비스

- 연결지향형 서비스와 신뢰적엔 데이터 전송 서비스 포함
- 연결지향형 서비스 : 애플리케이션 계층 메시지 전송 전에 클라이언트와 서버 간 전송 제어 정보를 교환한다(핸드셰이킹). 핸드셰이킹 단계를 지나면, **TCP 연결**이 두 프로세스의 소켓 사이에 존재한다고 말한다.
- 신뢰적인 데이터 전송 서비스 : 통신 프로세스는 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존한다.
- 통신하는 프로세스의 직접 이득보다는 인터넷의 전체 성능 향상을 위한 서비스인 혼잡 제어 방식을 포함한다.
- 따라서 네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮춘다.
- TCP를 강화한 TLS(Transport Layer Security)로 보안 서비스를 제공한다.
- SMTP(전자메일), Telnet(원격 터미널 접속), HTTP 1.1(웹), FTP(파일 전송), HTTP(유튜브) 등 모두 TCP 서비스를 이용한다.

### UDP 서비스

- 최소의 서비스 모델을 가진 간단한 전송 프로토콜이다.
- 비연결형이므로 핸드셰이킹이 없다.
- 비신뢰적인 데이터 전송 서비스.
- 혼잡 제어 방식을 포함하지 않는다.

### 인터넷 트랜스포트 프로토콜이 제공하지 않는 서비스

- 우리가 정의한 서비스는 신뢰적 데이터 전송, 처리율, 시간, 보안 4가지였다.
- TCP와 UDP에서 시간에 관한 서비스가 없는걸까?
- 이미 요즘 어플리케이션은 시간 민감인 경우가 많고 이에 적절한 서비스를 해오고 있다.
- 하지만 경우에 따라서(지연이 과도하다거나) 보장할 수 없는 경우가 있다.

## 2.1.5 애플리케이션 계층 프로토콜

- **애플리케이션 계층 프로토콜(application-layer protocol)**은 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의한다.
    - 교환 메시지 타입(ex. 요청과 응답)
    - 여러 메시지 타입의 문법(ex. 메시지 내부의 필드간 구별법)
    - 필드에 들어있는 정보의 의미
    - 언제, 어떻게 프로세스가 메시지를 전송하고 응답하는지 결정하는 규칙
- 여러 애플리케이션 계층 프로토콜은 RFC에 명시되어 있으므로 공중 도메인(public domain)에서 찾을 수 있다.
- 독점적인 것들은 비개방 애플리케이션 계층 프로토콜을 사용하기 때문에 구할 수 없다.(ex. 스카이프)
- 네트워크 애플리케이션과 애플리케이션 계층 프로토콜 : 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 요소일 뿐이다.
