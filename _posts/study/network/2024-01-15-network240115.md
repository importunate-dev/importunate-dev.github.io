---
layout: post
title: " 1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율 "
subtitle: " 네트워크의 성능을 결정하는 요소 "
catalog: true
category: study
subcategory: network
tags:
  - study
  - network
  - internet
  - delay
  - queing delay
  - transmission delay
  - propagation delay
  - packet drop
  - packet loss
  - traffic intensity
  - end-to-end delay
  - throughput
  - bottleneck link

---

# 1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율

네트워크는 반드시 두 end system 간에 처리율(전달될 수 있는 초당 뎅디터의 양)을 제한하여 end system 간에 지연을 야기하며 실제로 패킷을 잃어버리기도 한다.

## 1.4.1 패킷 교환 네트워크에서의 지연 개요

- 패킷은 한 호스트에서 일련의 라우터를 통과하며 다른 호스트까지 도달함.
- 경로를 따라 한 노드(호스트 혹은 라우터)에서 다음 노드로 전달될 때 다양한 지연을 겪음.
    - nodal processiong delay(노드 처리 지연)
    - queuing delay(큐잉 지연)
    - transmission delay(전송 지연)
    - propagation delay(전파 지연)
    - 이 모두를 합쳐 total nodal delay

### 지연 유형

- 라우터 A에서 B로 보내질 때
    1. 패킷이 앞선 노드에서 도착하면 라우터 A는 패킷 헤더를 조사해서 적당한 출력 링크를 결정하고(processing delay)
    2. 만약 선택된 링크가 이용되고 있더나 큐에서 대기하는 패킷이 있다면 큐로 들어간다(queuing delay).
    3. 링크를 이용할 수 있으면 패킷을 보낸다. 패킷의 길이가 L비트, 링크의 전송률이 R bps면 transmission delay는 L/R이다(transmission delay).
    4. 비트가 링크에 전해지면 목적지인 라우터 B까지 전달되야 한다. 이 전파 속도는 링크의 물리 매체에 따라 다르다(propagation delay).

### 전송 지연과 전파 지연 비교

- 전송지연
    - 전송률과 패킷 길이
    - 라우터가 패킷을 내보는데 필요한 시간
    - 한 개의 패킷 내에서 첫번째 비트부터 마지막 비트까지 라우터를 빠져나오는데 걸리는 시간.
    - 이전에 말했듯, 첫번째 비트는 마지막 비트가 도착할때까지 저장되어있어야 함.
    - 마지막비트가 라우터에 도착하고나서야 첫번째 비트는 다음 목적지로 전송된다.
- 전파지연
    - 비트가 한 라우터에서 다음 라우터로 전파되는데 걸리는 시간
    - 링크의 물리적 길이
    - 라우터를 빠져나와 다음 라우터까지 도달하는데 걸리는 시간.
- 패킷이 라우터에 저장되는 시간으로부터 다음 라우터에 저장될때 까지의 시간은 전송지연과 전파지연의 합.
- 당연히 마지막 비트가 전송되기도 전에 앞선 비트가 다음 라우터에 도착할 수도있다.

## 1.4.2 큐잉 지연과 패킷 손실

- 다른 지연들과 달리 큐잉 지연은 패킷마다 다를 수 있다.
- 여러 패킷이 동시에 비어있는 큐에 도착한다면, 처음 큐에 들어간 패킷과 마지막에 들어간 패킷의 큐잉 지연은 크게 차이난다.
- 따라서 큐잉 지연은 통계 측정을 일반적으로 사용한다.
- 큐잉 지연은 트래픽이 큐에 도착하는 비율, 링크의 전송률 ,도착하는 트래픽의 특성에 따라 달라진다.
- 예시
    - 패킷이 큐에 도착하는 평균율 : a 패킷/초
    - 전송률(비트가 큐에서 밀려나는 비율) : R 비트/초
    - 모든 패킷 : L 비트
    - 따라서 평균율의 단위를 비트로 바꾸면 La 비트/초 이다.
    - **트래픽 강도(traffic intensity) : La/R**
    - (트래픽 강도) > 1 인 경우
        - 비트가 큐에 도착하는 평균율이ㅐ 비트가 큐에서 전송되는 비율을 초과한다.
        - La/R > 1이면, La > R이므로 큐에 도착하는 비트의 수가 다음 목적지로 전송되는 비트보다 많다.
        - 큐에서 처리되는 비트보다 쌓이는 비트가 많아지므로, 점차 큐잉 지연은 커질것이다.
        - 따라서 트래픽 공학에선, 트래픽 강도가 1보다 크지 않게 시스템을 설계하라는 규칙이 있다.
    - (트래픽 강도) ≤ 1인 경우
        - 패킷이 주기적으로 도착한다면, 쌓이는 것보다 처리되는 것이 빠르기 떄문에 큐잉 지연이 없을 것이다.
        - 하지만 패킷이 몰려서(버스트) 도착한다면 큐잉 지연은 존재할 것이다.
        - 이게 반복되면 몰려서 도착하는 패킷의 횟수만큼 점차 큐잉 지연이 늘어날 것이고, 이에 따라 평균 큐잉 지연을 계산할 수 있다.
- 실제로, 큐에 도착하는 프로세스는 랜덤하다.\
- 또한 이 예시에선 큐가 무한한 패킷을 담을 수 있다고 가정했다.
- 하지만 트래픽 강도가 1에 가까울 수록, 큐잉 지연이 기하급수적으로 늘어나는 건 알아둬야 함.

### 패킷 손실

- 실제로 큐는 무한한 패킷을 담을 수 없다.
- 따라서 큐잉지연이 무한하게 증가하지 않는다.
- 패킷이 도착했을 때 큐가 꽉 차있다면, 패킷은 버려지고(**drop**), 잃어버리게(**lost**) 된다.
- 트래픽 강도가 높을 수록, 손실 패킷의 비율은 증가한다.
- end system에 입장에선, 패킷이 네트워크 코어로 전송되었으나 목적지에 나타나지 않는 것 처럼 보인다.

## 1.4.3 종단 간 지연

- 위 과정들은, 단일 라우터에서를 초점으로 두었다.
- 출발 호스트와 목적 호스트 사이에 N-1개의 라우터(즉, N개의 링크)가 있다고 가정.
    - d(proc) = 각 라우터와 출발지 호스트의 처리 지연
    - R 비트/초 = 각 호스트와 출발지 호스트에서의 전송률
    - d(prop) = 각 링크에서의 전파 지연
    - L = 패킷 크기
    - d(trans) = L/R (전송지연)
    - d(end-end) = 종단 간 지연 = N * (d(proc) + d(trans) + d(prop))

### Traceroute

- 컴퓨터 네트워크에서의 지연을 느낄 수 있는 진단 프로그램’

### 종단 시스템, 애플리케이션 그리고 그 밖의 지연

- 이외에도 다른 중요한 지연들 도 있다.
- 종단 시스템에서 매체를 공유하기 위해 프로토콜의 일부로 전송을 **의도적으로** 지연 시킬 수도 있다.
- media packetization delay(미디어 패킷화 지연)은 VoIP(Voice-over-IP)에서 송신 측은 먼저 패킷을 인터넷으로 보내기 전에 패킷을 인코딩된 디지털 음성으로 채워야 한다.

## 1.4.4 컴퓨터 네트워크에서의 처리율

- 지연과 패킷 손실 외에 컴퓨터 네트워크에서 성능과 연관된 요소는 throughput(처리율) 이다.
- instantaneous throughput(순간적인 처리율), average throughput(평균 처리율)
- 예시
    - 서버 → 라우터 → 클라이언트로 연결되어있다고 가정해보자.
    - 서버와 라우터간의 링크 속도는 R(s)고, 라우터와 클라이언트의 링크 속도는 R(c)이다.
    - 서버는 라우터로 R(s)의 속도로 비트를 보내고, 라우터는 클라이언트로 R(c)의 속도로 전송한다.
    - R(s) < R(c) 일때, 결국 클라이언트는 서버로부터 R(s)의 처리율로 비트를 받는다.
    - R(s) > R(c) 일때, 서버가 라우터로 아무리 빨리 보내더라도 결국 클라이언트는 R(c)의 속도로 비트가 처리되는 것처럼 느낀다.
    - 따라서 이 네트워크의 처리율은 min{R(c), R(s)} 가 된다.
    - **bottleneck link(병목 링크)**의 전송률이 처리율이 된 상황이다.
- 이처럼 일직선으로 되어있는 네트워크에서 서버가 클라이언트로 파일을 전송하는 경우의 처리율은 링크 속도 중 최솟값이고, 이는 병목 링크의 전송률이다.
- 10개의 서버와 10개의 클라이언트가 있다고 가정해보자.
    - 서버와 클라이언트간의 연결은 모두 **단 하나의 코어 링크**를 지난다고 생각해보자.
    - 어떤 서버가 어떤 클라이언트에게 파일을 전송하든, 코어 링크를 지나야 한다.
    - R(s) : 서버와 코어링크 사이의 링크 속도
    - R(c): 클라잉너트와 코어 링크 사이의 링크 속도
    - R : 코어 링크의 링크 속도
    - 만약 R이 R(s)와 R(c)보다 월등히 크다면, 코어 링크가 끼치는 영향은 무의미하다.
    - 따라서 병목은 R(s)와 R(c) 중 최솟값이 된다.
    - 하지만 R이 R(s), R(c)와 비슷하다면?
    - R(s) = 1 Mbps, R(c) = 2 Mbps고 R = 5 Mbps 라면 어떨까?
    - 공통된 코어 링크는 10개의 서버-클라이언트 쌍에게 전송률을 나눈다.
    - 하나의 통신은 500 Kbps를 가지게 된다.
    - 그렇다면 병목은 R(s)나 R(c)가 아니라 공통된 코어링크가 된다.
