---
layout : post
title : "PintOS User program WIL"
subtitle : " Pintos 2주차"
catalog : true
tags : 	
    - etc
    - pintos
---





# User Memory Access & System call

📋목차

------

# 🎯 과제목표

기본으로 주어진 Pintos는 프로그램과 인자를 구분하지 못하는구조로 되어있다.

예: $ls–a /* Pintos는 ‘ls-a’ 를 하나의 프로그램명으로 인식*/

이번 과제에는 프로그램이 시스템 콜을 통해서 OS와 상호작용하여 command line에서 명령어가 실행될 수 있도록 만드는 것이다.

프로젝트에서는 파일 시스템 코드와 인터페이스해야 한다. 유저 프로그램이 파일 시스템으로부터 로드되기도 하고, 구현해야 할 시스템 콜들이 파일 시스템을 다루기 때문이다.

**프로그램 이름과 인자를 구분하여 스택에 저장, 인자를 프로그램에 전달하고, 작성한 시스템 콜을 실행시켜 command line의 명령어가  실행되도록 만들자.**

------

# 🗒️Introduction

<aside> 💡 x86-64에서는 주어진 물리 주소 메모리에 직접적으로 접근할 수 있는 방법을 제공하지 않습니다. 이 기능은 os 커널에서 필요하며, 이를 위해 핀토스는 커널 가상 메모리를 물리 메모리와 1대1로 매핑(mapping)합니다.  즉, 가상 주소가 KERN_BASE라면 물리 주소 0에 매핑되며, 가상 주소가  `KERN_BASE + 0x1234` 라면, 물리 주소 0x1234에 매핑됩니다.  따라서, 물리 주소에 `KERN_BASE` 를 더하면 커널 가상 주소를 얻을 수 있고, 반대로 생각해보면, 커널 가상 주소에서 `KERN_BASE` 를 빼주면 물리 주소를 얻을 수 있습니다.

헤더파일  `include/threads/vaddr.h` 은 이러한 전환에 대한 한 쌍의 함수를 제공합니다

</aside>

> If you don't want to keep the file system disk around for later use or inspection, you can even combine all four steps into a single command. The `--filesys-size=n` option creates a temporary file system partition approximately n megabytes in size just for the duration of the pintos run. The Pintos automatic test suite makes extensive use of this syntax:

```bash
pintos --fs-disk=10 -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
```

<aside> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0de3f89-d77b-4701-8520-3ea52dc0e352/jungle_yujin_run.gif" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0de3f89-d77b-4701-8520-3ea52dc0e352/jungle_yujin_run.gif" width="40px" /> 만약 파일 시스템 디스크가 당장 필요 없다면, 이 네 단계를 하나의 커맨드로 합칠 수도 있습니다. `--filesys-size=n` 옵션을 쓰면 pintos를 실행하는 동안 대략 n메가바이트 크기의 임시 파일 시스템 파티션을 생성하게 됩니다. pinto의 자동 시스템 suite은 이 구문을 아주 다양하게 사용합니다.

</aside>

# 🔎코드 이해

main() > run_action() > run_task() >process_wait (process_create_initd (task)) >thread_exit ()

process_wait (): 자식 프로세스가 종료될 때까지 대기하는 함수를 만들어야함.

- ***main()***

    ***:*** threads/init.c/main(void)

    ```c
    /* Pintos main program. */
    int main (void) {
       uint64_t mem_end;
       char **argv;
    
       /* Clear BSS and get machine's RAM size. */
       bss_init ();
    
       /* Break command line into arguments and parse options. */
       argv = read_command_line ();
       argv = parse_options (argv);
    
       /* Initialize ourselves as a thread so we can use locks,
          then enable console locking. */
       thread_init ();
       console_init ();
    
       /* Initialize memory system. */
       mem_end = palloc_init ();
       malloc_init ();
       paging_init (mem_end);
    
    #ifdef USERPROG
       tss_init ();
       gdt_init ();
    #endif
    
       /* Initialize interrupt handlers. */
       intr_init ();
       timer_init ();
       kbd_init ();
       input_init ();
    #ifdef USERPROG
       exception_init ();
       syscall_init ();
    #endif
       /* Start thread scheduler and enable interrupts. */
       thread_start ();
       serial_init_queue ();
       timer_calibrate ();
    
    #ifdef FILESYS
       /* Initialize file system. */
       disk_init ();
       filesys_init (format_filesys);
    #endif
    
    #ifdef VM
       vm_init ();
    #endif
    
       printf ("Boot complete.\\\\n");
    
       /* Run actions specified on kernel command line. */
       run_actions (argv);
    
       /* Finish up. */
       if (power_off_when_done)
       	power_off ();
       thread_exit ();
    }
    ```

- read_command_line(void)

    : 커널 커맨드 라인을 단어로 분할하여 argv 형태의 배열로 반환하는 역할

    ```c
    static char **
    read_command_line(void)
    {
    	static char *argv[LOADER_ARGS_LEN / 2 + 1];
    	char *p, *end;
    	int argc;
    	int i;
    
    	argc = *(uint32_t *)ptov(LOADER_ARG_CNT);
    	p = ptov(LOADER_ARGS);
    	end = p + LOADER_ARGS_LEN;
    	for (i = 0; i < argc; i++)
    	{
    		if (p >= end)
    			PANIC("command line arguments overflow");
    
    		argv[i] = p;
    		p += strnlen(p, end - p) + 1;
    	}
    	argv[argc] = NULL;
    
    	/* Print kernel command line. */
    	printf("Kernel command line:\\n");
    	for (i = 0; i < argc; i++)
    		if (strchr(argv[i], ' ') == NULL)
    			printf("(args) values[%d] = %s\\n", i, argv[i]);
    		else
    			printf("%s\\n", argv[i]);
    	printf("\\n");
    
    	return argv;
    }
    ```

    해당 코드는 부트 로더에서 커널에 전달된 커맨드 라인 인자를 읽어오는 함수입니다.

    LOADER_ARG_CNT 변수를 통해 전달된 인자 개수를 읽어온 후, LOADER_ARGS 변수를 통해 인자들의 문자열 배열을 가리키는 포인터를 얻어옵니다.

    이후 for 루프를 통해 각 인자의 시작 주소를 argv 배열에 저장합니다. 각 인자는 문자열의 형태로 저장되어 있으며, 다음 인자를 가리키는 주소를 찾기 위해 문자열의 길이를 구합니다.

    마지막으로 argv 배열에 NULL을 추가해 커널에서 인자의 끝을 표시하고, 출력문을 통해 인자를 콘솔에 출력합니다.

    이를 통해 커널에서 어떤 인자들이 전달되었는지 확인할 수 있습니다.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d090c838-0db0-4255-9acc-16e27daf2305/Untitled.png)

- run_action()

    ***:*** threads/init.c/run_action()

    ```c
    static void
    run_actions (char **argv) {
    	/* An action. */
    	struct action {
    		char *name;                       /* Action name. */
    		int argc;                         /* # of args, including action name. */
    		void (*function) (char **argv);   /* Function to execute action. */
    	};
    
    	/* Table of supported actions. */
    	static const struct action actions[] = {
    		{"run", 2, run_task},
    #ifdef FILESYS
    		{"ls", 1, fsutil_ls},
    		{"cat", 2, fsutil_cat},
    		{"rm", 2, fsutil_rm},
    		{"put", 2, fsutil_put},
    		{"get", 2, fsutil_get},
    #endif
    		{NULL, 0, NULL},
    	};
    
    	while (*argv != NULL) {
    		const struct action *a;
    		int i;
    
    		/* Find action name. */
    		for (a = actions; ; a++)
    			if (a->name == NULL)
    				PANIC ("unknown action `%s' (use -h for help)", *argv);
    			else if (!strcmp (*argv, a->name))
    				break;
    
    		/* Check for required arguments. */
    		for (i = 1; i < a->argc; i++)
    			if (argv[i] == NULL)
    				PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
    
    		/* Invoke action and advance. */
    		a->function (argv);
    		argv += a->argc;
    	}
    
    }
    ```

- run_task()

    threads/init.c

    ```c
    static void
    run_task (char **argv) {
    	const char *task = argv[1];
    
    	printf ("Executing '%s':\\n", task);
    #ifdef USERPROG
    	if (thread_tests){
    		run_test (task);
    	} else {
    		process_wait (process_create_initd (task));
    	}
    #else
    	run_test (task);
    #endif
    	printf ("Execution of '%s' complete.\\n", task);
    }
    ```

- process_create_initd (const char *file_name)

    userprog/process.c

    ```c
    tid_t
    process_create_initd (const char *file_name) {
    	char *fn_copy;
    	tid_t tid;
    
    	/* Make a copy of FILE_NAME.
    	 * Otherwise there's a race between the caller and load(). */
    	fn_copy = palloc_get_page (0);
    	if (fn_copy == NULL)
    		return TID_ERROR;
    	strlcpy (fn_copy, file_name, PGSIZE);
    
    	/* Create a new thread to execute FILE_NAME. */
    	tid = thread_create (file_name, PRI_DEFAULT, initd, fn_copy);
    	if (tid == TID_ERROR)
    		palloc_free_page (fn_copy);
    	return tid;
    }
    ```

    - 코드 결과

        file_name: args-single onearg

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95bbcf87-151b-43e7-9fab-0d0dab334656/Untitled.png)

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d4f041ca-0c74-4fc6-b33f-05b7ad9a198f/Untitled.png)

- void initd (void *f_name)

    ```c
    static void initd (void *f_name) {
    #ifdef VM
    	supplemental_page_table_init (&thread_current ()->spt);
    #endif
    
    	process_init ();
    
    	if (process_exec (f_name) < 0)
    		PANIC("Fail to launch initd\\n");
    	NOT_REACHED ();
    }
    ```

- process_exec()

    userprog/process.c

    ```c
    int
    process_exec (void *f_name) {
    	char *file_name = f_name;
    	bool success;
    
    	/* We cannot use the intr_frame in the thread structure.
    	 * This is because when current thread rescheduled,
    	 * it stores the execution information to the member. */
    	struct intr_frame _if;
    	_if.ds = _if.es = _if.ss = SEL_UDSEG;
    	_if.cs = SEL_UCSEG;
    	_if.eflags = FLAG_IF | FLAG_MBS;
    
    	/* We first kill the current context */
    	process_cleanup ();
    
    	/* And then load the binary */
    	success = load (file_name, &_if);
    
    	/* If load failed, quit. */
    	palloc_free_page (file_name);
    	if (!success)
    		return -1;
    
    	/* Start switched process. */
    	do_iret (&_if);
    	NOT_REACHED ();
    }
    ```

    들어오는 인자

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e8438ac-e4b6-410f-b0b4-f8cbfc402053/Untitled.png)

- thread_create()

    threads/tread.c

    ```c
    tid_t thread_create(const char *name, int priority,
    					thread_func *function, void *aux)
    {
    	struct thread *t;
    	tid_t tid;
    
    	ASSERT(function != NULL);
    
    	t = palloc_get_page(PAL_ZERO);
    	if (t == NULL)
    		return TID_ERROR;
    
    	init_thread(t, name, priority);
    	tid = t->tid = allocate_tid();
    
    	t->tf.rip = (uintptr_t)kernel_thread;
    	t->tf.R.rdi = (uint64_t)function;
    	t->tf.R.rsi = (uint64_t)aux;
    	t->tf.ds = SEL_KDSEG;
    	t->tf.es = SEL_KDSEG;
    	t->tf.ss = SEL_KDSEG;
    	t->tf.cs = SEL_KCSEG;
    	t->tf.eflags = FLAG_IF;
    
    	thread_unblock(t); // t를 ready list에 추가함.
    
    	test_max_priority(); // 준코 여기 비교, yield 다있으니까
    
    	return tid;
    }
    ```

- process_wait()

    userprog/process.c

    ```c
    int
    process_wait (tid_t child_tid UNUSED) {
    	/* XXX: Hint) The pintos exit if process_wait (initd), we recommend you
    	 * XXX:       to add infinite loop here before
    	 * XXX:       implementing the process_wait. */
    	return -1;
    }
    ```

- load()

    ```c
    static bool
    load (const char *file_name, struct intr_frame *if_) {
    	struct thread *t = thread_current ();
    	struct ELF ehdr;
    	struct file *file = NULL;
    	off_t file_ofs;
    	bool success = false;
    	int i;
    
    	/* Allocate and activate page directory. */
    	t->pml4 = pml4_create ();
    	if (t->pml4 == NULL)
    		goto done;
    	process_activate (thread_current ());
    
    	/* Open executable file. */
    	file = filesys_open (file_name);
    	if (file == NULL) {
    		printf ("load: %s: open failed\\n", file_name);
    		goto done;
    	}
    
    	/* Read and verify executable header. */
    	if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
    			|| memcmp (ehdr.e_ident, "\\177ELF\\2\\1\\1", 7)
    			|| ehdr.e_type != 2
    			|| ehdr.e_machine != 0x3E // amd64
    			|| ehdr.e_version != 1
    			|| ehdr.e_phentsize != sizeof (struct Phdr)
    			|| ehdr.e_phnum > 1024) {
    		printf ("load: %s: error loading executable\\n", file_name);
    		goto done;
    	}
    
    	/* Read program headers. */
    	file_ofs = ehdr.e_phoff;
    	for (i = 0; i < ehdr.e_phnum; i++) {
    		struct Phdr phdr;
    
    		if (file_ofs < 0 || file_ofs > file_length (file))
    			goto done;
    		file_seek (file, file_ofs);
    
    		if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
    			goto done;
    		file_ofs += sizeof phdr;
    		switch (phdr.p_type) {
    			case PT_NULL:
    			case PT_NOTE:
    			case PT_PHDR:
    			case PT_STACK:
    			default:
    				/* Ignore this segment. */
    				break;
    			case PT_DYNAMIC:
    			case PT_INTERP:
    			case PT_SHLIB:
    				goto done;
    			case PT_LOAD:
    				if (validate_segment (&phdr, file)) {
    					bool writable = (phdr.p_flags & PF_W) != 0;
    					uint64_t file_page = phdr.p_offset & ~PGMASK;
    					uint64_t mem_page = phdr.p_vaddr & ~PGMASK;
    					uint64_t page_offset = phdr.p_vaddr & PGMASK;
    					uint32_t read_bytes, zero_bytes;
    					if (phdr.p_filesz > 0) {
    						/* Normal segment.
    						 * Read initial part from disk and zero the rest. */
    						read_bytes = page_offset + phdr.p_filesz;
    						zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
    								- read_bytes);
    					} else {
    						/* Entirely zero.
    						 * Don't read anything from disk. */
    						read_bytes = 0;
    						zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
    					}
    					if (!load_segment (file, file_page, (void *) mem_page,
    								read_bytes, zero_bytes, writable))
    						goto done;
    				}
    				else
    					goto done;
    				break;
    		}
    	}
    
    	/* Set up stack. */
    	if (!setup_stack (if_))
    		goto done;
    
    	/* Start address. */
    	if_->rip = ehdr.e_entry;
    
    	/* TODO: Your code goes here.
    	 * TODO: Implement argument passing (see project2/argument_passing.html). */
    
    	success = true;
    
    done:
    	/* We arrive here whether the load is successful or not. */
    	file_close (file);
    	return success;
    }
    ```

------

# Argument Passing 인자전달(월요일)

- 해당함수를 수행하는 커널스레드 생성 - 이미 되어있음

    : pintOS에서 64bit로 바뀌면서 tid_t thread_create()함수 안에 노란색으로 표시된 줄이 default로 추가되었다. 해당 내용은 struct thread안에 선언되어 있는 `struct intr_frame tf`구조체 안에 값을 초기화 해주는 내용이다.

    - **interrupt frame** 커널 스택에 저장 어셈블리어

        <aside> 💡 **interrupt frame은 커널 스택에 저장**됩니다. 인터럽트 발생 시 현재 수행 중인 프로세스의 상태를 보존하기 위해 **인터럽트 핸들러가 수행되기 전에 인터럽트 프레임이 커널 스택에 저장**됩니다. 인터럽트 핸들러는 커널 모드에서 실행되기 때문에 커널 스택을 사용합니다. 따라서 인터럽트가 발생하면 현재 사용자 모드에서 수행 중인 프로세스의 상태가 커널 스택에 저장되고, 인터럽트 핸들러에서 해당 상태를 복원할 수 있습니다.

        </aside>

        threads/intr-stubs.S

        ```c
        #include "threads/loader.h"
        
        /* Main interrupt entry point.
        
           An internal or external interrupt starts in one of the
           intrNN_stub routines, which push the `struct intr_frame'
           frame_pointer, error_code, and vec_no members on the stack,
           then jump here.
        
           We save the rest of the `struct intr_frame' members to the
           stack, set up some registers as needed by the kernel, and then
           call intr_handler(), which actually handles the interrupt.
        */
        .section .text
        .func intr_entry
        intr_entry:
        	/* Save caller's registers. */
        	subq $16,%rsp
        	movw %ds,8(%rsp)
        	movw %es,0(%rsp)
        	subq $120,%rsp
        	movq %rax,112(%rsp)
        	movq %rbx,104(%rsp)
        	movq %rcx,96(%rsp)
        	movq %rdx,88(%rsp)
        	movq %rbp,80(%rsp)
        	movq %rdi,72(%rsp)
        	movq %rsi,64(%rsp)
        	movq %r8,56(%rsp)
        	movq %r9,48(%rsp)
        	movq %r10,40(%rsp)
        	movq %r11,32(%rsp)
        	movq %r12,24(%rsp)
        	movq %r13,16(%rsp)
        	movq %r14,8(%rsp)
        	movq %r15,0(%rsp)
        	cld			/* String instructions go upward. */
        	movq $SEL_KDSEG, %rax
        	movw %ax, %ds
        	movw %ax, %es
        	movw %ax, %ss
        	movw %ax, %fs
        	movw %ax, %gs
        	movq %rsp,%rdi
        	call intr_handler
        	movq 0(%rsp), %r15
        	movq 8(%rsp), %r14
        	movq 16(%rsp), %r13
        	movq 24(%rsp), %r12
        	movq 32(%rsp), %r11
        	movq 40(%rsp), %r10
        	movq 48(%rsp), %r9
        	movq 56(%rsp), %r8
        	movq 64(%rsp), %rsi
        	movq 72(%rsp), %rdi
        	movq 80(%rsp), %rbp
        	movq 88(%rsp), %rdx
        	movq 96(%rsp), %rcx
        	movq 104(%rsp), %rbx
        	movq 112(%rsp), %rax
        	addq $120, %rsp
        	movw 8(%rsp), %ds
        	movw (%rsp), %es
        	addq $32, %rsp
        	iretq
        .endfunc
        
        /* Interrupt stubs.
        
           This defines 256 fragments of code, named `intr00_stub'
           through `intrff_stub', each of which is used as the entry
           point for the corresponding interrupt vector.  It also puts
           the address of each of these functions in the correct spot in
           `intr_stubs', an array of function pointers.
        
           Most of the stubs do this:
        
                1. Push %ebp on the stack (frame_pointer in `struct intr_frame').
        
                2. Push 0 on the stack (error_code).
        
                3. Push the interrupt number on the stack (vec_no).
        
           The CPU pushes an extra "error code" on the stack for a few
           interrupts.  Because we want %ebp to be where the error code
           is, we follow a different path:
        
                1. Push a duplicate copy of the error code on the stack.
        
                2. Replace the original copy of the error code by %ebp.
        
                3. Push the interrupt number on the stack. */
        
        /* This implements steps 1 and 2, described above, in the common
           case where we just push a 0 error code. */
        #define zero pushq $0;
        
        /* This implements steps 1 and 2, described above, in the case
           where the CPU already pushed an error code. */
        #define REAL
        
        .section .data
        .globl intr_stubs
        intr_stubs:
        
        /* Emits a stub for interrupt vector NUMBER.
           TYPE is `zero', for the case where we push a 0 error code,
           or `REAL', if the CPU pushes an error code for us. */
        #define STUB(NUMBER, TYPE)                      \\
        .section .text;                                  \\
        .globl intr##NUMBER##_stub;                     \\
        .func intr##NUMBER##_stub;			\\
        intr##NUMBER##_stub:                            \\
        	TYPE;                                   \\
        	push $0x##NUMBER;                       \\
        	jmp intr_entry;                         \\
        .endfunc; \\
        .section .data; \\
        .quad intr##NUMBER##_stub;
        
        /* All the stubs. */
        STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
        STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
        STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
        STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
        
        STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
        STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
        STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
        STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
        
        STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
        STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
        STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
        STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
        
        STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
        STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
        STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
        STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
        
        STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
        STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
        STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
        STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
        
        STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
        STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
        STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
        STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
        
        STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
        STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
        STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
        STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
        
        STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
        STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
        STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
        STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
        
        STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
        STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
        STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
        STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
        
        STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
        STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
        STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
        STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
        
        STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
        STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
        STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
        STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
        
        STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
        STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
        STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
        STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
        
        STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
        STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
        STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
        STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
        
        STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
        STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
        STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
        STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
        
        STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
        STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
        STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
        STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
        
        STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
        STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
        STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
        STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
        ```

    ```c
    tid_t thread_create(const char *name, int priority,
    					thread_func *function, void *aux)
    {
    	struct thread *t;
    	tid_t tid;
    	
    	ASSERT(function != NULL);
    
    	t = palloc_get_page(PAL_ZERO); /* 페이지할당*/
    	if (t == NULL)
    		return TID_ERROR;
    
    	init_thread(t, name, priority); /* thread 구조체 초기화*/
    	tid = t->tid = allocate_tid();	/* tid할당*/
    
    	t->tf.rip = (uintptr_t)kernel_thread;
    	t->tf.R.rdi = (uint64_t)function;
    	t->tf.R.rsi = (uint64_t)aux;
    	t->tf.ds = SEL_KDSEG;
    	t->tf.es = SEL_KDSEG;
    	t->tf.ss = SEL_KDSEG;
    	t->tf.cs = SEL_KCSEG;
    	t->tf.eflags = FLAG_IF;
    
    	thread_unblock(t); // t를 ready list에 추가함.
    
    	test_max_priority(); // 준코 여기 비교, yield 다있으니까
    
    	return tid;
    }
    ```

- 프로그램을 메모리에 적재하고 실행하는함수 - 이미 되어있음

    :process_exec()함수안에 이미 load()함수가 적혀있음

    - userprog/process.c/process_exec()

        ```c
        int
        process_exec (void *f_name) {
        	char *file_name = f_name;
        	bool success;
        
        	/* We cannot use the intr_frame in the thread structure.
        	 * This is because when current thread rescheduled,
        	 * it stores the execution information to the member. */
        	struct intr_frame _if;
        	_if.ds = _if.es = _if.ss = SEL_UDSEG;
        	_if.cs = SEL_UCSEG;
        	_if.eflags = FLAG_IF | FLAG_MBS;
        
        	/* We first kill the current context */
        	process_cleanup ();
        
        	/* And then load the binary */
        	success = load (file_name, &_if);
        
        	/* If load failed, quit. */
        	palloc_free_page (file_name);
        	if (!success)
        		return -1;
        
        	/* Start switched process. */
        	do_iret (&_if);
        	NOT_REACHED ();
        }
        ```

        - do_iret()

            **`do_iret()`** 함수는 이전에 인터럽트나 예외 처리를 실행하기 전에 저장된 레지스터 값들을 스택에서 복원하고, **`IRET`** 명령어를 실행하여 복귀합니다. 이 함수는 커널 내부에서 사용되며, 일반 사용자 프로그램에서 직접 호출되지 않습니다.

        - esp: 스택 포인터 주소 (64bit에서는 rsp)

        - eip: 세그먼트 시작 주소 ((64bit에서는 rip)

            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d2dc31ae-600f-4493-b9a3-bec3e27ecce5/Untitled.png)

    - load()

        ```c
        static bool
        load (const char *file_name, struct intr_frame *if_) {
        	struct thread *t = thread_current ();
        	struct ELF ehdr;
        	struct file *file = NULL;
        	off_t file_ofs;
        	bool success = false;
        	int i;
        
        	/* Allocate and activate page directory. */
        	t->pml4 = pml4_create ();
        	if (t->pml4 == NULL)
        		goto done;
        	process_activate (thread_current ());
        
        	/* Open executable file. */
        	file = filesys_open (file_name);
        	if (file == NULL) {
        		printf ("load: %s: open failed\\n", file_name);
        		goto done;
        	}
        
        	/* Read and verify executable header. */
        	if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
        			|| memcmp (ehdr.e_ident, "\\177ELF\\2\\1\\1", 7)
        			|| ehdr.e_type != 2
        			|| ehdr.e_machine != 0x3E // amd64
        			|| ehdr.e_version != 1
        			|| ehdr.e_phentsize != sizeof (struct Phdr)
        			|| ehdr.e_phnum > 1024) {
        		printf ("load: %s: error loading executable\\n", file_name);
        		goto done;
        	}
        
        	/* Read program headers. */
        	file_ofs = ehdr.e_phoff;
        	for (i = 0; i < ehdr.e_phnum; i++) {
        		struct Phdr phdr;
        
        		if (file_ofs < 0 || file_ofs > file_length (file))
        			goto done;
        		file_seek (file, file_ofs);
        
        		if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
        			goto done;
        		file_ofs += sizeof phdr;
        		switch (phdr.p_type) {
        			case PT_NULL:
        			case PT_NOTE:
        			case PT_PHDR:
        			case PT_STACK:
        			default:
        				/* Ignore this segment. */
        				break;
        			case PT_DYNAMIC:
        			case PT_INTERP:
        			case PT_SHLIB:
        				goto done;
        			case PT_LOAD:
        				if (validate_segment (&phdr, file)) {
        					bool writable = (phdr.p_flags & PF_W) != 0;
        					uint64_t file_page = phdr.p_offset & ~PGMASK;
        					uint64_t mem_page = phdr.p_vaddr & ~PGMASK;
        					uint64_t page_offset = phdr.p_vaddr & PGMASK;
        					uint32_t read_bytes, zero_bytes;
        					if (phdr.p_filesz > 0) {
        						/* Normal segment.
        						 * Read initial part from disk and zero the rest. */
        						read_bytes = page_offset + phdr.p_filesz;
        						zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
        								- read_bytes);
        					} else {
        						/* Entirely zero.
        						 * Don't read anything from disk. */
        						read_bytes = 0;
        						zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
        					}
        					if (!load_segment (file, file_page, (void *) mem_page,
        								read_bytes, zero_bytes, writable))
        						goto done;
        				}
        				else
        					goto done;
        				break;
        		}
        	}
        
        	/* Set up stack. */
        	if (!setup_stack (if_))
        		goto done;
        
        	/* Start address. */
        	if_->rip = ehdr.e_entry;
        
        	/* TODO: Your code goes here.
        	 * TODO: Implement argument passing (see project2/argument_passing.html). */
        
        	success = true;
        
        done:
        	/* We arrive here whether the load is successful or not. */
        	file_close (file);
        	return success;
        }
        ```

- 문자열을 파싱하고 유저스택에 인자값이 저장되도록 수정

    - process_create_initd()함수 수정

        file_name 문자열을 파싱

        첫번째토큰을 thread_create()함수에 스레드 이름으로 전달

        - 구현 코드

            ```c
            /* = process_execute()함수
            주어진 file_name을 실행하기 위해 initd 스레드를 만들고, 이 스레드에게 file_name과 fn_copy를 전달하는 함수 */
            tid_t process_create_initd (const char *file_name) {
            	char *fn_copy, *save_ptr;
            	tid_t tid;
            
            	/* Make a copy of FILE_NAME.
            	 * Otherwise there's a race between the caller and load(). */
            	fn_copy = palloc_get_page(0);
            	if (fn_copy == NULL)
            		return TID_ERROR;
            	strlcpy(fn_copy, file_name, PGSIZE);
            
            	
            	/*-------week09 추가---------*/
            	strtok_r(file_name, " ", &save_ptr);
            	/*-------week09 추가 끝---------*/
            	/* Create a new thread to execute FILE_NAME. */
            	tid = thread_create(file_name, PRI_DEFAULT, initd, fn_copy);
            	if (tid == TID_ERROR)
            		palloc_free_page(fn_copy);
            
            	return tid;
            }
            ```

    - process_exec()함수 수정

        뭉텅이 “args-single onearg”를 자르기 위해 “ “단위로 자른 token을 values[i]에 차곡차곡 저장. values[]와 몇 i까지 저장되었는지를 argument_stack으로 넘기고, &_if에 그 값들을 저장하여 반환하자.

        →file_name 문자열을 파싱 : 인자들을 토큰화(strtok_r(), string.h) 및 토큰의 개수 계산 , argument_stack() 함수를 이용해 스택에 토큰들을 저장

        - 구현코드

            ```c
            /* Switch the current execution context to the f_name.
             * Returns -1 on fail. */
            /* = start_process() 
            프로세스의 실행 파일을 불러와 인자값을 처리하고 실행시키는 함수*/
            int process_exec (void *f_name) {
            	char *file_name = f_name;
            	bool success;
            
            	struct intr_frame _if;
            	_if.ds = _if.es = _if.ss = SEL_UDSEG;
            	_if.cs = SEL_UCSEG;
            	_if.eflags = FLAG_IF | FLAG_MBS;
            	/* ----------week09 추가-------------*/
            	char *token, *save_ptr;
            	char *values[128];
            	int i = 0;
            	/* ----------week09 추가-------------*/
            	/* We first kill the current context */
            	process_cleanup ();
            
            	/* And then load the binary */
            	success = load (file_name, &_if);
            
            	/* If load failed, quit. */
            	palloc_free_page (file_name);
            	if (!success)
            		return -1;
            
            	/* ----------week09 추가-------------*/
            	token = strtok_r(f_name, " ", &save_ptr); // f_name 문자열을 공백(" ")으로 분리하여 토큰으로 만들고, token 변수에 저장
            	values[i] = token;						  // 분리한 토큰을 values 배열에 저장
            	while (token != NULL)
            	{
            		token = strtok_r(NULL, " ", &save_ptr);
            		i++;
            		values[i] = token;
            	}
            
            	argument_stack(values,i, &_if); // 스택에 함수 인자를 저장하는 함수 호출
            
            	hex_dump(_if.rsp, _if.rsp, USER_STACK - _if.rsp, true);
            	/* ----------week09 추가 끝-------------*/
            
            	/* Start switched process. */
            	do_iret (&_if);
            	NOT_REACHED ();
            }
            ```

    - void argument_stack() 함수 구현

        ```c
        void argument_stack(char **argv, int argc, struct intr_frame *if_)
        {
        	char *value_address[128];
        	/* 스택의 확장은 위->아래 방향으로 진행되므로, argv의 길이만큼 포인터를 내린 뒤 메모리 사용*/
        	for (int i = argc - 1; i >= 0; i--)
        	{
        		int parse_len = strlen(argv[i]) +EOL; /* 내려야하는 길이 구하기 arg[끝]부터 적기 ex:arg4->arg3->...*/
        		if_->rsp -= (parse_len);			  /* rsp를 구한 길이만큼 내림*/
        		memcpy(if_->rsp, argv[i], parse_len); /* stack에 데이터 포인터 적기*/
        		value_address[i] = if_->rsp;		  /* 해당 arg[i]의 포인터 주소 시작점을 value_address에 저장*/
        	}
        	// 스택 포인터 rsp가 8의 배수가 될 때까지 0으로 채우기
        	while (if_->rsp % SAU != 0) 
        	{
        		if_->rsp--;
        		memset(if_->rsp, 0, sizeof(uint8_t));
        	}
        	// 인자의 포인터 주소를 저장할 포인터 배열 value_address를 역순으로 스택에 저장
        	for (int i = argc; i >= 0; i--)
        	{
        		if_->rsp -= SAU; // 스택 포인터를 8바이트 만큼 내리기
        		if (i == argc)	 // 만약 현재 인덱스가 argc와 같다면, 즉 마지막 인덱스라면 NULL 값을 저장
        			memset(if_->rsp, 0, sizeof(char **));
        		else // 문자열의 시작 포인터가 저장되어야 한다면 그 주소값을 저장
        		{
        			memcpy(if_->rsp, &value_address[i], sizeof(char **));
        		}
        	}
        	// 스택 포인터 rsp를 다시 8바이트 만큼 내리고, 리턴 주소를 저장할 공간을 만들기
        	if_->rsp -= sizeof(void *);
        	memset(if_->rsp, 0, sizeof(void *)); // 리턴 주소를 저장할 공간에 0으로 초기화
        
        	if_->R.rdi = argc; // 레지스터에 인자 개수를 저장
        	if_->R.rsi = if_->rsp + SAU; // 레지스터에 스택에 저장된 인자들의 주소를 저장
        }
        ```

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/553d32fa-3c63-431f-aa45-c07fcd772c36/Untitled.png)

        위 그림을 구현하는 함수

        이미지와 같이 parsing한 입력 문자열을 stack에 차곡차곡 쌓고, interrupt frame의 rsp(32bit 컴퓨터에서는 esp)를 가르키는 포인터가 stack top에 위치하도록 코드를 구현하자.

    - 사용한 함수

        lib/string.c/strtok_r()

        ```c
        char *
        strtok_r (char *s, const char *delimiters, char **save_ptr) {
        	char *token;
        
        	ASSERT (delimiters != NULL);
        	ASSERT (save_ptr != NULL);
        
        	/* If S is nonnull, start from it.
        	   If S is null, start from saved position. */
        	if (s == NULL)
        		s = *save_ptr;
        	ASSERT (s != NULL);
        
        	/* Skip any DELIMITERS at our current position. */
        	while (strchr (delimiters, *s) != NULL) {
        		/* strchr() will always return nonnull if we're searching
        		   for a null byte, because every string contains a null
        		   byte (at the end). */
        		if (*s == '\\0') {
        			*save_ptr = s;
        			return NULL;
        		}
        
        		s++;
        	}
        
        	/* Skip any non-DELIMITERS up to the end of the string. */
        	token = s;
        	while (strchr (delimiters, *s) == NULL)
        		s++;
        	if (*s != '\\0') {
        		*s = '\\0';
        		*save_ptr = s + 1;
        	} else
        		*save_ptr = s;
        	return token;
        }
        ```

- pintOS 디버깅함수 hex_dump() 사용법

    - 수정해야되는 코드

        ```c
        int
        process_wait (tid_t child_tid UNUSED) {
        	/* XXX: Hint) The pintos exit if process_wait (initd), we recommend you
        	 * XXX:       to add infinite loop here before
        	 * XXX:       implementing the process_wait. */
        	while(1){
        		
        	}
        	return -1;
        }
        ```

    - 테스트 명령어

        `pintos -T 20 --fs-disk=10 -p tests/userprog/args-multiple:args-multiple -- -q -f run 'args-multiple arg1 hey2 hw3 til4’`

    - 결과

        ```c
        qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]
        Kernel command line: -q -f put args-multiple run 'args-multiple arg1 hey2 hw3 til4'
        0 ~ 9fc00 1
        100000 ~ ffe0000 1
        Pintos booting with: 
                base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
                ext_mem: 0x100000 ~ 0xffe0000 (Usable: 260,992 kB)
        Calibrating timer...  156,876,800 loops/s.
        hd0:0: detected 313 sector (156 kB) disk, model "QEMU HARDDISK", serial "QM00001"
        hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
        hd1:0: detected 102 sector (51 kB) disk, model "QEMU HARDDISK", serial "QM00003"
        Formatting file system...done.
        Boot complete.
        Putting 'args-multiple' into the file system...
        Executing 'args-multiple arg1 hey2 hw3 til4':
        000000004747ffa0  00 00 00 00 00 00 00 00-df ff 47 47 00 00 00 00 |..........GG....|
        000000004747ffb0  ed ff 47 47 00 00 00 00-f2 ff 47 47 00 00 00 00 |..GG......GG....|
        000000004747ffc0  f7 ff 47 47 00 00 00 00-fb ff 47 47 00 00 00 00 |..GG......GG....|
        000000004747ffd0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 61 |...............a|
        000000004747ffe0  72 67 73 2d 6d 75 6c 74-69 70 6c 65 00 61 72 67 |rgs-multiple.arg|
        000000004747fff0  31 00 68 65 79 32 00 68-77 33 00 74 69 6c 34 00 |1.hey2.hw3.til4.|
        system call!
        ```

# User Memory Access 유저 메모리 접근(화요일)

- 해야할 일

    - 시스템콜 구현 전, 유저가 잘못된 경로에 접근했을 때 프로그램 종료
    - 즉, 유저가 보낸 포인터가 유효한지 체크(커널을 가리키거나 할당되지 않은 메모리를 가리키면 안됨)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e40a0d18-1005-47c4-9b91-82b9b3cd374d/Untitled.png)

- kernel mode ↔ user mode 변환 method

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/abee797d-db37-4ce8-a8fb-a90b0f200628/Untitled.png)

    - process_exec()

        userprog/process.c

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/212d25d8-9306-4c05-9d0f-c29c73d588fe/Untitled.png)

        ```c
        int process_exec(void *f_name)
        {
        	char *file_name = f_name;
        	bool success;
        	// memcpy(values, file_name, strlen(file_name) + 1);
        
        	/* We cannot use the intr_frame in the thread structure.
        	 * This is because when current thread rescheduled,
        	 * it stores the execution information to the member. */
        /* 부팅 후 kernel단에서 돌아가던 process내용을 user함수를 실행하고 
        kernel단으로 복귀하기 위해 사용되는 구조체,
        interrupt_frame으로 기존에 kernel process의 실행된 정보를 저장 */
        	struct intr_frame _if;
        	_if.ds = _if.es = _if.ss = SEL_UDSEG;
        	_if.cs = SEL_UCSEG;
        	_if.eflags = FLAG_IF | FLAG_MBS;
        
        	/* We first kill the current context */
        	process_cleanup();
        
        	char *token, *save_ptr;
        	char *values[128];
        	int i = 0;
        
        	token = strtok_r(f_name, " ", &save_ptr);
        	values[i] = token;
        
        	while (token != NULL)
        	{
        		token = strtok_r(NULL, " ", &save_ptr);
        		i++;
        		values[i] = token;
        	}
        
        	/* And then load the binary */
        	success = load(file_name, &_if);
        
        	/* If load failed, quit. */
        	if (!success)
        	{
        		return -1;
        	}
        
        	/* 유저스택에 인자 저장 */
        	argument_stack(values, i, &_if);
        	// hex_dump(_if.rsp, _if.rsp, USER_STACK - _if.rsp, true);
        
        	palloc_free_page(file_name);
        
        	/* Start switched process. */
        	do_iret(&_if);
        	NOT_REACHED();
        }
        ```

    - syscall_init(void)

        <aside> 💡 **`syscall_init()`** 함수는 시스템 콜을 초기화하는 역할을 합니다.

        첫 번째로, **`write_msr()`** 함수를 사용하여 **`MSR_STAR`** 레지스터에 값을 쓰면서, 유저 모드와 커널 모드에서의 코드 세그먼트와 스택 세그먼트를 설정합니다. **`SEL_UCSEG`**는 유저 모드 코드 세그먼트, **`SEL_KCSEG`**는 커널 모드 코드 세그먼트를 나타냅니다.

        두 번째로, **`MSR_LSTAR`** 레지스터에 **`syscall_entry`** 함수의 주소를 쓰면서, **`syscall_entry()`** 함수를 시스템 콜 핸들러로 등록합니다.

        세 번째로, **`MSR_SYSCALL_MASK`** 레지스터에는 **`syscall_entry()`** 함수가 호출될 때 인터럽트가 비활성화되도록 설정합니다. 이는 **`syscall_entry()`** 함수에서 유저 모드에서 커널 모드로 전환할 때, 인터럽트가 발생하지 않도록 하기 위함입니다. 이 때 **`FLAG_IF`**를 설정하면 인터럽트가 비활성화됩니다.

        따라서 **`syscall_init()`** 함수는 시스템 콜의 호출 및 처리를 위한 준비 작업을 수행합니다.

        </aside>

        <aside> 💡  # 주석 내용 **`FLAG_FL`**은 **`EFLAGS`** 레지스터의 interrupt-enable flag이며, 이 플래그를 0으로 마스킹함으로써 인터럽트를 비활성화하고 시스템 콜을 처리하기 위해 유저 모드 스택을 커널 모드 스택으로 교체할 때까지 인터럽트가 발생하지 않도록 합니다. 따라서 **`syscall_entry`**에서 유저 모드에서 커널 모드로 전환될 때, interrupt-enable flag가 1로 설정되어 인터럽트가 활성화됩니다.

        </aside>

        ```c
        void syscall_init(void) {
        	write_msr(MSR_STAR, ((uint64_t)SEL_UCSEG - 0x10) << 48  |
        			((uint64_t)SEL_KCSEG) << 32);
        	write_msr(MSR_LSTAR, (uint64_t) syscall_entry);
        
        	/* The interrupt service rountine should not serve any interrupts
        	 * until the syscall_entry swaps the userland stack to the kernel
        	 * mode stack. Therefore, we masked the FLAG_FL. */
        	write_msr(MSR_SYSCALL_MASK,
        			FLAG_IF | FLAG_TF | FLAG_DF | FLAG_IOPL | FLAG_AC | FLAG_NT);
        }
        ```

    - syscall_entry

        <aside> 💡 x86-64 아키텍처에서 사용되는 시스템 콜 처리 과정을 구현하는 코드입니다.

        **시스템 콜을 호출한 유저 프로그램은 `syscall` 명령어를 사용해 유저 모드에서 커널 모드로 전환**합니다. 이때, **`syscall_entry`** 레이블이 있는 코드로 전환됩니다.

        이 코드는 먼저 **`syscall_entry`** 함수가 호출되면, 현재 **유저 모드 스택에 있는 값들을 커널 모드 스택으로 복사하고, 중요한 레지스터 값을 백업**합니다. 그리고 이후에, 인터럽트 플래그를 비트연산자를 사용해 클리어합니다.

        그 다음에, **`syscall_handler`** 함수를 호출하는데, 해당 함수에서는 인자 값들을 검사하고 해당 시스템 콜을 처리합니다.

        **시스템 콜 처리 후에는 이전의 인터럽트 상태를 복구하고, 유저 모드로 복귀**합니다.

        이 코드는 **`loader.h`**에 정의된 **`struct intr_frame`** 구조체를 사용해 유저 모드 스택의 인자 값들을 검사하고, 시스템 콜을 처리합니다. **`syscall_init`** 함수는 시스템 콜을 위한 인터럽트 핸들러를 등록하는 역할을 합니다.

        </aside>

        userprog/syscall-entry.S

        ```c
        #include "threads/loader.h"
        
        .text
        .globl syscall_entry
        .type syscall_entry, @function
        syscall_entry:
        	movq %rbx, temp1(%rip)
        	movq %r12, temp2(%rip)     /* callee saved registers */
        	movq %rsp, %rbx            /* Store userland rsp    */
        	movabs $tss, %r12
        	movq (%r12), %r12
        	movq 4(%r12), %rsp         /* Read ring0 rsp from the tss */
        	/* Now we are in the kernel stack */
        	push $(SEL_UDSEG)      /* if->ss */
        	push %rbx              /* if->rsp */
        	push %r11              /* if->eflags */
        	push $(SEL_UCSEG)      /* if->cs */
        	push %rcx              /* if->rip */
        	subq $16, %rsp         /* skip error_code, vec_no */
        	push $(SEL_UDSEG)      /* if->ds */
        	push $(SEL_UDSEG)      /* if->es */
        	push %rax
        	movq temp1(%rip), %rbx
        	push %rbx
        	pushq $0
        	push %rdx
        	push %rbp
        	push %rdi
        	push %rsi
        	push %r8
        	push %r9
        	push %r10
        	pushq $0 /* skip r11 */
        	movq temp2(%rip), %r12
        	push %r12
        	push %r13
        	push %r14
        	push %r15
        	movq %rsp, %rdi
        
        check_intr:
        	btsq $9, %r11          /* Check whether we recover the interrupt */
        	jnb no_sti
        	sti                    /* restore interrupt */
        no_sti:
        	movabs $syscall_handler, %r12
        	call *%r12
        	popq %r15
        	popq %r14
        	popq %r13
        	popq %r12
        	popq %r11
        	popq %r10
        	popq %r9
        	popq %r8
        	popq %rsi
        	popq %rdi
        	popq %rbp
        	popq %rdx
        	popq %rcx
        	popq %rbx
        	popq %rax
        	addq $32, %rsp
        	popq %rcx              /* if->rip */
        	addq $8, %rsp
        	popq %r11              /* if->eflags */
        	popq %rsp              /* if->rsp */
        	sysretq
        
        .section .data
        .globl temp1
        temp1:
        .quad	0
        .globl temp2
        temp2:
        .quad	0
        ```

- resister 종류 설명

    [x64 ABI 규칙 | Microsoft Learn](https://learn.microsoft.com/ko-kr/cpp/build/x64-software-conventions?view=msvc-170)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7079d182-69f2-4f5f-bca1-89cd68afd5a5/Untitled.png)

    <aside> 💡 필요한 인자 : 1번째 인자: %rdi // 메모리를 이동하고 비교할 때 그 목적지 주소 2번째 인자: %rsi // 메모리를 이동하고 비교할 때 그 출발지 주소 3번째 인자: %rdx 4번째 인자: %r10 5번째 인자: %r8 6번째 인자: %r9

    </aside>

### check_address() 구현

:주소유효성 검사:포인터가 가리키는 주소가 사용자영역(0x8048000~0xc0000000)인지 확인 → 유저영역을벗어난영역일경우프로세스종료(exit(-1))

- 구현 코드

    ```c
    void check_address(const void *addr)
    {
    	/* 주소가 NULL이면 예외 처리 ,주소가 유저 영역이 아니면 예외 처리*/
    	if (addr == NULL || is_kernel_vaddr(addr))
    	{
    		exit(-1);
    	}
    }
    ```

    addr의 validation 미흡

    ------

- 수정 코드

    ```c
    void check_address(const void *addr)
    {
    	/* 주소가 유효하지 않으면 예외 처리 ,주소가 유저 영역이 아니면 예외 처리*/
    	if (addr == NULL || pml4_get_page(&thread_current()->pml4, addr) == NULL || is_kernel_vaddr(addr))
    	{
    		exit(1);
    	}
    }
    ```

- 사용 함수

    threads/mmu.c

    ```c
    /* Looks up the physical address that corresponds to user virtual
     * address UADDR in pml4.  Returns the kernel virtual address
     * corresponding to that physical address, or a null pointer if
     * UADDR is unmapped. */
    void *
    pml4_get_page (uint64_t *pml4, const void *uaddr) {
    	ASSERT (is_user_vaddr (uaddr));
    
    	uint64_t *pte = pml4e_walk (pml4, (uint64_t) uaddr, 0);
    
    	if (pte && (*pte & PTE_P))
    		return ptov (PTE_ADDR (*pte)) + pg_ofs (uaddr);
    	return NULL;
    }
    ```

    이 함수는 **가상 주소(uaddr)에 해당하는 물리 주소를 찾는 함수**입니다. 먼저 uaddr가 유저 영역의 주소인지 검사하고, PML4 테이블에서 가상 주소에 대한 PML4 엔트리를 찾습니다. 이때, PML4 테이블에서 가상 주소를 찾아 가리키는 페이지 테이블 엔트리(PTE)를 가져옵니다.

    만약 페이지 테이블 엔트리가 유효하고, 해당 페이지가 메모리에 적재되어 있다면(pt_present) 이 **페이지의 물리 주소를 계산하고 반환**합니다. 계산할 때는 물리 주소 = (PTE & 0x000ffffffffff000) | (uaddr & 0x0000000000000fff) 로 계산합니다. 이때, ptov() 함수를 이용해 가상 주소로부터 커널 주소로 변환합니다.

    반환값으로는 **uaddr에 해당하는 물리 주소를 반환하거나, 해당 페이지가 메모리에 없거나 PTE가 유효하지 않을 경우 NULL을 반환**합니다.

### get_argument() 구현→ 필요없음

:  pintOS가 64bit로 바뀌면서 **`syscall_entry`** , **`syscall_handler`** 코드가 추가되었다. 해당 코드 덕분에 get_argument()함수같이 **시스템 콜 인자를 커널(arg 배열)에 복사하는 함수를 구현할 필요가 없어졌다. (더 자세한 설명은 ‘**kernel mode ↔ user mode 변환 method’의 syscall_entry정리 내용을 참고해주세요)

멋모를 때 구현한 코드는 아래에

- logic

    **시스템 콜 인자를 커널(arg 배열)에 복사**한다.

    **스택 포인터를 참조해서 count만큼 스택에 저장된 인자들을 arg 배열로 복사**한다.

    → 스택에서 인자들을 4byte 크기로꺼내어 arg배열에 순차적으로 저장

    →  count 개수만큼의 인자를 스택에서 가져옴

    이 때 해당 인자들이 저장된 메모리 주소가 유저 영역인지 확인한다.

- 구현 코드

    userprog/syscall.c

    ```c
    void get_argument(void *rsp, int *arg, int count)
    {
    	void *find = rsp + 8;
    
    	for (int i=0; i<=count; i++)
    	{
    		check_address(find);
    		
    		memcpy(find, &arg[i], 8);
    		find +=8;
    	}
    }
    ```

- 참고 코드

    ```c
    void get_argument(void *rsp, int **arg, int count){
    	rsp = (int64_t *)rsp + 2;  // 원래 stack pointer에서 2칸(16byte) 올라감 : |argc|"argv"|...
    	for (int i=0; i<count; i++){
    		arg[i] = rsp;
    		rsp = (int64_t *)rsp + 1;
    	}
    }
    ```

- 수정 코드

    ```c
    void get_argument(void *rsp, int **arg, int count)
    {
    	rsp = (int64_t *)rsp + 2; // 원래 stack pointer에서 2칸(16byte) 올라감 : |argc|"argv"|...
    	for (int i = 0; i < count; i++)
    	{
    		check_address(rsp); //진교 추가
    		arg[i] = rsp;
    		rsp = (int64_t *)rsp + 1;
    	}
    }
    ```

### syscall_handler() 구현

- logic

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/909d5d2d-d3ad-4b23-b019-f193b49e6a40/Untitled.png)

    <aside> 💡  syscall_handler()란?

    - syscallN()함수가 레지스터의 값을 syscall_handler를 위해 세팅해줌
    - 시스템콜 핸들러에서 시스템 콜번호에 해당하는 시스템콜 호출 (%rax 에 그 번호가 담긴 systemcall을 부르게됨.)
    - 시스템콜 핸들러에서 유저스택 포인터(esp) 주소와 인자가 가리키는 주소(포인터)가 유저영역인지 확인
    - 유저스택에 있는 인자들을 커널에 저장
    - 시스템콜의 함수의 리턴값은 인터럽트프레임의 rax에 저장 </aside>

- 구현 코드

    userprog>syscall.c

    ```c
    void
    syscall_handler (struct intr_frame *f) {
    	check_address(f->rsp);
    
    	int count = f->R.rdi;
    	void *check_ptr = f->R.rsi;
    	void* tmp;
    	void* args[count];
    	
    
    	for(int i=1; i <= count; i++)
    	{
    		memcpy(check_ptr, &tmp, 8);
    		check_address(tmp);
    		args[i]= tmp;
    	}
    	
    	switch (count)
    	{
    		case SYS_HALT:
    			halt();
    			break;
    		case SYS_EXIT:
    			exit(args[1]);
    			break;
    		case SYS_FORK:
    			fork(args[1]);
    			break;
    		case SYS_EXEC:
    			exec(args[1]);
    			break;
    		case SYS_WAIT:
    			wait(args[1]);
    			break;
    		case SYS_CREATE:
    			create(args[1],args[2]);
    			break;
    		case SYS_REMOVE:
    			remove(args[1]);
    			break;
    		case SYS_OPEN:
    			open(args[1]);
    			break;
    		case SYS_FILESIZE:
    			filesize(args[1]);
    			break;
    		case SYS_READ:
    			read(args[1], args[2], args[3]);
    			break;
    		case SYS_WRITE:
    			write(args[1], args[2], args[3]);
    			break;
    		case SYS_SEEK:
    			seek(args[1], args[2]);
    			break;
    		case SYS_TELL:
    			tell(args[1]);
    			break;
    		case SYS_CLOSE:
    			close(args[1]);
    			break;
    		case SYS_DUP2:
    			dup2(args[1], args[2]);
    			break;
    		case SYS_MMAP:
    			mmap(args[1], args[2], args[3], args[4], args[5]);
    			break;
    		case SYS_MUNMAP:
    			munmap(args[1]);
    			break;
    		case SYS_CHDIR:
    			chdir(args[1]);
    			break;
    		case SYS_MKDIR:
    			mkdir(args[1]);
    			break;
    		case SYS_READDIR:
    			readdir(args[1], args[2]);
    			break;
    		case SYS_ISDIR:
    			isdir(args[1]);
    			break;
    		case SYS_INUMBER:
    			inumber(args[1]);
    			break;
    		case SYS_SYMLINK:
    			symlink(args[1], args[2]);
    			break;
    		case SYS_MOUNT:
    			mount(args[1], args[2], args[3]);
    			break;
    		case SYS_UMOUNT:
    			umount(args[1]);
    			break;
    		default:
    			thread_exit();
    	}
    
    	printf("system call!\\n");
    	thread_exit ();
    }
    ```

- 참고 코드

    ```c
    void
    syscall_handler (struct intr_frame *f UNUSED) {
    	/* 유저 스택에 저장되어 있는 시스템 콜 넘버를 가져와야지 일단 */
    	int sys_number = f->R.rax; // rax: 시스템 콜 넘버
        /* 
    	인자 들어오는 순서:
    	1번째 인자: %rdi
    	2번째 인자: %rsi
    	3번째 인자: %rdx
    	4번째 인자: %r10
    	5번째 인자: %r8
    	6번째 인자: %r9 
    	*/
    	// TODO: Your implementation goes here.
    	switch(sys_number) {
    		case SYS_HALT:
    			halt();
    		case SYS_EXIT:
    			exit(f->R.rdi);
    		case SYS_FORK:
    			fork(f->R.rdi);		
    		case SYS_EXEC:
    			exec(f->R.rdi);
    		case SYS_WAIT:
    			wait(f->R.rdi);
    		case SYS_CREATE:
    			create(f->R.rdi, f->R.rsi);		
    		case SYS_REMOVE:
    			remove(f->R.rdi);		
    		case SYS_OPEN:
    			open(f->R.rdi);		
    		case SYS_FILESIZE:
    			filesize(f->R.rdi);
    		case SYS_READ:
    			read(f->R.rdi, f->R.rsi, f->R.rdx);
    		case SYS_WRITE:
    			write(f->R.rdi, f->R.rsi, f->R.rdx);		
    		case SYS_SEEK:
    			seek(f->R.rdi, f->R.rsi);		
    		case SYS_TELL:
    			tell(f->R.rdi);		
    		case SYS_CLOSE:
    			close(f->R.rdi);	
    	}
    	printf ("system call!\\n");
    	thread_exit ();
    }
    ```

- 수정코드

    ```c
    void syscall_handler(struct intr_frame *f)
    {
    	/* 포인터 레지스터인 rsp 주소 확인 필요*/
    	check_address(&f->rsp);
    
    	switch (f->R.rax) // rax값이 들어가야함.
    	{
    	case SYS_HALT:
    		halt();
    		break;
    	case SYS_EXIT:
    		exit(f->R.rdi);
    		break;
    	case SYS_FORK:
    		fork(f->R.rdi);
    		break;
    	case SYS_EXEC:
    		exec(f->R.rdi);
    		break;
    	case SYS_WAIT:
    		wait(f->R.rdi);
    		break;
    	case SYS_CREATE:
    		f->R.rax = create(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_REMOVE:
    		f->R.rax = remove(f->R.rdi);
    		break;
    	case SYS_OPEN:
    		open(f->R.rdi);
    		break;
    	case SYS_FILESIZE:
    		f->R.rax = filesize(f->R.rdi);
    		break;
    	case SYS_READ:
    		read(f->R.rdi, f->R.rsi, f->R.rdx);
    		break;
    	case SYS_WRITE:
    		write(f->R.rdi, f->R.rsi, f->R.rdx);
    		break;
    	case SYS_SEEK:
    		seek(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_TELL:
    		tell(f->R.rdi);
    		break;
    	case SYS_CLOSE:
    		close(f->R.rdi);
    		break;
    	case SYS_DUP2:
    		dup2(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_MMAP:
    		mmap(f->R.rdi, f->R.rsi, f->R.rdx, f->R.r10, f->R.r8);
    		break;
    	case SYS_MUNMAP:
    		munmap(f->R.rdi);
    		break;
    	case SYS_CHDIR:
    		chdir(f->R.rdi);
    		break;
    	case SYS_MKDIR:
    		mkdir(f->R.rdi);
    		break;
    	case SYS_READDIR:
    		readdir(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_ISDIR:
    		isdir(f->R.rdi);
    		break;
    	case SYS_INUMBER:
    		inumber(f->R.rdi);
    		break;
    	case SYS_SYMLINK:
    		symlink(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_MOUNT:
    		mount(f->R.rdi, f->R.rsi, f->R.rdx);
    		break;
    	case SYS_UMOUNT:
    		umount(f->R.rdi);
    		break;
    	default:
    		thread_exit();
    	}
    
    	printf("system call!\\n");
    	thread_exit();
    }
    ```

    s**ystemcall_handler()에서 rsi, rdi, rbp, rsp와 같은 레지스터가 가리키는 주소가 유효한 user address인지 확인하는 것은 매우 중요**합니다. 이는 유저 스택이나 유저 데이터를 읽거나 쓸 때 프로그램의 안정성과 보안성을 보장하기 위해 필요한 작업입니다. 따라서 systemcall_handler()에서 이러한 주소들의 유효성을 검사하는 것은 좋은 습관입니다.

# system call 시스템콜(수,목요일)

시스템 콜(System Call)은 컴퓨터 프로그램이 운영 체제의 커널에서 서비스를 요청하는 프로그램 방식입니다. 이러한 호출은 일반적으로 C로 작성된 루틴으로 제공됩니다.

- 함수 flow

    <aside> 💡 user func→ syscallN→syscall()→syscall_entry.S→syscall_handler()→우리가 작성한 systemcall()

    </aside>

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/254e4f61-7d69-477d-b385-3cb3df2e75a2/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9f67f038-a057-4104-a1b6-09f4dd77f656/Untitled.png)

- logic

    - writing a simple program to read data from one file and copy them to another file

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b0bbf95-9c36-4a7e-879a-b018db86eaee/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/79d7db57-1e65-4f28-8b6a-a2081f34371b/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/79ce3e7a-95a0-4905-bd55-272dd726ab59/Untitled.png)

    1. Acquire input filename: 어떤 파일에 input할건지, 어떤 파일을 input할건지 filename필요

        입력받거나, selecter

    2. write prompt to screen: device systemcall 필요

    3. accept input: systemcall 필요

    https://youtu.be/v30ilCpITnY

    ------

- 관련 매크로&함수

    1. NOT_REACHED()

        ```c
        #define NOT_REACHED() PANIC ("executed an unreachable statement");
        ```

        <aside> 💡 **`NOT_REACHED()`**은 매크로 함수로, 절대로 도달하지 않아야 하는 코드가 실행된 경우 panic 상태에 빠지도록 하는 역할을 합니다. 예를 들어, **`switch`**문 등에서 default case에 **`NOT_REACHED()`**를 작성하면, case 중 하나가 아닌 다른 값을 받아들이는 경우, 이 코드는 실행되지 않기 때문에 코드가 잘못 작성되었음을 파악할 수 있습니다. 따라서 이 매크로는 디버깅을 쉽게 하기 위해 사용됩니다.

        </aside>

    2. syscallN()

        <aside> 💡 **`syscall()`** 함수는 주어진 시스템 콜 번호(**`NUMBER`**)를 호출하고, 인자를 전달하지 않고 실행합니다. 그리고 실행 결과를 **`int`** 형태로 반환합니다. 이 함수는 프로그램이 커널에 있는 서비스를 요청하고, 그 결과를 프로그램에 반환할 때 사용됩니다.

        예를 들어, **`syscall(SYS_EXIT, 0)`**는 현재 프로세스를 종료하도록 커널에 요청하고, 종료 코드 0을 반환합니다. **`syscall(SYS_WRITE, 1, "Hello, world!\\n", 14)`**는 "Hello, world!" 문자열을 표준 출력으로 출력하도록 커널에 요청하고, 출력한 바이트 수(14)를 반환합니다.

        </aside>

        ```c
        #define syscall0(NUMBER) ( \\
        		syscall(((uint64_t) NUMBER), 0, 0, 0, 0, 0, 0))
        
        /* Invokes syscall NUMBER, passing argument ARG0, and returns the
           return value as an `int'. */
        #define syscall1(NUMBER, ARG0) ( \\
        		syscall(((uint64_t) NUMBER), \\
        			((uint64_t) ARG0), 0, 0, 0, 0, 0))
        /* Invokes syscall NUMBER, passing arguments ARG0 and ARG1, and
           returns the return value as an `int'. */
        #define syscall2(NUMBER, ARG0, ARG1) ( \\
        		syscall(((uint64_t) NUMBER), \\
        			((uint64_t) ARG0), \\
        			((uint64_t) ARG1), \\
        			0, 0, 0, 0))
        
        #define syscall3(NUMBER, ARG0, ARG1, ARG2) ( \\
        		syscall(((uint64_t) NUMBER), \\
        			((uint64_t) ARG0), \\
        			((uint64_t) ARG1), \\
        			((uint64_t) ARG2), 0, 0, 0))
        
        .
        .
        .
        ```

## process descriptor (수요일)

- logic

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e2aceacf-2c75-4a7e-a16f-bd821aa43c3d/Untitled.png)

    <aside> 💡 프로세스 디스크립터(Process descriptor)는 운영 체제에서 현재 실행 중인 **프로세스에 대한 정보를 유지하고 있는 데이터 구조**입니다. 프로세스 디스크립터는 일반적으로 프로세스의 ID, 상태, 우선 순위, 프로세스 테이블 항목 등의 정보를 저장합니다. 또한, 프로세스 디스크립터는 프로세스의 스케줄링, 메모리 할당, 파일 시스템 등과 같은 운영 체제 서비스에 필요한 정보를 유지합니다. 따라서 프로세스 디스크립터는 운영 체제에서 프로세스 관리에 중요한 역할을 합니다.

    </aside>

- struct thread 수정

    include/threads/thread.h

    - 구현 코드1

        ```c
        /* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/* 준코 user program */
        	struct thread* pp_fd;
        	struct list_elem children_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        	int exit_status;
        ```

    - 구현 코드2

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion 관련 element 추가 */
        	int init_priority;				// donation이후 우선순위를 초기화하기 위해 초기값 저장
        	struct lock *wait_on_lock;		// 해당 스레드가 대기하고 있는 lock자료구조 주소 저장
        	struct list donations;			// multiple donation 을 고려하기 위해사용
        	struct list_elem donation_elem; // multiple donation 을 고려하기 위해사용
        									/*----------------[project1]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/* 준코's user program */
        	/* parent-children hierachy */
        
        	struct thread* parent_pd; // 부모 프로세스의 디스크립터
        	struct list_elem children_elem;
        	struct list children_list;
        
        	/* 준코 : 일단 만들어 놓자  */
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	int exit_status;
        
        	/* 준코 */
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        };
        ```

    - 최종 수정

        include/threads/thread.h

        ```c
        /*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // 부모 프로세스의 디스크립터
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        	/*----------------[project2]-------------------*/
        ```

- threads/thread.c/thread_create() 추가

    - 구현 코드1

        ```c
        /* project2 프로세스 계층 구조 구현  */
        	struct thread *curr = thread_current();
        	if( curr != NULL){
        		t->parent_pd = curr;
        		sema_init(&curr->exit_sema, 0);
        		sema_init(&curr->load_sema, 0);
        		sema_init(&curr->wait_sema, 0);
        	}
        ```

        잘못된 생각

        : sema init을 여기서 해야된다고 생각함.

        chileren_list관리를 안함 : 현재 thread(부모)에 방금 생성된 thread(자식)의 elem을 추가해야됨.

    - 수정 코드1 : thread_create()

        ```c
        // if (curr != NULL)
        	// {
        	// 	t->parent_pd = curr;
        	// 	sema_init(&curr->exit_sema, 0);
        	// 	sema_init(&curr->load_sema, 0);
        	// 	sema_init(&curr->wait_sema, 0);
        	// }
        	list_push_back(&curr->children_list, &t->child_elem);
        ```

- init_thread() 수정

    sema init를 init_thread()에서 하도록 수정

    ```c
    list_init(&t->donations);
    	/*----------------[project1]-------------------*/
    	list_init(&t->children_list);
    
    	sema_init(&t->wait_sema, 0);
    	sema_init(&t->fork_sema, 0);
    	sema_init(&t->free_sema, 0);
    
    	/*---------------[준코]------------------------*/
    }
    ```

- threads/thread.c/thread_exit() 추가

    - 구현 코드

        ```c
        #endif
        
        	intr_disable();
        	sema_up(&list_entry(&thread_current()->elem, struct thread, elem)->wait_sema);
        	list_remove (&thread_current()->elem); // elem? all elem? 😡
        	do_schedule(THREAD_DYING);
        	NOT_REACHED();
        }
        ```

    - 수정 코드

        ```c
        #endif
        
        	intr_disable();
        	// sema_up(&list_entry(&thread_current()->elem, struct thread, elem)->wait_sema);
        	list_remove(&thread_current()->allelem); // elem? all elem? 😡
        	do_schedule(THREAD_DYING);
        	NOT_REACHED();
        }
        ```

- threads/thread.c/init_thread() 추가

    threads/thread.c

    - 구현 코드1

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        	/*---------------[준코]------------------------*/
        }
        ```

    - 수정 코드

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        
        	sema_init(&t->wait_sema, 0);
        	sema_init(&t->fork_sema, 0);
        	sema_init(&t->free_sema, 0);
        
        	/*---------------[준코]------------------------*/
        }
        ```

- userprog/process.c/int process_exec(void *f_name) 추가

    - 구현 코드 : 수정사항 없음 💕

        ```c
        /* And then load the binary */
        	success = load(file_name, &_if);
        
        	/* project2 system call */
        	if (success)
        	{
        		struct thread *curr = thread_current();
        		struct thread *target = list_entry(&curr->child_elem, struct thread, child_elem);
        		sema_up(&target->wait_sema);
        	}
        ```

- userprog/process.c/int process_wait(tid_t child_tid UNUSED) 구현

    - 구현 코드

        ```c
        int process_wait(tid_t child_tid UNUSED)
        {
        	struct thread *child = get_child_process(pid);
        	struct thread *curr = thread_current();
        	if(child = NULL){
        		return -1;
        	}
        	sema_down(&curr->wait_sema);
        	thread_exit();
        	return &child->status;
        
        }
        ```

    - 수정 코드

        ```c
        int process_wait(tid_t child_tid UNUSED)
        {
        	struct thread *child = get_child_process(child_tid);
        	struct thread *curr = thread_current();
        	if (child = NULL)
        	{
        		return -1;
        	}
        	sema_down(&curr->wait_sema);
        	// thread_exit();
        	list_remove(&child->child_elem);
        	sema_up(&child->free_sema);
        	return &child->exit_status;
        }
        ```

- userprog/process.c/struct thread *get_child_process(int pid) 구현

    - 구현 코드 : 수정사항 없음 💕

        ```c
        struct thread *get_child_process(int pid)
        {
        	struct thread *curr = thread_current();
        	struct list_elem *find = list_begin(&curr->children_list);
        	while (find != NULL)
        	{
        		if (list_entry(find, struct thread, child_elem)->tid = pid)
        		{
        			return list_entry(find, struct thread, child_elem);
        		}
        		else
        		{
        			find = list_next(find);
        		}
        	}
        	return NULL;
        }
        ```

- userprog/process.c/remove_child_process(struct thread *cp) 구현

    - 구현 코드 : 수정사항 없음 💕

        ```c
        void remove_child_process(struct thread *cp)
        {
        	list_remove(&cp->child_elem);
        	free(*cp);
        }
        ```

- userprog/syscall.c/int exec(const *cmd_line) 구현

    - 구현 코드 : 수정사항 없음 💕

        ```c
        int exec(const *cmd_line)
        {
        	struct thread *curr = thread_current();
        	tid_t pid = process_create_initd(cmd_line);	   // cmd_line parsing해서 file_name 추출해서 넣음.
        												   /* sema_down 옛터  */
        	struct thread *child = get_child_process(pid); // 생성된 자식 프로세스의 디스크립터 검색 미구현 😡
        	int result = process_wait(child);			   // 자식 프로세스의 프로그램 적재 대기😡
        	list_push_back(&curr->children_list, &child->child_elem);
        
        	if (result = 1) // 적재 성공시
        	{
        		return pid;
        	}
        	else
        	{ // 적재 실패시
        		return -1;
        	}
        }
        ```

## file descriptor(목요일)

- struct thread 추가

    include/threads/thread.h

    - 구현 코드

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion 관련 element 추가 */
        	int init_priority;				// donation이후 우선순위를 초기화하기 위해 초기값 저장
        	struct lock *wait_on_lock;		// 해당 스레드가 대기하고 있는 lock자료구조 주소 저장
        	struct list donations;			// multiple donation 을 고려하기 위해사용
        	struct list_elem donation_elem; // multiple donation 을 고려하기 위해사용
        									/*----------------[project1]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // 부모 프로세스의 디스크립터
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        
        	struct file **fdt;
        	int next_fd;
        
        	/*----------------[project2]-------------------*/
        };
        ```

    - 참고 코드

        ```c
        struct thread {
        	/* Owned by thread.c. */
        	tid_t tid;                          /* Thread identifier. */
        	enum thread_status status;          /* Thread state. */
        	char name[16];                      /* Name (for debugging purposes). */
        	int priority;                       /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem;              /* List element. */
        
        	/* ==================== project1 ==================== */
        	/* priority donation */
        	/* priority를 양도 받고 반환하고나서 원래 priority를 복원하기 위해 기록*/
        	int init_priority; 
        	/* thread가 현재 얻기 위해 기다리고 있는 lock 으로 스레드는 이 lock 이 release 되기를 기다린다. */
        	struct lock *wait_on_lock; 
        	/* 자신에게 priority 를 나누어준 thread들의 리스트이고 */
        	struct list donations; 
        	 /*  donations 리스트를 관리하기 위한 element 로 thread 구조체의 그냥 elem 과 구분하여 사용하도록 한다. */
        	struct list_elem donation_elem;
        	
        	/* Wake Up Time Tick (시스템이 시작된 이후부터 언제 일어나야되는지 알려주는 시간) */
        	int64_t wake_ticks;
        	/* ==================== project1 ==================== */
        
        	/* ==================== project2 ==================== */
        	// 2-3 Parent-child hierarchy
        	struct list child_list;		 // keep children
        	struct list_elem child_elem; // used to put current thread into 'children' list
        	// 2-3 wait syscall
        	// struct semaphore wait_sema; // used by parent to wait for child
        	int exit_status;			// used to deliver child exit_status to parent
        	// 2-3 fork syscall
        	struct intr_frame parent_if; // to preserve my current intr_frame and pass it down to child in fork ('parent_if' in child's perspective)
        	// struct semaphore fork_sema;	 // parent wait (process_wait) until child fork completes (__do_fork)
        	// struct semaphore free_sema;	 // Postpone child termination (process_exit) until parent receives its exit_status in 'wait' (process_wait)
        	// 2-4 file descripter
        	struct file **fdTable; // allocation in threac_create (thread.c)
        	int fdIdx;			   // an index of an open spot in fdTable
        	// 2-5 deny exec writes
        	struct file *running; // executable ran by current process (process.c load, process_exit)
        	// 2-extra - count the number of open stdin/stdout
        	// dup2 may copy stdin or stdout; stdin or stdout is not really closed until these counts goes 0
        	int stdin_count;
        	int stdout_count;
        	/* ==================== project2 ==================== */
        	
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4;                     /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf;               /* Information for switching */
        	unsigned magic;                     /* Detects stack overflow. */
        };
        ```

    - 수정 코드

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion 관련 element 추가 */
        	int init_priority;				// donation이후 우선순위를 초기화하기 위해 초기값 저장
        	struct lock *wait_on_lock;		// 해당 스레드가 대기하고 있는 lock자료구조 주소 저장
        	struct list donations;			// multiple donation 을 고려하기 위해사용
        	struct list_elem donation_elem; // multiple donation 을 고려하기 위해사용
        									/*----------------[project1]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // 부모 프로세스의 디스크립터
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        
        	struct file **fdt;
        	int next_fd;
        	/* 🤔 */
        	struct file *running; // 현재 스레드가 사용 중인 파일(load하고 있는 파일)
        	int stdin_count;
        	int stdout_count;
        	/*----------------[project2]-------------------*/
        };
        ```

- init_thread() 수정

    - 구현코드

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        
        	sema_init(&t->wait_sema, 0);
        	sema_init(&t->fork_sema, 0);
        	sema_init(&t->free_sema, 0);
        	
        	/* project 2: system call*/
        	t->exit_status = 0;
        	/*---------------[준코]------------------------*/
        }
        ```

- thread_create() 추가

    threads/thread.c

    - 구현 코드

        ```c
        tid_t thread_create(const char *name, int priority,
        					thread_func *function, void *aux)
        {
        	struct thread *t;
        	tid_t tid;
        
        	ASSERT(function != NULL);
        
        	t = palloc_get_page(PAL_ZERO);
        	if (t == NULL)
        		return TID_ERROR;
        
        	init_thread(t, name, priority);
        	tid = t->tid = allocate_tid();
        
        	t->tf.rip = (uintptr_t)kernel_thread;
        	t->tf.R.rdi = (uint64_t)function;
        	t->tf.R.rsi = (uint64_t)aux;
        	t->tf.ds = SEL_KDSEG;
        	t->tf.es = SEL_KDSEG;
        	t->tf.ss = SEL_KDSEG;
        	t->tf.cs = SEL_KCSEG;
        	t->tf.eflags = FLAG_IF;
        
        	/* project2 프로세스 계층 구조 구현  */
        	struct thread *curr = thread_current();
        
        	list_push_back(&curr->children_list, &t->child_elem);
        
        	/* 스레드 생성시 File Descriptor 초기화 */
        	t->fdt = palloc_get_page(0);
        	for(int i=0; i<128; i++){
        		t->fdt[i]=NULL;
        	}
        	t->next_fd = 2;
        
        	thread_unblock(t); // t를 ready list에 추가함.
        
        	test_max_priority(); // 준코 여기 비교, yield 다있으니까
        						 // 여기는 5월 2일 준코 반갑다!
        
        	return tid;
        }
        ```

    - 구현 코드2

        ```c
        tid_t thread_create(const char *name, int priority,
        					thread_func *function, void *aux)
        {
        	struct thread *t;
        	tid_t tid;
        
        	ASSERT(function != NULL);
        
        	t = palloc_get_page(PAL_ZERO);
        	if (t == NULL)
        		return TID_ERROR;
        
        	init_thread(t, name, priority);
        	tid = t->tid = allocate_tid();
        
        	t->tf.rip = (uintptr_t)kernel_thread;
        	t->tf.R.rdi = (uint64_t)function;
        	t->tf.R.rsi = (uint64_t)aux;
        	t->tf.ds = SEL_KDSEG;
        	t->tf.es = SEL_KDSEG;
        	t->tf.ss = SEL_KDSEG;
        	t->tf.cs = SEL_KCSEG;
        	t->tf.eflags = FLAG_IF;
        
        	/* project2 프로세스 계층 구조 구현  */
        	struct thread *curr = thread_current();
        
        	list_push_back(&curr->children_list, &t->child_elem);
        
        	/*  94p
        		😡 프로그램이 로드되지 않음
        		😡 프로세스가 종료되지 않음
        		😡자식리스트에 추가		*/
        
        	/* 스레드 생성시 File Descriptor 초기화 */
        	t->fdt = palloc_get_multiple(PAL_ZERO, FDT_PAGES);
        	if (t->fdt == NULL)
        	{
        		return TID_ERROR;
        	}
        	t->next_fd = 2;
        	t->fdt[0] = 1;
        	t->fdt[1] = 2;
        
        	thread_unblock(t); // t를 ready list에 추가함.
        
        	test_max_priority(); // 준코 여기 비교, yield 다있으니까
        						 // 여기는 5월 2일 준코 반갑다!
        
        	return tid;
        }
        ```

    - 참고 코드

        [PintOS Project 2 - User Program (7) System Call(정글사관학교 69일차 TIL) - 파일 디스크립터 관련 system call 구현 (tistory.com)](https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-7-System-Call정글사관학교-69일차-TIL)

        ```c
        tid_t
        thread_create (const char *name, int priority,
        		thread_func *function, void *aux) {
        	
            (...)
        
        	/* --- project 2: system call --- */
        	t->file_descriptor_table = palloc_get_multiple(PAL_ZERO, FDT_PAGES);
        	if (t->file_descriptor_table == NULL) {
        		return TID_ERROR;
        	}
        	t->fdidx = 2; // 0은 stdin, 1은 stdout에 이미 할당
        	t->file_descriptor_table[0] = 1; // stdin 자리: 1 배정
        	t->file_descriptor_table[1] = 2; // stdout 자리: 2 배정
        
        }
        ```

        노션 코드

        ```c
        tid_t thread_create (const char *name, int priority, thread_func *function, void *aux){
        ...
        	t->fdTable = palloc_get_multiple(PAL_ZERO, FDT_PAGES);  // 해당 프로세스의 FDT 공간 할당
          if (t->fdTable == NULL)  // 제대로 공간이 할당되지 않았다면 에러.
              return TID_ERROR;
        
          t->fdIdx = 2;       // 0 : stdin, 1 : stdout이므로 새 파일이 open()하면 2부터 시작.
          t->fdTable[0] = 1;  // 의미가 있는 숫자는 아니다. 다만 해당 인덱스(식별자)를 사용하는 파일이 존재하므로 넣어준 것.
          t->fdTable[1] = 2;  // NULL 만들지 않으려고. 원래는 해당 파일을 가리키는 포인터가 들어가야함
        	t->stdin_count = 1; // 이 프로세스의 표준 입력 파일이 열려있는지를 확인하는 flag
          t->stdout_count = 1; // 이 프로세스의 표준 출력 파일이 열려있는지를 확인하는 flag
        ...
        }
        ```

    - 수정 코드

        ```c
        tid_t thread_create(const char *name, int priority,
        					thread_func *function, void *aux)
        {
        	struct thread *t;
        	tid_t tid;
        
        	ASSERT(function != NULL);
        
        	t->fdt = palloc_get_multiple(PAL_ZERO, 3); /* 🤔 */
        	if (t->fdt == NULL)
        		return TID_ERROR;
        
        	/* 스레드 생성시 File Descriptor 초기화 */
        	// t->fdt = palloc_get_page(0);
        	// for (int i = 0; i < 128; i++)
        	// {
        	// 	t->fdt[i] = NULL;
        	// }
        	t->next_fd = 2;
        	/* 🤔 */
        	t->fdt[0] = 1; // 의미가 있는 숫자는 아니다. 다만 해당 인덱스(식별자)를 사용하는 파일이 존재하므로 넣어준 것.
        	t->fdt[1] = 2; // NULL 만들지 않으려고. 원래는 해당 파일을 가리키는 포인터가 들어가야함
        
        	init_thread(t, name, priority);
        	tid = t->tid = allocate_tid();
        
        	t->tf.rip = (uintptr_t)kernel_thread;
        	t->tf.R.rdi = (uint64_t)function;
        	t->tf.R.rsi = (uint64_t)aux;
        	t->tf.ds = SEL_KDSEG;
        	t->tf.es = SEL_KDSEG;
        	t->tf.ss = SEL_KDSEG;
        	t->tf.cs = SEL_KCSEG;
        	t->tf.eflags = FLAG_IF;
        
        	/* project2 프로세스 계층 구조 구현  */
        	struct thread *curr = thread_current();
        	// if (curr != NULL)
        	// {
        	// 	t->parent_pd = curr;
        	// 	sema_init(&curr->exit_sema, 0);
        	// 	sema_init(&curr->load_sema, 0);
        	// 	sema_init(&curr->wait_sema, 0);
        	// }
        	list_push_back(&curr->children_list, &t->child_elem);
        
        	/*  94p
        		😡 프로그램이 로드되지 않음
        		😡 프로세스가 종료되지 않음
        		😡자식리스트에 추가		*/
        
        	thread_unblock(t); // t를 ready list에 추가함.
        
        	test_max_priority(); // 준코 여기 비교, yield 다있으니까
        						 // 여기는 5월 2일 준코 반갑다!
        
        	return tid;
        }
        ```

    - 사용 함수

        - palloc_get_multiple()

            <aside> 💡 주석 설명 PAGE_CNT 개의 연속적인 빈 페이지 그룹을 가져와 반환합니다. 만약 PAL_USER가 설정되어 있다면, 페이지들은 사용자 풀에서 얻어집니다. 그렇지 않으면 커널 풀에서 얻어집니다. FLAGS에서 PAL_ZERO가 설정되어 있다면, 페이지들은 0으로 채워집니다. 사용 가능한 페이지가 충분하지 않으면, null 포인터를 반환합니다. 단, FLAGS에서 PAL_ASSERT가 설정되어 있다면, 커널이 패닉 상태에 빠집니다.

            </aside>

            <aside> 💡 gpt의 설명

            이 함수는 **`palloc_get_multiple`**이라는 이름의 페이지 할당 함수입니다. 이 함수는 주어진 **`flags`**와 **`page_cnt`**에 따라 연속된 여러 페이지를 할당합니다.

            함수 인자:

            1. **`flags`**: 페이지 할당에 대한 옵션을 나타내는 열거형(enum)입니다. 가능한 값은 **`PAL_USER`**, **`PAL_ZERO`**, **`PAL_ASSERT`**입니다.
            2. **`page_cnt`**: 연속적으로 할당하려는 페이지 수를 나타냅니다.

            함수 작동 과정:

            1. 사용자 풀 또는 커널 풀 중 어느 풀에서 페이지를 할당할지 결정합니다. **`flags`**에 **`PAL_USER`**가 설정되어 있으면 사용자 풀을 사용하고, 그렇지 않으면 커널 풀을 사용합니다.
            2. 풀의 잠금을 획득합니다.
            3. **`bitmap_scan_and_flip`** 함수를 사용하여 사용 가능한 연속적인 페이지를 찾고, 해당 페이지들을 사용 중으로 표시합니다.
            4. 풀의 잠금을 해제합니다.
            5. 페이지가 성공적으로 할당된 경우, 페이지의 시작 주소를 계산합니다. 그렇지 않으면 **`pages`**를 NULL로 설정합니다.
            6. 페이지가 할당되었는지 확인합니다. 만약 페이지가 할당되었다면, **`flags`**에 **`PAL_ZERO`**가 설정되어 있으면 페이지를 0으로 초기화합니다.
            7. 페이지가 할당되지 않았고, **`flags`**에 **`PAL_ASSERT`**가 설정되어 있다면, 커널 패닉 상태를 발생시킵니다.
            8. 할당된 페이지의 시작 주소를 반환합니다. 페이지가 할당되지 않았다면 NULL을 반환합니다.

            이 함수는 주어진 플래그와 페이지 수를 기반으로 페이지를 할당하고 초기화합니다. 반환 값은 할당된 페이지 블록의 시작 주소입니다.

            </aside>

            ```c
            /* Obtains and returns a group of PAGE_CNT contiguous free pages.
               If PAL_USER is set, the pages are obtained from the user pool,
               otherwise from the kernel pool.  If PAL_ZERO is set in FLAGS,
               then the pages are filled with zeros.  If too few pages are
               available, returns a null pointer, unless PAL_ASSERT is set in
               FLAGS, in which case the kernel panics. */
            void *
            palloc_get_multiple (enum palloc_flags flags, size_t page_cnt) {
            	struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
            
            	lock_acquire (&pool->lock);
            	size_t page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
            	lock_release (&pool->lock);
            	void *pages;
            
            	if (page_idx != BITMAP_ERROR)
            		pages = pool->base + PGSIZE * page_idx;
            	else
            		pages = NULL;
            
            	if (pages) {
            		if (flags & PAL_ZERO)
            			memset (pages, 0, PGSIZE * page_cnt);
            	} else {
            		if (flags & PAL_ASSERT)
            			PANIC ("palloc_get: out of pages");
            	}
            
            	return pages;
            }
            ```

- process_add_file() 구현

    userprog/process.c

    - 구현 코드

        ```c
        int process_add_file(struct file *f)
        {
        	struct thread *curr = thread_current();
        	curr -> fdt[curr->next_fd] = f;
        	curr->next_fd += 1;
        	return curr->next_fd - 1 ;
        }
        ```

    - 참고 코드

        [PintOS Project 2 - User Program (7) System Call(정글사관학교 69일차 TIL) - 파일 디스크립터 관련 system call 구현 (tistory.com)](https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-7-System-Call정글사관학교-69일차-TIL)

        ```c
        @userprog/syscall.c
        
         /* 파일을 현재 프로세스의 fdt에 추가 */
        int add_file_to_fd_table(struct file *file) {
        	struct thread *t = thread_current();
        	struct file **fdt = t->file_descriptor_table;
        	int fd = t->fdidx; //fd값은 2부터 출발
        	
        	while (t->file_descriptor_table[fd] != NULL && fd < FDCOUNT_LIMIT) {
        		fd++;
        	}
        
        	if (fd >= FDCOUNT_LIMIT) {
        		return -1;
        	}
        	t->fdidx = fd;
        	fdt[fd] = file;
        	return fd;
        
        }
        ```

        노션 코드

        ```c
        int add_file_to_fdt(struct file *file){
        	struct thread* cur = thread_current();
        	struct file** fdt = cur->fdTable;  /* 현재 스레드의 파일 테이블 */
        	int fdIdx;  /* 현재 open하는 파일이 받을 새 식별자 */
        
        	ASSERT(file != NULL);
        
        	/* 파일 식별자는 식별자 범위 내에 들어와야 한다(1024). */
        	if (cur->fdIdx >= FDCOUNT_LIMIT)
        		return -1;
        	// 해당 에러가 뜨는 파일은 open
        
        	/* 새 파일 식별자를 인덱스로 하는 fdt와, 해당 파일을 가리키고 있는 포인터와 맵핑. 
        	   파일 식별자를 지정해준 다음엔 그 다음 파일을 위해 파일 식별자를 +1 해준다.*/
        	fdIdx = cur->fdIdx;
        	fdt[fdIdx] = file;
        	cur->fdIdx++;
        
        	return fdIdx;  // 현재 새로 open한 파일의 식별자 리턴
        }
        ---
        다른 버전.
        int add_file_to_fdt(struct file *file)
        {
        	struct thread *cur = thread_current();
        	struct file **fdt = cur->fdTable; /* 현재 스레드의 파일 테이블 */
        	int fdIdx;						  /* 현재 open하는 파일이 받을 새 식별자 */
        
        	ASSERT(file != NULL);
        
        	while (cur->fdIdx < FDCOUNT_LIMIT && fdt[cur->fdIdx]){
        		cur->fdIdx++;
        	}
        
        	/* 파일 식별자는 식별자 범위 내에 들어와야 한다(1024). */
        	if (cur->fdIdx >= FDCOUNT_LIMIT)
        	{
        		return -1;
        	}
        
        	/* 새 파일 식별자를 인덱스로 하는 fdt와, 해당 파일을 가리키고 있는 포인터와 맵핑. 
        	   파일 식별자를 지정해준 다음엔 그 다음 파일을 위해 파일 식별자를 +1 해준다.*/
        	fdt[cur->fdIdx] = file;
        	return cur->fdIdx; // 현재 새로 open한 파일의 식별자 리턴
        }
        ```

    - 수정 코드

        ```c
        int process_add_file(struct file *f)
        {
        	struct thread *curr = thread_current();
        	int findIdx = curr->next_fd; /* 탐색 포인터 */
        	ASSERT(f != NULL);
        
        	while (findIdx < 128 && curr->fdt[findIdx])
        	{
        		findIdx++;
        	}
        	if (findIdx >= 128)
        	{
        		return -1;
        	}
        	curr->next_fd = findIdx;
        	curr->fdt[findIdx]=f;
        	
        	return findIdx;
        }
        ```

- process_get_file() 구현

    - 구현 코드

        ```c
        struct file *process_get_file(int fd)
        {
        	struct thread *curr = thread_current();
        	if(curr -> fdt[fd])
        	{return curr -> fdt[fd];}
        	else{
        		return NULL;
        	} 
        }
        ```

    - 참고 코드

        [PintOS Project 2 - User Program (7) System Call(정글사관학교 69일차 TIL) - 파일 디스크립터 관련 system call 구현 (tistory.com)](https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-7-System-Call정글사관학교-69일차-TIL)

        ```c
        /*  fd 값을 넣으면 해당 file을 반환하는 함수 */
        struct file *fd_to_struct_filep(int fd) {
        	if (fd < 0 || fd >= FDCOUNT_LIMIT) {
        		return NULL;
        	}
        	
        	struct thread *t = thread_current();
        	struct file **fdt = t->file_descriptor_table;
        	
        	struct file *file = fdt[fd];
        	return file;
        }
        ```

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        static struct file *find_file_by_fd(int fd){
        	struct thread* cur = thread_current();
        	
        	/* 이상한 값이 들어오지 않았는지 확인 */
        	if (fd < 0 || fd >= FDCOUNT_LIMIT)
        		return NULL;
        
        	struct file** fdt = cur->fdTable;
        
        	return fdt[fd];
        }
        ```

    - 수정 코드

        ```c
        struct file *process_get_file(int fd)
        {
        	struct thread *curr = thread_current();
        	if (fd < 0 || fd >= 128 || !(curr -> fdt[fd])) {
        		return NULL;
        	}
        	return curr -> fdt[fd];}
        }
        ```

- process_close_file() 구현

    - 구현 코드

        ```c
        void process_close_file(int fd)
        {
        	struct thread *curr = thread_current();
        	// close(curr->fdt[fd]);
        	// curr->fdt[fd] = NULL or 0; 
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        void close_file_from_fdt(int fd){
        	struct thread* cur = thread_current();
        
        	if (fd < 0 || fd >= FDCOUNT_LIMIT)
        		return;
        	
        	cur->fdTable[fd] = NULL;
        }
        ```

    - 수정 코드

        ```c
        void process_close_file(int fd)
        {
        	struct thread *curr = thread_current();
        	if (fd < 0 || fd >= FDCOUNT_LIMIT)
        		return;
        
        	curr->fdt[fd] = NULL;
        }
        ```

- process_exit()

    - 구현 코드

        ```c
        void process_exit(void)
        {
        	struct thread *curr = thread_current();
        	int index = 2;
        	for(int i=2;i<128;i++)
        	{
        		process_close_file(i);
        	}
        	free(curr->fdt);
        	/* close만들고 다시 볼 예정 😡 */
        	
        
        	/* TODO: Your code goes here.
        	 * TODO: Implement process termination message (see
        	 * TODO: project2/process_termination.html).
        	 * TODO: We recommend you to implement process resource cleanup here. */
        
        	process_cleanup();
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        struct thread에 flag사용

        ```c
        void process_exit (void) {
        	struct thread *curr = thread_current ();
        
        	/* 프로세스의 모든 파일들을 닫아주고 fdt의 메모리도 free해준다. */
        	for (int i = 0; i < FDCOUNT_LIMIT; i++)
        		close(i);
        	palloc_free_multiple(curr->fdTable, FDT_PAGES);  // thread_create
        	
        	/* load()에서 초기화한 현재 실행되고 있는 프로세스 실행 파일도 닫아준다. */
        	file_close(curr->running);
        
        	/* 현재 프로세스의 페이지 디렉토리(pml4)을 없앤다. */
        	process_cleanup ();
        
        	/* 현재 프로세스가 종료되었으므로, 자신의 종료를 wait()하는 부모를 위해
        	   부모가 대기하고 있는 sema의 value를 UP해준다. */
        	sema_up(&curr->wait_sema);
        
        	/* 그리고 완전히 종료되기 전 자신의 free_sema에서 BLOCK되면서 좀비 프로세스로 남는다.
        	   그래야 부모 프로세스가 안전하게 자신의 전달값을 받을 수 있다.
        	   전달값에는 자신의 exit_status와 child_process_list(부모가 여기서 자신을 빼야 함)이 있다.
        	   부모가 sema UP해줄 때까지 기다린다. */
        	sema_down(&curr->free_sema);
        }
        ```

    - 수정 코드

        ```c
        void process_exit(void)
        {
        	struct thread *curr = thread_current();
        	for (int i = 0; i < 128; i++)
        	{
        		process_close_file(i);
        	}
        	palloc_free_multiple(curr->fdt, 3);
        	/* 🤔 */
        	file_close(curr->running);
        	process_cleanup();
        	sema_up(&curr->wait_sema);
        	sema_down(&curr->free_sema);
        	/* close만들고 다시 볼 예정 😡 */
        
        	/* TODO: Your code goes here.
        	 * TODO: Implement process termination message (see
        	 * TODO: project2/process_termination.html).
        	 * TODO: We recommend you to implement process resource cleanup here. */
        
        	process_cleanup();
        }
        ```

- userprog/exception.c/page_fault() 수정

    - 구현 코드

        ```c
        static void
        page_fault (struct intr_frame *f) {
        	bool not_present;  /* True: not-present page, false: writing r/o page. */
        	bool write;        /* True: access was write, false: access was read. */
        	bool user;         /* True: access by user, false: access by kernel. */
        	void *fault_addr;  /* Fault address. */
        
        	/* Obtain faulting address, the virtual address that was
        	   accessed to cause the fault.  It may point to code or to
        	   data.  It is not necessarily the address of the instruction
        	   that caused the fault (that's f->rip). */
        
        	fault_addr = (void *) rcr2();
        
        	/* Turn interrupts back on (they were only off so that we could
        	   be assured of reading CR2 before it changed). */
        	intr_enable ();
        
        	/* Determine cause. */
        	not_present = (f->error_code & PF_P) == 0;
        	write = (f->error_code & PF_W) != 0;
        	user = (f->error_code & PF_U) != 0;
        	if(!not_present || !write || !user)
        	{
        		exit(-1);
        	}
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        
        ```

    - 수정 코드

        ```c
        page_fault(struct intr_frame *f)
        {
        	bool not_present; /* True: not-present page, false: writing r/o page. */
        	bool write;		  /* True: access was write, false: access was read. */
        	bool user;		  /* True: access by user, false: access by kernel. */
        	void *fault_addr; /* Fault address. */
        
        	/* Obtain faulting address, the virtual address that was
        	   accessed to cause the fault.  It may point to code or to
        	   data.  It is not necessarily the address of the instruction
        	   that caused the fault (that's f->rip). */
        
        	fault_addr = (void *)rcr2();
        
        	/* Turn interrupts back on (they were only off so that we could
        	   be assured of reading CR2 before it changed). */
        	intr_enable();
        
        	/* Determine cause. */
        	not_present = (f->error_code & PF_P) == 0;
        	write = (f->error_code & PF_W) != 0;
        	user = (f->error_code & PF_U) != 0;
        	// if(!not_present || !write || !user)
        	// {
        	// 	exit(-1);
        	// }
        
        #ifdef VM
        	/* For project 3 and later. */
        	if (vm_try_handle_fault(f, fault_addr, user, write, not_present))
        		return;
        #endif
        
        	/* Count page faults. */
        	page_fault_cnt++;
        
        	/* If the fault is true fault, show info and exit. */
        	printf("Page fault at %p: %s error %s page in %s context.\\n",
        		   fault_addr,
        		   not_present ? "not present" : "rights violation",
        		   write ? "writing" : "reading",
        		   user ? "user" : "kernel");
        	// kill (f);
        	exit(-1); /* 🤔 */
        ```

## 작성해야되는 system call함수 (월,화,수,목 요일)

userprog/syscall.c

- void halt (void)

    - 구현 lib/user/syscall.c

        ```c
        void halt (void) {
        	syscall0 (SYS_HALT);
        	NOT_REACHED ();
        
        	power_off();
        }
        ```

    - 참고

        ```c
        /* pintos 종료시키는 함수 */
        void halt(void){
        	power_off();
        }
        ```

    - 수정

        ```c
        /* pintos 종료시키는 함수 */
        void halt(void){
        	power_off();
        }
        ```

    - 관련 함수

        qemu 에뮬레이터를 종료시킴으로써 시스템을 종료

        ```c
        void power_off (void) {
        //#ifdef FILESYS
        //	filesys_done ();
        //#endif
        
        	print_stats (); // 현재 시스템의 타이머, 스레드당 tick 수 등을 현재 시스템 정보들을 출력한다.
        
        	printf ("Powering off...\\n");
        	outw (0x604, 0x2000);               /* Poweroff command for qemu */
        	for (;;);
        }
        
        ----
        # io.h/outw()
        
        /* Writes the 16-bit DATA to PORT. */
        static inline void outw (uint16_t port, uint16_t data) {
        	/* See [IA32-v2b] "OUT". */
        	asm volatile ("outw %0,%w1" : : "a" (data), "d" (port));
        }
        ```

- void exit (int status)

    - 구현코드

        lib/user/syscall.c

        ```c
        void
        exit (int status) {
        	syscall1 (SYS_EXIT, status);
        	NOT_REACHED ();
        
        	printf("%c :exit(%d)", thread_name(), status);
        	thread_exit();
        }
        ```

    - 참고 코드

        ```c
        void exit (int status){  // 종료 status를 입력받는다. exit(0)이면 성공, 아님 실패
        	struct thread* cur = thread_current();
        	cur->exit_status = status;
        	printf("%s: exit(%d)\\n", cur->name, status);
        	thread_exit();  // 스레드가 죽는다.
        }
        ```

    - 수정 코드

        ```c
        void exit (int status){  // 종료 status를 입력받는다. exit(0)이면 성공, 아님 실패
        	struct thread* cur = thread_current();
        
        	cur->exit_status = status;
        	printf("%s: exit(%d)\\n", cur->name, status);
        	thread_exit();  // 스레드가 죽는다.
        }
        ```

- pid_t fork (const char *thread_name);

    - 구현 코드

        ```c
        pid_t fork(const char *thread_name)
        {
        	struct thread *curr = thread_current();
        
        	return process_fork(thread_name, &curr->tf);
        }
        ```

    - 수정 코드

        ```c
        tid_t fork (const char *thread_name, struct intr_frame *f) {
            // check_address(thread_name);
            return process_fork(thread_name, f);
        }
        ```

- int exec (const char *cmd_line);

    - 구현 코드

        ```c
        int exec(const *cmd_line)
        {
        	struct thread *curr = thread_current();
        	tid_t pid = process_create_initd(cmd_line);	   // cmd_line parsing해서 file_name 추출해서 넣음.
        												   /* sema_down 옛터  */
        	struct thread *child = get_child_process(pid); // 생성된 자식 프로세스의 디스크립터 검색 미구현 😡
        	int result = process_wait(child);			   // 자식 프로세스의 프로그램 적재 대기😡
        	list_push_back(&curr->children_list, &child->child_elem);
        
        	if (result = 1) // 적재 성공시
        	{
        		return pid;
        	}
        	else
        	{ // 적재 실패시
        		return -1;
        	}
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        int exec(const char *cmd_line)
        {
        	check_address(cmd_line);
        
        	/* 인자로 받은 파일 이름 문자열을 복사하여 이 복사본을 인자로 process_exec() 실행*/
        	int size = strlen(cmd_line) + 1;
        	char *fn_copy = palloc_get_page(PAL_ZERO);
        	if(fn_copy == NULL)
        		exit(-1);
        	strlcpy(fn_copy, cmd_line, size);
        
        	if(process_exec(fn_copy) == -1)
        		return -1;
        	
        	/* Caller 프로세스는 do_iret() 후 돌아오지 못한다. */
        	NOT_REACHED();
        
        	return 0;  //이 값은 리턴되지 않는다. 즉, exec()은 오직 에러가 발생했을 때만 리턴한다.
        }
        ```

    - 수정

        ```c
        int exec(const char *cmd_line)
        {
        	check_address(cmd_line);
        
        	/* 인자로 받은 파일 이름 문자열을 복사하여 이 복사본을 인자로 process_exec() 실행*/
        	int size = strlen(cmd_line) + 1;
        	char *fn_copy = palloc_get_page(0);
        	if (fn_copy == NULL)
        		exit(-1);
        	strlcpy(fn_copy, cmd_line, size);
        
        	if (process_exec(fn_copy) == -1) /* process_exec에서 free해줌 */
        		return -1;
        
        	/* Caller 프로세스는 do_iret() 후 돌아오지 못한다. */
        	NOT_REACHED();
        
        	return 0; // 이 값은 리턴되지 않는다. 즉, exec()은 오직 에러가 발생했을 때만 리턴한다.
        }
        ```

- int wait (tid_t pid);

    userprog/syscall/c

    - 구현 코드

        ```c
        구현 깜박함 😜
        ```

    - 참고 코드

        ```c
        int wait(pid_t pid)
        {
        	return process_wait(pid);
        }
        ```

    - 수정 코드

        ```c
        int wait(pid_t pid)
        {
        	return process_wait(pid);
        }
        ```

- bool create (const char *file, unsigned initial_size)

    - 구현 lib/user/syscall.c

        ```c
        bool
        create (const char *file, unsigned initial_size) {
        
        	syscall2(SYS_CREATE, file, initial_size);
        
        	bool success = filesys_create(file, initial_size);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	save_regi = success;
        	return success;
        }
        ```

    - 참고

        ```c
        bool create (const char *file , unsigned initial_size){
        	check_address(file);
        	return filesys_create(file, initial_size);
        }
        ```

    - 구현코드 2

        ```c
        bool create (const char *file , unsigned initial_size){
        	check_address(file);
        	return filesys_create(file, initial_size);
        }
        ```

    - 수정 코드

        ```c
        bool create (const char *file, unsigned initial_size) {
            check_address(file);
            if (filesys_create(file, initial_size)) {
                return true;
            } else {
                return false;
            }
            /*return filesys_create(file, initial_size);*/
        }
        ```

- bool remove (const char *file)

    - 구현 lib/user/syscall.c

        ```c
        bool
        remove (const char *file) {
        	syscall1 (SYS_REMOVE, file);
        	filesys_remove(file);
        	bool success = filesys_remove(file);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	save_regi = success;
        	return success;
        }
        ```

    - 참고

        ```c
        bool remove (const char *file){
        	check_address(file);
        	return filesys_remove(file);
        }
        ```

    - 수정

        ```c
        bool remove (const char *file){
        	check_address(file);
        	return filesys_remove(file);
        }
        ```

- int open (const char *file);

    - 구현 코드

        ```c
        int
        open (const char *file) {
        	syscall1 (SYS_OPEN, file);
        	struct file *fd = filesys_open(file);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	if(fd){
        		save_regi = fd;
        		return fd;
        	}
        	else{
        		save_regi = -1;
        		return -1;
        	}
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        int open(const char *file)
        {
        	check_address(file);
        	struct file *fileobj = filesys_open(file); // 해당 이름을 가진 파일을 찾아서 연다.
        
        	if (fileobj == NULL) // 실패하면 NULL을 리턴한다.
        		return -1;
        
        	int fd = add_file_to_fdt(fileobj); // 해당 파일을 가리키는 포인터를 fdt에 넣어주고 식별자 리턴
        
        	if (fd == -1)  // 식별자 숫자 범위를 초과하면 해당 파일을 닫아준다.
        		file_close(fileobj);
        
        	return fd;
        }
        ```

    - 구현 코드 2

        ```c
        int open(const char *file)
        {
        	struct file *fileobj = filesys_open(file);
        	if (fileobj == NULL)
        	{
        		return -1;
        	}
        	int fd = process_add_file(fileobj); // 해당 파일을 가리키는 포인터를 fdt에 넣어주고 식별자 리턴
        
        	// struct thread *curr = thread_current();
        	// curr->fdt[curr->next_fd] = file;
        
        	if (fd == -1)
        	{
        		file_close(fileobj);
        	}
        	return fd;
        }
        ```

    - 수정코드

        ```c
        int open(const char *file)
        {
        	check_address(file);
        	lock_acquire(&filesys_lock);
        	struct file *fileobj = filesys_open(file);
        	if (fileobj == NULL)
        	{
        		return -1;
        	}
        	int fd = process_add_file(fileobj); // 해당 파일을 가리키는 포인터를 fdt에 넣어주고 식별자 리턴
        
        	// struct thread *curr = thread_current();
        	// curr->fdt[curr->next_fd] = file;
        
        	if (fd == -1)
        	{
        		file_close(fileobj);
        	}
        	lock_release(&filesys_lock);
        	return fd;
        }
        ```

- int filesize (int fd)

    - 구현 lib/user/syscall.c

        ```c
        int
        filesize (int fd) {
        	syscall1 (SYS_FILESIZE, fd);
        	off_t size = file_length(fd);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	save_regi = size;
        	return size;
        }
        ```

    - 참고

        ```c
        int filesize (int fd)
        {
        	struct file* fileobj = find_file_from_fd(fd);
        
        	if (fileobj == NULL)
        		return -1;
        	
        	return file_length(fileobj);
        }
        ```

    - 수정

        ```c
        int filesize (int fd)
        {
        	struct file* fileobj = find_file_from_fd(fd);
        
        	if (fileobj == NULL)
        		return -1;
        	
        	return file_length(fileobj);
        }
        ```

    - 필요 함수

        **filesys/file.c/file_length()**

        ```c
        /* Returns the size of FILE in bytes. */
        off_t file_length (struct file *file) {
        	ASSERT (file != NULL);
        	return inode_length (file->inode);
        }
        ```

        **filesys/inode.c/inode_length()**

        ```c
        /* Returns the length, in bytes, of INODE's data. */
        off_t inode_length (const struct inode *inode) {
        	return inode->data.length;
        }
        ```

- int write (int fd, const void *buffer, unsigned size)

    - 구현 코드

        ```c
        int write(int fd, void *buffer, unsigned size)
        {
        	lock_acquire(&filesys_lock);
        	if(fd==1)
        	{
        		putbuf(buffer, size);
        		return sizeof(buffer); 
        	}
        	else
        	{
        		file_write(process_get_file(fd), buffer, size);
        		return size; //size? filesize? 😡
        	}
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        int write(int fd, const void *buffer, unsigned size){
        	check_address(buffer);
        	int write_count;
        	struct thread *cur = thread_current();
        
        	struct file* fileobj = find_file_by_fd(fd);
        	if (fileobj == NULL)
        		return -1;
        	
        	if (fileobj == STDOUT){
        		if (cur->stdout_count == 0){ /* 얘도 없어도 돌아가긴 한다.*/
        			NOT_REACHED();
        			remove_file_from_fdt(fd);
        			write_count = -1;
        		}
        		else{
        			/* buffer에 있는 데이터를 size byte 만큼 console에 보내 출력하게 한다.
        			출력 중에는 console을 획득한 프로세스만이 console에 쓸 수 있다. */
        			putbuf(buffer, size);
        			write_count = size;
        		}
        	}
        	else if(fileobj == STDIN){
        		write_count = -1;
        	}
        	else{
        		/* 현재 프로세스가 해당 파일에 데이터를 쓰는 동안
        		   다른 프로세스가 그 파일을 쓰면 안 되므로. */
        		lock_acquire(&filesys_lock);
        		write_count = file_write(fileobj, buffer, size);
        		lock_release(&filesys_lock);
        	}
        
        	return write_count;  // 출력한 데이터의 byte를 반환한다.
        }
        ```

    - 수정 코드

        ```c
        int write(int fd, const void *buffer, unsigned size)
        {
        	check_address(buffer);
        	int write_count;
        	struct thread *cur = thread_current();
        
        	struct file *fileobj = process_get_file(fd);
        	if (fileobj == NULL)
        		return -1;
        
        	if (fileobj == STDOUT)
        	{
        		if (cur->stdout_count == 0)
        		{ /* 얘도 없어도 돌아가긴 한다.*/
        			NOT_REACHED();
        			process_close_file(fd);
        			write_count = -1;
        		}
        		else
        		{
        			/* buffer에 있는 데이터를 size byte 만큼 console에 보내 출력하게 한다.
        			출력 중에는 console을 획득한 프로세스만이 console에 쓸 수 있다. */
        			putbuf(buffer, size);
        			write_count = size;
        		}
        	}
        	else if (fileobj == STDIN)
        	{
        		write_count = -1;
        	}
        	else
        	{
        		/* 현재 프로세스가 해당 파일에 데이터를 쓰는 동안
        		   다른 프로세스가 그 파일을 쓰면 안 되므로. */
        		lock_acquire(&filesys_lock);
        		write_count = file_write(fileobj, buffer, size);
        		lock_release(&filesys_lock);
        	}
        
        	return write_count; // 출력한 데이터의 byte를 반환한다.
        }
        ```

- int read(int fd, void *buffer, unsigned size)

    - 구현코드

        ```c
        /* 이건 다시 생각해봐야 할 것 같아... 힌트) 표준 입력 */
        int read(int fd, void *buffer, unsigned size)
        {
        	lock_acquire(&filesys_lock);
        	if (fd)
        	{
        		if (!file_read(process_get_file(fd), buffer, size))
        		{
        			return -1;
        		}
        		return file_read(process_get_file(fd), buffer, size);
        	}
        	else
        	{
        		buffer = input_getc();
        		return sizeof(buffer);
        	}
        }
        ```

    - 참고코드

        ```c
        int read(int fd, void *buffer, unsigned size) {
        	// 유효한 주소인지부터 체크
        	check_address(buffer); // 버퍼 시작 주소 체크
        	check_address(buffer + size -1); // 버퍼 끝 주소도 유저 영역 내에 있는지 체크
        	unsigned char *buf = buffer;
        	int read_count;
        	
        	struct file *fileobj = fd_to_struct_filep(fd);
        
        	if (fileobj == NULL) {
        		return -1;
        	}
        
        	/* STDIN일 때: */
        	if (fd == STDIN_FILENO) {
        		char key;
        		for (int read_count = 0; read_count < size; read_count++) {
        			key  = input_getc();
        			*buf++ = key;
        			if (key == '\\0') { // 엔터값
        				break;
        			}
        		}
        	}
        	/* STDOUT일 때: -1 반환 */
        	else if (fd == STDOUT_FILENO){
        		return -1;
        	}
        
        	else {
        		lock_acquire(&filesys_lock);
        		read_count = file_read(fileobj, buffer, size); // 파일 읽어들일 동안만 lock 걸어준다.
        		lock_release(&filesys_lock);
        
        	}
        	return read_count;
        }
        ```

    - 수정코드

        ```c
        int read(int fd, void *buffer, unsigned size)
        {
        	// 유효한 주소인지부터 체크
        	check_address(buffer);			  // 버퍼 시작 주소 체크
        	check_address(buffer + size - 1); // 버퍼 끝 주소도 유저 영역 내에 있는지 체크
        	unsigned char *buf = buffer;
        	int read_count;
        	struct thread *cur = thread_current();
        	struct file *fileobj = cur->fdt[fd];
        
        	if (fileobj == NULL)
        	{
        		return -1;
        	}
        
        	/* STDIN일 때: */
        	if (fd == 0)
        	{
        		char key;
        		for (int read_count = 0; read_count < size; read_count++)
        		{
        			key = input_getc();
        			*buf++ = key;
        			if (key == '\\0')
        			{ // 엔터값
        				break;
        			}
        		}
        	}
        	/* STDOUT일 때: -1 반환 */
        	else if (fd == 1)
        	{
        		return -1;
        	}
        
        	else
        	{
        		lock_acquire(&filesys_lock);
        		read_count = file_read(fileobj, buffer, size); // 파일 읽어들일 동안만 lock 걸어준다.
        		lock_release(&filesys_lock);
        	}
        	return read_count;
        }
        ```

- void seek (int fd, unsigned position)

    - 구현 코드

        ```c
        void seek(int fd, unsigned position)
        {
        	file_seek(process_get_file(fd), position);
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        void seek(int fd, unsigned position){
        	struct file *fileobj = find_file_by_fd(fd);
        	
        	/* file이 fdt에 없거나 해당 파일이 표준 입출력 파일인 경우. */
        	if(fileobj == NULL || fileobj <= 2)
        		return;
        	
        	fileobj->pos = position;
        } 
        ```

    - 수정 코드

        ```c
        void seek(int fd, unsigned position)
        {
        	struct file *fileobj = process_get_file(fd);
        	if (fileobj == NULL || fileobj < 2)
        		return;
        
        	file_seek(fileobj, position);
        }
        ```

- unsigned tell (int fd)

    - 구현 코드

        ```c
        unsigned tell(int fd)
        {
        	file_tell(process_get_file(fd));
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        unsigned tell (int fd){
        	struct file* fileobj = find_file_by_fd(fd);
        
        	if (fileobj == NULL || fileobj <= 2)
        		return -1;
        	return file_tell(fileobj);
        }
        ```

    - 수정 코드

        ```c
        unsigned tell(int fd)
        {
        	struct file *fileobj = process_get_file(fd);
        
        	if (fileobj == NULL || fileobj <= 2) /* 조건 빠짐 */
        		return -1;
        
        	return file_tell(fileobj);
        }
        ```

- void close (int fd)

    - 구현 코드

        ```c
        void close(int fd)
        {
        	file_close(process_get_file(fd));
        }
        ```

    - 참고 코드

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        void close (int fd){
        	struct thread* cur = thread_current();
        	struct file* fileobj = find_file_by_fd(fd);
        
        	if (fileobj == STDIN){  // 1
        		cur->stdin_count--;
        	}
        	if (fileobj == STDOUT) { // 2
        		cur->stdout_count--;
        	}
        
        	remove_file_from_fdt(fd);
        }
        ```

    - 수정

        ```c
        void close(int fd)
        {
        	struct thread *cur = thread_current();
        	struct file *fileobj = process_get_file(fd);
        
        	if (fileobj == STDIN)
        	{
        		cur->stdin_count--;
        	}
        	if (fileobj == STDOUT)
        	{
        		cur->stdout_count--;
        	}
        
        	process_close_file(fd);
        }
        ```

## 디버깅 (금요일)

```c
root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog# make check
cd build && make check
make[1]: Entering directory '/root/pintos-kaist/userprog/build'
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-none:args-none -- -q   -f run args-none < /dev/null 2> tests/userprog/args-none.errors > tests/userprog/args-none.output
perl -I../.. ../../tests/userprog/args-none.ck tests/userprog/args-none tests/userprog/args-none.result
FAIL tests/userprog/args-none
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-single:args-single -- -q   -f run 'args-single onearg' < /dev/null 2> tests/userprog/args-single.errors > tests/userprog/args-single.output
perl -I../.. ../../tests/userprog/args-single.ck tests/userprog/args-single tests/userprog/args-single.result
FAIL tests/userprog/args-single
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-multiple:args-multiple -- -q   -f run 'args-multiple some arguments for you!' < /dev/null 2> tests/userprog/args-multiple.errors > tests/userprog/args-multiple.output
perl -I../.. ../../tests/userprog/args-multiple.ck tests/userprog/args-multiple tests/userprog/args-multiple.result
FAIL tests/userprog/args-multiple
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-many:args-many -- -q   -f run 'args-many a b c d e f g h i j k l m n o p q r s t u v' < /dev/null 2> tests/userprog/args-many.errors > tests/userprog/args-many.output
perl -I../.. ../../tests/userprog/args-many.ck tests/userprog/args-many tests/userprog/args-many.result
FAIL tests/userprog/args-many
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-dbl-space:args-dbl-space -- -q   -f run 'args-dbl-space two  spaces!' < /dev/null 2> tests/userprog/args-dbl-space.errors > tests/userprog/args-dbl-space.output
perl -I../.. ../../tests/userprog/args-dbl-space.ck tests/userprog/args-dbl-space tests/userprog/args-dbl-space.result
FAIL tests/userprog/args-dbl-space
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/halt:halt -- -q   -f run halt < /dev/null 2> tests/userprog/halt.errors > tests/userprog/halt.output
^Cmake[1]: *** Deleting file 'tests/userprog/halt.output'
../../tests/Make.tests:75: recipe for target 'tests/userprog/halt.output' failed
make[1]: *** [tests/userprog/halt.output] Interrupt
../Makefile.kernel:10: recipe for target 'check' failed
make: *** [check] Interrupt

root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog# cd build
root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog/build# pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-single:args-single -- -q   -f run 'args-single onearg'
qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]
Kernel command line: -q -f put args-single run 'args-single onearg'
0 ~ 9fc00 1
100000 ~ 13e0000 1
Pintos booting with: 
        base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
        ext_mem: 0x100000 ~ 0x13e0000 (Usable: 19,328 kB)
Calibrating timer...  117,760,000 loops/s.
hd0:0: detected 321 sector (160 kB) disk, model "QEMU HARDDISK", serial "QM00001"
hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
hd1:0: detected 102 sector (51 kB) disk, model "QEMU HARDDISK", serial "QM00003"
Formatting file system...done.
Boot complete.
Putting 'args-single' into the file system...
Executing 'args-single onearg':
Page fault at 0x188: not present error reading page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog/build#
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-none:args-none -- -q   -f run args-none
```

- 얹어본 함수들

    process.c

    void argument_stack(char **parse, int count, struct intr_frame *_if)

    tid_t process_create_initd (const char *file_name) {

    tid_t process_fork(const char *name, struct intr_frame *if_ UNUSED)→ 원래 똑같음 ㅎ

    int process_exec (void *f_name) {

    struct thread *get_child_process(int pid)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ffc29a8-78e8-43ee-8528-b04c314abffb/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aadb0fec-adb5-4be0-b277-d1f03f1ef796/Untitled.png)

# **Process Termination Message 프로세스 종료 메세지**

<aside> 💡 해야할 일:  `exit` 함수를 호출 했거나 다른 어떤 이유들로 유저 프로세스가 종료될 때 마다  프로세스의 이름과 exit 코드를 출력합니다. 마치 아래 printf 문을 통해 출력된 것과 같은 형식으로 말이죠.

</aside>

- 구현 코드

    userprog/syscall.c

    ```c
    void exit(int status)
    { // 종료 status를 입력받는다. exit(0)이면 성공, 아님 실패
    	struct thread *cur = thread_current();
    	cur->exit_status = status;
    	printf("%s: exit(%d)\\n", thread_name(), status);
    	thread_exit(); // 스레드가 죽는다.
    }
    ```

# **Deny Write on Executables 실행 파일에 쓰기 거부**

- 해야할 일

    <aside> 💡 실행중인 파일, 즉 실행 파일에 쓰기를 거부하는 코드를 작성하세요.

    </aside>

    <aside> 💡 열려있는 파일에 쓰기를 방지하려면 `file_deny_write()`  함수를 사용하면 됩니다.

    그리고 `file_allow_write()`를 파일 안에서 호출하면 다시 쓰기가 가능해지도록 만들 수 있습니다 (이 파일을 여는 또다른 무언가에 의해 쓰기가 거부되지만 않는다면).

    그리고 파일을 닫아도 다시 쓰기가 가능해지게 됩니다. 그러므로, 프로세스의 실행 파일에 쓰기를 계속 거부하려면, 프로세스가 돌아가는 동안에는 실행 파일이 쭉 열려 있게끔 해야 합니다.

    </aside>

- 관련 함수

    - file_deny_write ()

        filesys/file.c

        ```c
        /* Prevents write operations on FILE's underlying inode
         * until file_allow_write() is called or FILE is closed. */
        void
        file_deny_write (struct file *file) {
        	ASSERT (file != NULL);
        	if (!file->deny_write) {
        		file->deny_write = true;
        		inode_deny_write (file->inode);
        	}
        }
        ```

    - file_allow_write ()

        filesys/file.c

        ```c
        /* Re-enables write operations on FILE's underlying inode.
         * (Writes might still be denied by some other file that has the
         * same inode open.) */
        void
        file_allow_write (struct file *file) {
        	ASSERT (file != NULL);
        	if (file->deny_write) {
        		file->deny_write = false;
        		inode_allow_write (file->inode);
        	}
        }
        ```

- 구현 코드

    - thread 구조체 추가

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion 관련 element 추가 */
        	int init_priority;				// donation이후 우선순위를 초기화하기 위해 초기값 저장
        	struct lock *wait_on_lock;		// 해당 스레드가 대기하고 있는 lock자료구조 주소 저장
        	struct list donations;			// multiple donation 을 고려하기 위해사용
        	struct list_elem donation_elem; // multiple donation 을 고려하기 위해사용
        	/*----------------[project1]-------------------*/
        
        	/*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // 부모 프로세스의 디스크립터
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        
        	struct file **fdt;
        	int next_fd;
        	/* 🤔 */
        	struct file *running; // 현재 스레드가 사용 중인 파일(load하고 있는 파일)
        	int stdin_count;
        	int stdout_count;
        	/*----------------[project2]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        };
        ```

    - init_thread() 추가

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        
        	sema_init(&t->wait_sema, 0);
        	sema_init(&t->fork_sema, 0);
        	sema_init(&t->free_sema, 0);
        	t->running = NULL;
        	t->exit_status = 0;
        	/*---------------[준코]------------------------*/
        }
        ```

    - process_exit() 수정

        ```c
        /* Exit the process. This function is called by thread_exit (). */
        void process_exit(void)
        {
            struct thread *curr = thread_current();
            for (int i = 0; i < FDCOUNT_LIMIT; i++)
            {
                close(i);
            }
            palloc_free_multiple(curr->fdt, FDT_PAGES);
            /* 🤔 */
            file_close(curr->running);
        
            sema_up(&curr->wait_sema);
            sema_down(&curr->free_sema);
        
            process_cleanup();
        
            /* TODO: Your code goes here.
             * TODO: Implement process termination message (see
             * TODO: project2/process_termination.html).
             * TODO: We recommend you to implement process resource cleanup here. */
        }
        ```

    - load() 수정

        ```c
        static bool
        load(const char *file_name, struct intr_frame *if_)
        {
            struct thread *t = thread_current();
            struct ELF ehdr;
            struct file *file = NULL;
            off_t file_ofs;
            bool success = false;
            int i;
        
            /* Allocate and activate page directory. */
            t->pml4 = pml4_create();
            if (t->pml4 == NULL)
                goto done;
            process_activate(thread_current());
        
            /* Open executable file. */
            file = filesys_open(file_name);
            if (file == NULL)
            {
                printf("load: %s: open failed\\n", file_name);
                goto done;
            }
        
            /* 실행 중인 스레드 t의 running을 실행할 파일로 초기화*/
            t->running = file;
        
            /* 현재 오픈한 파일에 다른내용 쓰지 못하게 함 */
            file_deny_write(file);
        
            /* Read and verify executable header. */
            if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr || memcmp(ehdr.e_ident, "\\177ELF\\2\\1\\1", 7) || ehdr.e_type != 2 || ehdr.e_machine != 0x3E // amd64
                || ehdr.e_version != 1 || ehdr.e_phentsize != sizeof(struct Phdr) || ehdr.e_phnum > 1024)
            {
                printf("load: %s: error loading executable\\n", file_name);
                goto done;
            }
        
            /* Read program headers. */
            file_ofs = ehdr.e_phoff;
            for (i = 0; i < ehdr.e_phnum; i++)
            {
                struct Phdr phdr;
        
                if (file_ofs < 0 || file_ofs > file_length(file))
                    goto done;
                file_seek(file, file_ofs);
        
                if (file_read(file, &phdr, sizeof phdr) != sizeof phdr)
                    goto done;
                file_ofs += sizeof phdr;
                switch (phdr.p_type)
                {
                case PT_NULL:
                case PT_NOTE:
                case PT_PHDR:
                case PT_STACK:
                default:
                    /* Ignore this segment. */
                    break;
                case PT_DYNAMIC:
                case PT_INTERP:
                case PT_SHLIB:
                    goto done;
                case PT_LOAD:
                    if (validate_segment(&phdr, file))
                    {
                        bool writable = (phdr.p_flags & PF_W) != 0;
                        uint64_t file_page = phdr.p_offset & ~PGMASK;
                        uint64_t mem_page = phdr.p_vaddr & ~PGMASK;
                        uint64_t page_offset = phdr.p_vaddr & PGMASK;
                        uint32_t read_bytes, zero_bytes;
                        if (phdr.p_filesz > 0)
                        {
                            /* Normal segment.
                             * Read initial part from disk and zero the rest. */
                            read_bytes = page_offset + phdr.p_filesz;
                            zero_bytes = (ROUND_UP(page_offset + phdr.p_memsz, PGSIZE) - read_bytes);
                        }
                        else
                        {
                            /* Entirely zero.
                             * Don't read anything from disk. */
                            read_bytes = 0;
                            zero_bytes = ROUND_UP(page_offset + phdr.p_memsz, PGSIZE);
                        }
                        if (!load_segment(file, file_page, (void *)mem_page,
                                          read_bytes, zero_bytes, writable))
                            goto done;
                    }
                    else
                        goto done;
                    break;
                }
            }
        
            /* Set up stack. */
            if (!setup_stack(if_))
                goto done;
        
            /* Start address. */
            if_->rip = ehdr.e_entry;
        
            /* TODO: Your code goes here.
             * TODO: Implement argument passing (see project2/argument_passing.html). */
        
            success = true;
        
        done:
            /* We arrive here whether the load is successful or not. */
            // file_close(file);
            return success;
        }
        ```

- 추가 수정

    - 현재까지 구현 결과

        ```c
        pass tests/threads/priority-donate-chain
        pass tests/userprog/args-none
        pass tests/userprog/args-single
        pass tests/userprog/args-multiple
        pass tests/userprog/args-many
        pass tests/userprog/args-dbl-space
        pass tests/userprog/halt
        pass tests/userprog/exit
        pass tests/userprog/create-normal
        pass tests/userprog/create-empty
        pass tests/userprog/create-null
        pass tests/userprog/create-bad-ptr
        pass tests/userprog/create-long
        pass tests/userprog/create-exists
        pass tests/userprog/create-bound
        pass tests/userprog/open-normal
        pass tests/userprog/open-missing
        pass tests/userprog/open-boundary
        pass tests/userprog/open-empty
        pass tests/userprog/open-null
        pass tests/userprog/open-bad-ptr
        pass tests/userprog/open-twice
        pass tests/userprog/close-normal
        pass tests/userprog/close-twice
        pass tests/userprog/close-bad-fd
        pass tests/userprog/read-normal
        pass tests/userprog/read-bad-ptr
        pass tests/userprog/read-boundary
        pass tests/userprog/read-zero
        pass tests/userprog/read-stdout
        pass tests/userprog/read-bad-fd
        pass tests/userprog/write-normal
        pass tests/userprog/write-bad-ptr
        pass tests/userprog/write-boundary
        pass tests/userprog/write-zero
        pass tests/userprog/write-stdin
        pass tests/userprog/write-bad-fd
        pass tests/userprog/fork-once
        pass tests/userprog/fork-multiple
        pass tests/userprog/fork-recursive
        pass tests/userprog/fork-read
        pass tests/userprog/fork-close
        pass tests/userprog/fork-boundary
        pass tests/userprog/exec-once
        pass tests/userprog/exec-arg
        pass tests/userprog/exec-boundary
        pass tests/userprog/exec-missing
        pass tests/userprog/exec-bad-ptr
        pass tests/userprog/exec-read
        pass tests/userprog/wait-simple
        pass tests/userprog/wait-twice
        pass tests/userprog/wait-killed
        pass tests/userprog/wait-bad-pid
        pass tests/userprog/multi-recurse
        pass tests/userprog/multi-child-fd
        pass tests/userprog/rox-simple
        pass tests/userprog/rox-child
        pass tests/userprog/rox-multichild
        pass tests/userprog/bad-read
        pass tests/userprog/bad-write
        pass tests/userprog/bad-read2
        pass tests/userprog/bad-write2
        pass tests/userprog/bad-jump
        pass tests/userprog/bad-jump2
        pass tests/filesys/base/lg-create
        pass tests/filesys/base/lg-full
        pass tests/filesys/base/lg-random
        pass tests/filesys/base/lg-seq-block
        pass tests/filesys/base/lg-seq-random
        pass tests/filesys/base/sm-create
        pass tests/filesys/base/sm-full
        pass tests/filesys/base/sm-random
        pass tests/filesys/base/sm-seq-block
        pass tests/filesys/base/sm-seq-random
        pass tests/filesys/base/syn-read   (됐다 안됐다 함ㅎ)
        pass tests/filesys/base/syn-remove
        FAIL tests/filesys/base/syn-write
        FAIL tests/userprog/no-vm/multi-oom
        pass tests/threads/alarm-single
        pass tests/threads/alarm-multiple
        pass tests/threads/alarm-simultaneous
        pass tests/threads/alarm-priority
        pass tests/threads/alarm-zero
        pass tests/threads/alarm-negative
        pass tests/threads/priority-change
        pass tests/threads/priority-donate-one
        pass tests/threads/priority-donate-multiple
        pass tests/threads/priority-donate-multiple2
        pass tests/threads/priority-donate-nest
        pass tests/threads/priority-donate-sema
        pass tests/threads/priority-donate-lower
        pass tests/threads/priority-fifo
        pass tests/threads/priority-preempt
        pass tests/threads/priority-sema
        pass tests/threads/priority-condvar
        pass tests/threads/priority-donate-chain
        2 of 95 tests failed.
        ```

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1587a499-d0ca-44e6-9d26-6dc8a1438542/Untitled.png)

    - make check 메세지

        - multi-oom -solved

            ```c
            pintos -v -k -T 600 -m 20 -m 20   --fs-disk=10 -p tests/userprog/no-vm/multi-oom:multi-oom -- -q   -f run multi-oom < /dev/null 2> tests/userprog/no-vm/multi-oom.errors > tests/userprog/no-vm/multi-oom.output
            perl -I../.. ../../tests/userprog/no-vm/multi-oom.ck tests/userprog/no-vm/multi-oom tests/userprog/no-vm/multi-oom.result
            FAIL tests/userprog/no-vm/multi-oom
            run: FAIL to insert page!
            ```

            process_add_file()함수 문제

            - 고치기 전

            ```c
            int process_add_file(struct file *f)
            {
            	struct thread *curr = thread_current();
            	int findIdx = curr->next_fd; /* 탐색 포인터 */
            	// ASSERT(f != NULL);
            
            	while (findIdx < FDCOUNT_LIMIT && curr->fdt[findIdx])
            	{
            		findIdx++;
            	}
            	if (findIdx >= FDCOUNT_LIMIT)
            	{
            		return -1;
            	}
            	curr->fdt[findIdx] = f;
            	return findIdx;
            }
            ```

            - 고친 후

            ```c
            int process_add_file(struct file *f)
            {
            	struct thread *curr = thread_current();
            	struct file **fdt = curr->fdt;
            
            	// Find open spot from the front
            	while (curr->next_fd < FDCOUNT_LIMIT && fdt[curr->next_fd])
            	{
            		curr->next_fd++;
            	}
            
            	// error - fd table full
            	if (curr->next_fd >= FDCOUNT_LIMIT)
            		return -1;
            
            	fdt[curr->next_fd] = f;
            	return curr->next_fd;
            }
            ```

            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efd90f27-6dec-409a-9894-5445edc9b5f0/Untitled.png)

        - sys-read

            ```c
            pintos -v -k -T 300 -m 20   --fs-disk=10 -p tests/filesys/base/syn-read:syn-read -p tests/filesys/base/child-syn-read:child-syn-read -- -q   -f run syn-read < /dev/null 2> tests/filesys/base/syn-read.errors > tests/filesys/base/syn-read.output
            perl -I../.. ../../tests/filesys/base/syn-read.ck tests/filesys/base/syn-read tests/filesys/base/syn-read.result
            FAIL tests/filesys/base/syn-read
            run: wait for child 3 of 10 returned -1 (expected 2): FAILED
            ```

            ```c
            Kernel command line: -q -f put syn-read put child-syn-read run syn-read
            0 ~ 9fc00 1
            100000 ~ 13e0000 1
            Pintos booting with: 
                    base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
                    ext_mem: 0x100000 ~ 0x13e0000 (Usable: 19,328 kB)
            Calibrating timer...  117,760,000 loops/s.
            hd0:0: detected 321 sector (160 kB) disk, model "QEMU HARDDISK", serial "QM00001"
            hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
            hd1:0: detected 225 sector (112 kB) disk, model "QEMU HARDDISK", serial "QM00003"
            Formatting file system...done.
            Boot complete.
            Putting 'syn-read' into the file system...
            Putting 'child-syn-read' into the file system...
            Executing 'syn-read':
            (syn-read) begin
            (syn-read) create "data"
            (syn-read) open "data"
            (syn-read) write "data"
            (syn-read) close "data"
            (syn-read) exec child 1 of 10: "child-syn-read 0"
            (syn-read) exec child 2 of 10: "child-syn-read 1"
            (syn-read) exec child 3 of 10: "child-syn-read 2"
            (syn-read) exec child 4 of 10: "child-syn-read 3"
            (syn-read) exec child 5 of 10: "child-syn-read 4"
            (syn-read) exec child 6 of 10: "child-syn-read 5"
            (syn-read) exec child 7 of 10: "child-syn-read 6"
            (syn-read) exec child 8 of 10: "child-syn-read 7"
            (syn-read) exec child 9 of 10: "child-syn-read 8"
            (syn-read) exec child 10 of 10: "child-syn-read 9"
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-read: exit(-1)
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-read: exit(-1)
            child-syn-read: exit(0)
            (syn-read) wait for child 1 of 10 returned 0 (expected 0)
            child-syn-read: exit(1)
            (syn-read) wait for child 2 of 10 returned 1 (expected 1)
            child-syn-read: exit(3)
            child-syn-read: exit(2)
            (syn-read) wait for child 3 of 10 returned 2 (expected 2)
            (syn-read) wait for child 4 of 10 returned 3 (expected 3)
            child-syn-read: exit(4)
            (syn-read) wait for child 5 of 10 returned 4 (expected 4)
            child-syn-read: exit(5)
            (syn-read) wait for child 6 of 10 returned 5 (expected 5)
            (syn-read) wait for child 7 of 10 returned -1 (expected 6)
            (syn-read) wait for child 7 of 10 returned -1 (expected 6): FAILED
            child-syn-read: exit(8)
            syn-read: exit(1)
            Execution of 'syn-read' complete.
            child-syn-read: exit(9)
            Timer: 905 ticks
            Thread: 347 idle ticks, 38 kernel ticks, 520 user ticks
            hd0:0: 0 reads, 0 writes
            hd0:1: 8909 reads, 504 writes
            hd1:0: 225 reads, 0 writes
            Console: 2345 characters output
            Keyboard: 0 keys pressed
            Exception: 2 page faults
            Powering off...
            ```

            - 고치기전

                ```c
                int write(int fd, const void *buffer, unsigned size)
                {
                	check_address(buffer);
                	int write_count;
                
                	struct file *fileobj = process_get_file(fd);
                
                	if (fd == 0)
                	{
                		return 0;
                	}
                
                	if (fileobj == NULL)
                	{
                		return -1;
                	}
                	if (fileobj == STDOUT)
                	{
                		putbuf(buffer, size);
                		write_count = size;
                	}
                	else if (fileobj == 1)
                	{
                		return -1;
                	}
                	else
                	{
                
                		lock_acquire(&filesys_lock);
                		write_count = file_write(fileobj, buffer, size);
                		lock_release(&filesys_lock);
                	}
                	return write_count; // 출력한 데이터의 byte를 반환한다.
                }
                ```

            - 고친후

                ```c
                int write(int fd, const void *buffer, unsigned size)
                {
                	check_address(buffer);
                	int write_count;
                
                	struct file *fileobj = process_get_file(fd);
                	
                	if (fileobj == NULL)
                	{
                		return -1;
                	}
                
                	if (fileobj == STDOUT)
                	{
                		putbuf(buffer, size);
                		write_count = size;
                	}
                	else if (fileobj == STDIN)
                	{
                		return -1;
                	}
                	else
                	{
                		lock_acquire(&filesys_lock);
                		write_count = file_write(fileobj, buffer, size);
                		lock_release(&filesys_lock);
                	}
                	return write_count; // 출력한 데이터의 byte를 반환한다.
                }
                ```

        - syn-write

            ```c
            pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/filesys/base/syn-write:syn-write -p tests/filesys/base/child-syn-wrt:child-syn-wrt -- -q   -f run syn-write < /dev/null 2> tests/filesys/base/syn-write.errors > tests/filesys/base/syn-write.output
            perl -I../.. ../../tests/filesys/base/syn-write.ck tests/filesys/base/syn-write tests/filesys/base/syn-write.result
            FAIL tests/filesys/base/syn-write
            run: wait for child 9 of 10 returned -1 (expected 8): FAILED
            ```

            ```c
            pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/filesys/base/syn-write:syn-write -p tests/filesys/base/child-syn-wrt:child-syn-wrt -- -q   -f run syn-write < /dev/null 2> tests/filesys/base/syn-write.errors > tests/filesys/base/syn-write.output
            perl -I../.. ../../tests/filesys/base/syn-write.ck tests/filesys/base/syn-write tests/filesys/base/syn-write.result
            FAIL tests/filesys/base/syn-write
            Kernel panic in run: PANIC at ../../threads/thread.c:227 in thread_current(): assertion `is_thread(t)' failed.
            Call stack: 0x8004217ec7 0x800420711a 0x800421d15c 0x800421d406 0x800421d022 0x800421cdf3 0x4001ce 0x400f82
            Translation of call stack:
            0x0000008004217ec7: debug_panic (lib/kernel/debug.c:32)
            0x000000800420711a: thread_current (threads/thread.c:228)
            0x000000800421d15c: check_address (userprog/syscall.c:167)
            0x000000800421d406: open (userprog/syscall.c:258)
            0x000000800421d022: syscall_handler (userprog/syscall.c:103)
            0x000000800421cdf3: no_sti (userprog/syscall-entry.o:?)
            0x00000000004001ce: (unknown)
            0x0000000000400f82: (unknown)
            ```

            ```c
            root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog/build# pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/filesys/base/syn-write:syn-write -p tests/filesys/base/child-syn-wrt:child-syn-wrt -- -q   -f run syn-write
            qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]
            Kernel command line: -q -f put syn-write put child-syn-wrt run syn-write
            0 ~ 9fc00 1
            100000 ~ 13e0000 1
            Pintos booting with: 
                    base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
                    ext_mem: 0x100000 ~ 0x13e0000 (Usable: 19,328 kB)
            Calibrating timer...  130,867,200 loops/s.
            hd0:0: detected 321 sector (160 kB) disk, model "QEMU HARDDISK", serial "QM00001"
            hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
            hd1:0: detected 226 sector (113 kB) disk, model "QEMU HARDDISK", serial "QM00003"
            Formatting file system...done.
            Boot complete.
            Putting 'syn-write' into the file system...
            Putting 'child-syn-wrt' into the file system...
            Executing 'syn-write':
            (syn-write) begin
            (syn-write) create "stuff"
            (syn-write) exec child 1 of 10: "child-syn-wrt 0"
            (syn-write) exec child 2 of 10: "child-syn-wrt 1"
            (syn-write) exec child 3 of 10: "child-syn-wrt 2"
            (syn-write) exec child 4 of 10: "child-syn-wrt 3"
            (syn-write) exec child 5 of 10: "child-syn-wrt 4"
            (syn-write) exec child 6 of 10: "child-syn-wrt 5"
            (syn-write) exec child 7 of 10: "child-syn-wrt 6"
            (syn-write) exec child 8 of 10: "child-syn-wrt 7"
            (syn-write) exec child 9 of 10: "child-syn-wrt 8"
            (syn-write) exec child 10 of 10: "child-syn-wrt 9"
            child-syn-wrt: exit(0)
            (syn-write) wait for child 1 of 10 returned 0 (expected 0)
            child-syn-wrt: exit(1)
            (syn-write) wait for child 2 of 10 returned 1 (expected 1)
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-wrt: exit(-1)
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-wrt: exit(-1)
            child-syn-wrt: exit(2)
            (syn-write) wait for child 3 of 10 returned 2 (expected 2)
            (syn-write) wait for child 4 of 10 returned -1 (expected 3)
            (syn-write) wait for child 4 of 10 returned -1 (expected 3): FAILED
            syn-write: exit(1)
            Execution of 'syn-write' complete.
            Timer: 149 ticks
            Thread: 59 idle ticks, 45 kernel ticks, 45 user ticks
            hd0:0: 0 reads, 0 writes
            hd0:1: 641 reads, 515 writes
            hd1:0: 226 reads, 0 writes
            Console: 1984 characters output
            Keyboard: 0 keys pressed
            Exception: 2 page faults
            Powering off...
            ```

            **read, write 둘다 이상한거보니 같이 쓰이는 함수가 문제다.**

            - 의심 1) get_file() 이상 - 고칠게 없

                ```c
                struct file *process_get_file(int fd)
                {
                	if (fd < 0 || fd >= FDCOUNT_LIMIT)
                	{
                		return NULL;
                	}
                	struct thread *curr = thread_current();
                	return curr->fdt[fd];
                }
                ```

            - exec_children()

                현재 프로세스를 `fork()`한 후 자식 프로세스를 실행하는 것을 10번 반복

                ```c
                void
                exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
                {
                  size_t i;
                
                  for (i = 0; i < child_cnt; i++) 
                    {
                      char cmd_line[128];
                      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
                      if ((pids[i] = fork (child_name))){
                        CHECK (pids[i] != PID_ERROR,
                             "exec child %zu of %zu: \\"%s\\"", i + 1, child_cnt, cmd_line);
                      } else {
                        exec (cmd_line);
                      }
                      
                    }
                }
                ```

            - wait_children() 여기서 문제가 나는거같은데…

                ```c
                void
                wait_children (pid_t pids[], size_t child_cnt) 
                {
                  size_t i;
                  
                  for (i = 0; i < child_cnt; i++) 
                    {
                      int status = wait (pids[i]);
                      CHECK (status == (int) i,
                             "wait for child %zu of %zu returned %d (expected %zu)",
                             i + 1, child_cnt, status, i);
                    }
                }
                ```

            - wait() syscall 확인 → 문제없음

            priority 관련 다 확인 문제없음

            wait sema 문제없음. list order문제없음

            yield관련 !!!문제 있음!!!!  동영상 찍어놓

            - test_max_priority(void) 고치기 전

                ```c
                void test_max_priority(void)
                {
                	if (list_empty(&ready_list) || intr_context())
                	{
                		return;
                	}
                	int run_priority = thread_current()->priority;
                	struct list_elem *e = list_begin(&ready_list);
                	struct thread *t = list_entry(e, struct thread, elem);
                	if (run_priority <= thread_get_priority())
                	{
                		thread_yield();
                	}
                }
                ```

            - test_max_priority(void) 고친 후

                ```c
                void test_max_priority(void)
                {
                	if (list_empty(&ready_list) || intr_context())
                	{
                		return;
                	}
                	int run_priority = thread_current()->priority;
                	struct list_elem *e = list_begin(&ready_list);
                	struct thread *t = list_entry(e, struct thread, elem);
                	if (t->priority > thread_get_priority())
                	{
                		thread_yield();
                	}
                }
                ```

    - 결과

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/119ca5dc-d8c3-437d-aeb8-60c2c52066df/Untitled.png)

- error log

    - make 실패: include file문제

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/282188be-815e-402b-81d1-8e6f82a333d0/Untitled.png)

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c4b69c2-da22-4bb5-ad78-b03d0e407d3f/Untitled.png)

    - kernel panic -backtrace사용법

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/871395c0-e7c1-43d1-ae5e-9f6e99269e53/Untitled.png)

- pml4_create()

    threads/mmu.c

    ```c
    uint64_t *
    pml4_create (void) {
    	uint64_t *pml4 = palloc_get_page (0);
    	if (pml4)
    		memcpy (pml4, base_pml4, PGSIZE);
    	return pml4;
    }
    ```

- 공부한 내용: 동빈나 system call

    https://youtu.be/PsXXjNL_ogc

    - resister 종류

        rax: 시스템콜의 실질적인 번호를 가르키는 번호이자, 그 결과가 담기는 resister

        rbx: base resister, 메모리 지정 시 사용

        rcx: counter resister, 주로 반복문에 사용

        rdx: data resister, 연산을 수행할 때 rax와 함께 많이 사용

        여기까지가 데이터 레지스터

        ------

        rsi: 메모리를 이동하고 비교할 때 그 출발지 주소

        rdi:  메모리를 이동하고 비교할 때 그 목적지 주소

        rbp: 함수의 파라미터나 변수의 주소를 가리킬 때 사용

        rsp: stack의 삽입 및 삭제 명령에 의해변경되는 스택에서 가장 위에 있는 주소를 가리킬 때 사용

        여기까지가 포인터 레지스터: 특정한 주소를 가리키는 레지스터 4가지

        ------

        r8~r15 : 함수의 매개 변수로 사용

        ------

    - 시스템콜 과정

        %rax 에 그 번호가 담긴 systemcall을 부르게됨.

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ff9b48b-84ad-480f-915e-9ab28097e825/Untitled.png)

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8e92283-53aa-42f4-8b44-dfedc7cecc6a/Untitled.png)

        syscall1: write()

        syscall60: exit()

- 공부한 내용: notion시스템콜 과정

    - 사용자 프로그램이 시스템 콜을 호출한다.

        ```c
        write (STDOUT_FILENO, buf, strlen (buf));
        ```

    - 사용자 프로그램 라이브러리(**syscall.c**)가 **해당 시스템 콜의 넘버, 인자들, 해당 프로그램의 인터럽트 프레임**을 정해진 순서대로 **레지스터에 채워준다.** 그리고 `syscall` 명령어를 CPU에게 때려준다. 소프트웨어 인터럽트가 발생되면서 CPU가 커널 모드로 전환된다.

        - **lib/user/syscall.c**

            ```c
            __attribute__((always_inline))
            static __inline int64_t syscall (uint64_t num_, uint64_t a1_, uint64_t a2_,
            		uint64_t a3_, uint64_t a4_, uint64_t a5_, uint64_t a6_) {
            	int64_t ret;
            	register uint64_t *num asm ("rax") = (uint64_t *) num_;
            	register uint64_t *a1 asm ("rdi") = (uint64_t *) a1_;
            	register uint64_t *a2 asm ("rsi") = (uint64_t *) a2_;
            	register uint64_t *a3 asm ("rdx") = (uint64_t *) a3_;
            	register uint64_t *a4 asm ("r10") = (uint64_t *) a4_;
            	register uint64_t *a5 asm ("r8") = (uint64_t *) a5_;
            	register uint64_t *a6 asm ("r9") = (uint64_t *) a6_;
            
            	/* 3. 각각의 레지스터에 차례대로 시스템 콜 넘버부터 각 인자들을 저장한다. */
            	__asm __volatile(
            			"mov %1, %%rax\\n"
            			"mov %2, %%rdi\\n"
            			"mov %3, %%rsi\\n"
            			"mov %4, %%rdx\\n"
            			"mov %5, %%r10\\n"
            			"mov %6, %%r8\\n"
            			"mov %7, %%r9\\n"
            			"syscall\\n"    // 4. 저장 후 syscall instruction을 때린다. 커널 모드로 전환.
            			: "=a" (ret)
            			: "g" (num), "g" (a1), "g" (a2), "g" (a3), "g" (a4), "g" (a5), "g" (a6)
            			: "cc", "memory");
            	return ret;
            }
            
            // asm volatile( asms : output : input : clober )
            // <http://wiki.kldp.org/KoreanDoc/html/EmbeddedKernel-KLDP/app3.basic.html>
            
            ....
            /* 1. 해당 시스템 콜을 찾고 */
            int write (int fd, const void *buffer, unsigned size) {
            	return syscall3 (SYS_WRITE, fd, buffer, size);
            }
            ...
            /* 2. 형식에 맞게 변환 */
            #define syscall3(NUMBER, ARG0, ARG1, ARG2) ( \\
            		syscall(((uint64_t) NUMBER), \\
            			((uint64_t) ARG0), \\
            			((uint64_t) ARG1), \\
            			((uint64_t) ARG2), 0, 0, 0))
            ```

    - **userprog/syscall-entry.S**

        **Previllege Level을 커널 모드(Ring 0)으로 올린다.** 이 때 원래 Caller 사용자 스택 포인터를 RBX에 저장해둔다.

        ```c
        #include "threads/loader.h"
        .text
        .globl syscall_entry
        .type syscall_entry, @function
        syscall_entry:
        	movq %rbx, temp1(%rip)
        	movq %r12, temp2(%rip)     /* callee saved registers */
        	movq %rsp, %rbx            /* Store userland rsp    */
        	movabs $tss, %r12  // 해당 커널 프로세스의 TSS의 주소를 받아온다.
        	movq (%r12), %r12
        	movq 4(%r12), %rsp 
          // TSS에 저장되어 있던 RSP0(커널 스택 시작주소)의 주소를 RSP로 옮긴다.
        ```

        **CPU와 OS가** 자동으로 인터럽트 되기 전 인터럽트 당한 프로세스(커널이든 사용자든)의 **Context를 프로세스 자신의 커널 스택에** **저장**해둔다. 이를 통해 인터럽트가 끝나면 다시 인터럽트 된 Task로 되돌아올 수 있다.

        일단 이 밑 5개 레지스터 값은 **CPU가 push**해주는 레지스터 값이다.

        1. %ss
        2. %rsp
        3. %eflags
        4. %cs
        5. %rip

        `RIP`를 통해 인터럽트 후 다시 되돌아가야 하는 인스트럭션의 주소를 알 수 있다. 또한 `RSP`는 커널 스레드의 스택 최상단을 가리킨다(so we can return to the exact chain of function calls when the interrupt happened).

        ```c
        	/* Now we are in the kernel stack 여기서 커널 스택으로 바뀐다. */
        	/* 여기서부터 유저 프로세스의 인터럽트 프레임을 커널 스택에 순서대로 push한다. */
        	push $(SEL_UDSEG)      /* if->ss, 유저 스택 메모리 공간 주소 */
        	push %rbx              /* if->rsp, RBX에 돌아가야 할 유저 메모리의 RSP 값을 저장한다. */
        	push %r11              /* if->eflags */
        	push $(SEL_UCSEG)      /* if->cs, 유저 코드 세그먼트 메모리 시작 주소 */
        	push %rcx              /* if->rip, RCX에 돌아가야 할 다음 PC 값(RIP)을 저장한다. */
        	subq $16, %rsp         /* skip error_code, vec_no */
        ```

        **OS(intr_enrty)가** 커널 스택에 또 추가적인 레지스터 값을 담아준다.

        ```c
        	push $(SEL_UDSEG)      /* if->ds */
        	push $(SEL_UDSEG)      /* if->es */
        	push %rax
        	movq temp1(%rip), %rbx  /* 인자들도 커널 스택에 push한다. */
        	push %rbx
        	pushq $0
        	push %rdx
        	push %rbp
        	push %rdi
        	push %rsi
        	push %r8
        	push %r9
        	push %r10
        	pushq $0 /* skip r11 */
        	movq temp2(%rip), %r12
        	push %r12
        	push %r13
        	push %r14
        	push %r15
        ```

        <aside> 💡 즉, 다시 말해 인터럽트 시 인터럽트 당한 프로세스는 인터럽트 당하기 직전 CPU 레지스터에 담긴 정보들을 자신의 커널 스레드 스택에 담는다.

        </aside>

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c174134-be85-48ac-a4b9-2711eade1c5c/Untitled.png)

        커널 스택에 해당 프로세스의 인터럽트 프레임을 차곡차곡 쌓았으면, RDI를 RSP와 같은 값으로 맞춰줌으로써 바로 전까지 우리가 쌓은 커널 스택의 포인터를 인터럽트 프레임 함수(`void intr_handler(struct intr_frame *frame)`)의 argument로 넣어준다.

        ```c
        	movq %rsp, %rdi  
        	// 이제 rdi는 rsp가 가리키는 주소를 가리킨다. 
          // 즉, 앞으로 CALL할 함수의 첫 번째 인자가 
          // 스택에 쌓여 있는 데이터(인터럽트 프레임)의 시작 주소를 가리킨다.
        check_intr:
        	btsq $9, %r11          /* Check whether we recover the interrupt */
        	jnb no_sti
        	sti                    /* restore interrupt */
        ```

        인터럽트 프레임으로 인자를 설정했으면 이제 인터럽트 핸들러 함수를 부른다.

        ```c
        no_sti:
        	movabs $syscall_handler, %r12   
        	call *%r12             // 시스템 콜 핸들러를 부른다!
        ```

        인터럽트 핸들러가 작업을 처리한 후, 아까 커널 스택에 우리가 쌓았던 인터럽트 프레임에 대한 정보들을 다 레지스터에 집어넣으면서 스택을 지워준다. CPU가 쌓았던 원래 Caller의 레지스터 값들을 다시 원복하는 과정이다.

        ```c
        	popq %r15
        	popq %r14
        	popq %r13
        	popq %r12
        	popq %r11
        	popq %r10
        	popq %r9
        	popq %r8
        	popq %rsi
        	popq %rdi
        	popq %rbp
        	popq %rdx
        	popq %rcx
        	popq %rbx
        	popq %rax
        	addq $32, %rsp
        	popq %rcx              /* if->rip */
        	addq $8, %rsp
        	popq %r11              /* if->eflags */
        	popq %rsp              /* if->rsp */
        ```

        - Caller로 되돌아간다.

        ```c
        	sysretq        // 리턴.
        
        .section .data
        .globl temp1
        temp1:
        .quad	0
        .globl temp2
        temp2:
        .quad	0
        ```

    <aside> 💡 **시스템 콜 엔트리와 do_iret()의 차이는?** do_iret()은 인터럽트 프레임을 레지스터에 넣어 실행시키고 나면 다시 그 이전 프로세스로 되돌아오지 않는다.

    </aside>

    - 시스템 콜 핸들러는 시스템 콜 넘버를 확인해 시스템 콜의 종류를 확인한 후, 해당 시스템 콜에 맞는 함수 혹은 작업을 수행한다.

        - **userprog/syscall.c**

            ```c
            /* syscall_handler의 인자는 하나. 그 인자는 rdi에서 가져온다. 
               */
            void syscall_handler (struct intr_frame *f UNUSED) {
            	// TODO: Your implementation goes here.
            	char *f_copy;
            
            	switch(f->R.rax) {
            		case SYS_HALT:
            			halt();
            			break;
            		case SYS_EXIT:
            			exit(f->R.rdi);
            			break;
            		case SYS_CREATE:
            			f->R.rax = create(f->R.rdi, f->R.rsi);
            			break;
            ...
            }
            ```

    - 리턴값을 RAX 레지스터에 저장한 다음 사용자 프로그램에 돌려준다. 커널에서 구체적으로 어떻게 돌려주는지는 몰겠음.

        - **lib/user/syscall.c**

            ```c
            __attribute__((always_inline))
            static __inline int64_t syscall (uint64_t num_, uint64_t a1_, uint64_t a2_,
            		uint64_t a3_, uint64_t a4_, uint64_t a5_, uint64_t a6_) {
            	int64_t ret;
            	register uint64_t *num asm ("rax") = (uint64_t *) num_;
            	register uint64_t *a1 asm ("rdi") = (uint64_t *) a1_;
            	register uint64_t *a2 asm ("rsi") = (uint64_t *) a2_;
            	register uint64_t *a3 asm ("rdx") = (uint64_t *) a3_;
            	register uint64_t *a4 asm ("r10") = (uint64_t *) a4_;
            	register uint64_t *a5 asm ("r8") = (uint64_t *) a5_;
            	register uint64_t *a6 asm ("r9") = (uint64_t *) a6_;
            
            	__asm __volatile(
            			"mov %1, %%rax\\n"
            			"mov %2, %%rdi\\n"
            			"mov %3, %%rsi\\n"
            			"mov %4, %%rdx\\n"
            			"mov %5, %%r10\\n"
            			"mov %6, %%r8\\n"
            			"mov %7, %%r9\\n"
            			"syscall\\n"    
            			: "=a" (ret)  // 리턴값을 ret이라는 변수에 넣고
            			: "g" (num), "g" (a1), "g" (a2), "g" (a3), "g" (a4), "g" (a5), "g" (a6)
            			: "cc", "memory");
            	return ret;  // 리턴한다.
            }
            
            ....
            
            int write (int fd, const void *buffer, unsigned size) {
            	return syscall3 (SYS_WRITE, fd, buffer, size);  // 리턴된다.
            }
            ```

    x86과는 다르게 x86_64 시스템에서는 `syscall`이라는 특별한 명령어를 제공한다. x86에서는 그냥 인터럽트 번호가 int 0x80이다. `syscall` 명령어는 시스템 콜 핸들러를 부를 수 있는 가장 빠른 방법이다.

    사용자 프로그램은 syscall 명령어를 통해 시스템 콜을 보낼 수 있다. 이 때 다른 함수들을 호출할 때와 비슷하게 인자들과 리턴값이 레지스터에 저장되는데, 딱 두 가지가 다르다.

    - `%rax`에는 **시스템 콜 넘버**가 저장된다(보통의 함수라면 이 자리에 callee의 반환값을 저장한다).
    - **4번째 인자**는 `%rcx`가 아닌 `**%r10`에** 저장된다(원래 보통의 함수라면  `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8` 그리고 `%r9`에 저장된다).

    시스템 콜을 부른 사용자 함수의 레지스터 값은  `struct intr_frame`에서 확인할 수 있다.

    그리고 리턴값이 있는 시스템 콜의 경우 그 리턴값을 해당 구조체의 `rax`를 수정해서 커널이 확인할 수 있다.

- 참고 블로그

    https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-3-System-Call정글사관학교-65일차-TIL

- 그 외

    - **x86-64 Calling Convention**

        x86-64 호출 규약은 함수 호출 방식을 정의하는 규칙 세트입니다. 호출자와 피호출자 간의 인자 전달, 스택 및 레지스터 사용 및 관리, 반환 값 처리 등을 포함합니다. 이 규약은 x86-64 아키텍처에서 소프트웨어 개발에 필수적인 부분 중 하나입니다.

    - ELF

        ELF 바이너리(=ELF 실행파일)들을 로드하고 프로세스를 실행합니다

        ELF는 많은 운영체제에서 목적 파일, 공유 라이브러리, 그리고 실행 파일들을 위해 사용되는 파일 포맷

    - GDT

        GDT는 Global Descriptor Table의 약자로, x86 아키텍처에서 메모리 보호 및 가상 메모리 관리에 사용되는 데이터 구조입니다. GDT는 메모리에 저장된 세그먼트 디스크립터의 배열로, 각 디스크립터는 특정 세그먼트의 범위와 속성을 나타내는 정보를 담고 있습니다. 이를 통해 운영체제는 각각의 프로세스가 접근 가능한 메모리 영역을 제한하고, 프로세스간의 충돌을 방지하며, 가상 메모리를 구현할 수 있게 됩니다. GDT는 운영체제에서 초기화되고 관리되며, 사용자 프로세스는 GDT에 직접 접근할 수 없습니다.

    - TSS

        Task-State Segment (TSS)은 x86 아키텍처에서 사용되었던 태스크 스위칭을 위한 세그먼트이다. 그러나 x86-64에서는 태스크 스위칭이 사용되지 않는다. 그럼에도 불구하고 TSS는 링 스위칭 중 스택 포인터를 찾기 위해 여전히 사용된다.이는 유저 프로세스가 인터럽트 핸들러에 진입할 때, 하드웨어는 tss에게 커널의 스택 포인터를 찾아달라고 요청한다는 의미입니다.

    - Execution information

        "Execution information"은 프로그램 실행 도중에 생성되는 정보로, 프로세스가 메모리에 올라가 실행되면서 발생하는 다양한 정보를 의미합니다. 이 정보에는 현재 프로세스의 CPU 레지스터 값, 스택 포인터, 프로그램 카운터 값 등이 포함

    - ECF(Exceptional contol flow): 예외적인 흐름

        프로세서에서 전원을 처음 공급하는 시점부터 전원을 끌 때까지 **프로그램 카운터는 연속된 값을 A0,A1, . . ., An-1가정**한다.

        이때, 인스트럭션 Ik에 대응되는 주소가 Ak이다.  Ak에서  Ak+1로의 전환은 **제어이동**이라고 부른다. 이러한 제어

        일반적인 프로그램의 흐름은 명령어들이 순차적으로 실행되는 것입니다. 하지만 예외적인 상황이 발생하면, 예를 들어 디바이스 오류, 시스템 콜 요청, 인터럽트 등이 발생하면 프로그램의 제어 흐름은 일시적으로 예외적인 상황으로 전환

    - 가상메모리란?

        메인 메모리의 추상화. 각 프로세스에 하나의 크고 통합된, 사적 주소공간을 제공하는 것.

        1. 메인 메모리 내 활성화 영역만 유지→메인메모리를 효율적으로 사용
        2. 각 프로세스에 통일된 주소공간을 제공→ 메모리 관리 단순화
        3. 각 프로세스의 주소공간을 다른 프로세스에 의한 손상으로부터 보호.

    [22. 페이징(Paging)과 페이지 테이블(Page table) (tistory.com)](https://ddongwon.tistory.com/49)