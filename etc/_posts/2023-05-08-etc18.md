---
layout : post
title : "PintOS User program WIL"
subtitle : " Pintos 2ì£¼ì°¨"
catalog : true
tags : 	
    - etc
    - pintos
---





# User Memory Access & System call

ğŸ“‹ëª©ì°¨

------

# ğŸ¯ ê³¼ì œëª©í‘œ

ê¸°ë³¸ìœ¼ë¡œ ì£¼ì–´ì§„ PintosëŠ” í”„ë¡œê·¸ë¨ê³¼ ì¸ìë¥¼ êµ¬ë¶„í•˜ì§€ ëª»í•˜ëŠ”êµ¬ì¡°ë¡œ ë˜ì–´ìˆë‹¤.

ì˜ˆ: $lsâ€“a /* PintosëŠ” â€˜ls-aâ€™ ë¥¼ í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ëª…ìœ¼ë¡œ ì¸ì‹*/

ì´ë²ˆ ê³¼ì œì—ëŠ” í”„ë¡œê·¸ë¨ì´ ì‹œìŠ¤í…œ ì½œì„ í†µí•´ì„œ OSì™€ ìƒí˜¸ì‘ìš©í•˜ì—¬ command lineì—ì„œ ëª…ë ¹ì–´ê°€ ì‹¤í–‰ë  ìˆ˜ ìˆë„ë¡ ë§Œë“œëŠ” ê²ƒì´ë‹¤.

í”„ë¡œì íŠ¸ì—ì„œëŠ” íŒŒì¼ ì‹œìŠ¤í…œ ì½”ë“œì™€ ì¸í„°í˜ì´ìŠ¤í•´ì•¼ í•œë‹¤. ìœ ì € í”„ë¡œê·¸ë¨ì´ íŒŒì¼ ì‹œìŠ¤í…œìœ¼ë¡œë¶€í„° ë¡œë“œë˜ê¸°ë„ í•˜ê³ , êµ¬í˜„í•´ì•¼ í•  ì‹œìŠ¤í…œ ì½œë“¤ì´ íŒŒì¼ ì‹œìŠ¤í…œì„ ë‹¤ë£¨ê¸° ë•Œë¬¸ì´ë‹¤.

**í”„ë¡œê·¸ë¨ ì´ë¦„ê³¼ ì¸ìë¥¼ êµ¬ë¶„í•˜ì—¬ ìŠ¤íƒì— ì €ì¥, ì¸ìë¥¼ í”„ë¡œê·¸ë¨ì— ì „ë‹¬í•˜ê³ , ì‘ì„±í•œ ì‹œìŠ¤í…œ ì½œì„ ì‹¤í–‰ì‹œì¼œ command lineì˜ ëª…ë ¹ì–´ê°€  ì‹¤í–‰ë˜ë„ë¡ ë§Œë“¤ì.**

------

# ğŸ—’ï¸Introduction

<aside> ğŸ’¡ x86-64ì—ì„œëŠ” ì£¼ì–´ì§„ ë¬¼ë¦¬ ì£¼ì†Œ ë©”ëª¨ë¦¬ì— ì§ì ‘ì ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì€ os ì»¤ë„ì—ì„œ í•„ìš”í•˜ë©°, ì´ë¥¼ ìœ„í•´ í•€í† ìŠ¤ëŠ” ì»¤ë„ ê°€ìƒ ë©”ëª¨ë¦¬ë¥¼ ë¬¼ë¦¬ ë©”ëª¨ë¦¬ì™€ 1ëŒ€1ë¡œ ë§¤í•‘(mapping)í•©ë‹ˆë‹¤.  ì¦‰, ê°€ìƒ ì£¼ì†Œê°€ KERN_BASEë¼ë©´ ë¬¼ë¦¬ ì£¼ì†Œ 0ì— ë§¤í•‘ë˜ë©°, ê°€ìƒ ì£¼ì†Œê°€  `KERN_BASE + 0x1234` ë¼ë©´, ë¬¼ë¦¬ ì£¼ì†Œ 0x1234ì— ë§¤í•‘ë©ë‹ˆë‹¤.  ë”°ë¼ì„œ, ë¬¼ë¦¬ ì£¼ì†Œì— `KERN_BASE` ë¥¼ ë”í•˜ë©´ ì»¤ë„ ê°€ìƒ ì£¼ì†Œë¥¼ ì–»ì„ ìˆ˜ ìˆê³ , ë°˜ëŒ€ë¡œ ìƒê°í•´ë³´ë©´, ì»¤ë„ ê°€ìƒ ì£¼ì†Œì—ì„œ `KERN_BASE` ë¥¼ ë¹¼ì£¼ë©´ ë¬¼ë¦¬ ì£¼ì†Œë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í—¤ë”íŒŒì¼  `include/threads/vaddr.h` ì€ ì´ëŸ¬í•œ ì „í™˜ì— ëŒ€í•œ í•œ ìŒì˜ í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤

</aside>

> If you don't want to keep the file system disk around for later use or inspection, you can even combine all four steps into a single command. The `--filesys-size=n` option creates a temporary file system partition approximately n megabytes in size just for the duration of the pintos run. The Pintos automatic test suite makes extensive use of this syntax:

```bash
pintos --fs-disk=10 -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
```

<aside> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0de3f89-d77b-4701-8520-3ea52dc0e352/jungle_yujin_run.gif" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0de3f89-d77b-4701-8520-3ea52dc0e352/jungle_yujin_run.gif" width="40px" /> ë§Œì•½ íŒŒì¼ ì‹œìŠ¤í…œ ë””ìŠ¤í¬ê°€ ë‹¹ì¥ í•„ìš” ì—†ë‹¤ë©´, ì´ ë„¤ ë‹¨ê³„ë¥¼ í•˜ë‚˜ì˜ ì»¤ë§¨ë“œë¡œ í•©ì¹  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. `--filesys-size=n` ì˜µì…˜ì„ ì“°ë©´ pintosë¥¼ ì‹¤í–‰í•˜ëŠ” ë™ì•ˆ ëŒ€ëµ në©”ê°€ë°”ì´íŠ¸ í¬ê¸°ì˜ ì„ì‹œ íŒŒì¼ ì‹œìŠ¤í…œ íŒŒí‹°ì…˜ì„ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤. pintoì˜ ìë™ ì‹œìŠ¤í…œ suiteì€ ì´ êµ¬ë¬¸ì„ ì•„ì£¼ ë‹¤ì–‘í•˜ê²Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

</aside>

# ğŸ”ì½”ë“œ ì´í•´

main() > run_action() > run_task() >process_wait (process_create_initd (task)) >thread_exit ()

process_wait (): ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì•¼í•¨.

- ***main()***

    ***:*** threads/init.c/main(void)

    ```c
    /* Pintos main program. */
    int main (void) {
       uint64_t mem_end;
       char **argv;
    
       /* Clear BSS and get machine's RAM size. */
       bss_init ();
    
       /* Break command line into arguments and parse options. */
       argv = read_command_line ();
       argv = parse_options (argv);
    
       /* Initialize ourselves as a thread so we can use locks,
          then enable console locking. */
       thread_init ();
       console_init ();
    
       /* Initialize memory system. */
       mem_end = palloc_init ();
       malloc_init ();
       paging_init (mem_end);
    
    #ifdef USERPROG
       tss_init ();
       gdt_init ();
    #endif
    
       /* Initialize interrupt handlers. */
       intr_init ();
       timer_init ();
       kbd_init ();
       input_init ();
    #ifdef USERPROG
       exception_init ();
       syscall_init ();
    #endif
       /* Start thread scheduler and enable interrupts. */
       thread_start ();
       serial_init_queue ();
       timer_calibrate ();
    
    #ifdef FILESYS
       /* Initialize file system. */
       disk_init ();
       filesys_init (format_filesys);
    #endif
    
    #ifdef VM
       vm_init ();
    #endif
    
       printf ("Boot complete.\\\\n");
    
       /* Run actions specified on kernel command line. */
       run_actions (argv);
    
       /* Finish up. */
       if (power_off_when_done)
       	power_off ();
       thread_exit ();
    }
    ```

- read_command_line(void)

    : ì»¤ë„ ì»¤ë§¨ë“œ ë¼ì¸ì„ ë‹¨ì–´ë¡œ ë¶„í• í•˜ì—¬ argv í˜•íƒœì˜ ë°°ì—´ë¡œ ë°˜í™˜í•˜ëŠ” ì—­í• 

    ```c
    static char **
    read_command_line(void)
    {
    	static char *argv[LOADER_ARGS_LEN / 2 + 1];
    	char *p, *end;
    	int argc;
    	int i;
    
    	argc = *(uint32_t *)ptov(LOADER_ARG_CNT);
    	p = ptov(LOADER_ARGS);
    	end = p + LOADER_ARGS_LEN;
    	for (i = 0; i < argc; i++)
    	{
    		if (p >= end)
    			PANIC("command line arguments overflow");
    
    		argv[i] = p;
    		p += strnlen(p, end - p) + 1;
    	}
    	argv[argc] = NULL;
    
    	/* Print kernel command line. */
    	printf("Kernel command line:\\n");
    	for (i = 0; i < argc; i++)
    		if (strchr(argv[i], ' ') == NULL)
    			printf("(args) values[%d] = %s\\n", i, argv[i]);
    		else
    			printf("%s\\n", argv[i]);
    	printf("\\n");
    
    	return argv;
    }
    ```

    í•´ë‹¹ ì½”ë“œëŠ” ë¶€íŠ¸ ë¡œë”ì—ì„œ ì»¤ë„ì— ì „ë‹¬ëœ ì»¤ë§¨ë“œ ë¼ì¸ ì¸ìë¥¼ ì½ì–´ì˜¤ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.

    LOADER_ARG_CNT ë³€ìˆ˜ë¥¼ í†µí•´ ì „ë‹¬ëœ ì¸ì ê°œìˆ˜ë¥¼ ì½ì–´ì˜¨ í›„, LOADER_ARGS ë³€ìˆ˜ë¥¼ í†µí•´ ì¸ìë“¤ì˜ ë¬¸ìì—´ ë°°ì—´ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ì–»ì–´ì˜µë‹ˆë‹¤.

    ì´í›„ for ë£¨í”„ë¥¼ í†µí•´ ê° ì¸ìì˜ ì‹œì‘ ì£¼ì†Œë¥¼ argv ë°°ì—´ì— ì €ì¥í•©ë‹ˆë‹¤. ê° ì¸ìëŠ” ë¬¸ìì—´ì˜ í˜•íƒœë¡œ ì €ì¥ë˜ì–´ ìˆìœ¼ë©°, ë‹¤ìŒ ì¸ìë¥¼ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œë¥¼ ì°¾ê¸° ìœ„í•´ ë¬¸ìì—´ì˜ ê¸¸ì´ë¥¼ êµ¬í•©ë‹ˆë‹¤.

    ë§ˆì§€ë§‰ìœ¼ë¡œ argv ë°°ì—´ì— NULLì„ ì¶”ê°€í•´ ì»¤ë„ì—ì„œ ì¸ìì˜ ëì„ í‘œì‹œí•˜ê³ , ì¶œë ¥ë¬¸ì„ í†µí•´ ì¸ìë¥¼ ì½˜ì†”ì— ì¶œë ¥í•©ë‹ˆë‹¤.

    ì´ë¥¼ í†µí•´ ì»¤ë„ì—ì„œ ì–´ë–¤ ì¸ìë“¤ì´ ì „ë‹¬ë˜ì—ˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d090c838-0db0-4255-9acc-16e27daf2305/Untitled.png)

- run_action()

    ***:*** threads/init.c/run_action()

    ```c
    static void
    run_actions (char **argv) {
    	/* An action. */
    	struct action {
    		char *name;                       /* Action name. */
    		int argc;                         /* # of args, including action name. */
    		void (*function) (char **argv);   /* Function to execute action. */
    	};
    
    	/* Table of supported actions. */
    	static const struct action actions[] = {
    		{"run", 2, run_task},
    #ifdef FILESYS
    		{"ls", 1, fsutil_ls},
    		{"cat", 2, fsutil_cat},
    		{"rm", 2, fsutil_rm},
    		{"put", 2, fsutil_put},
    		{"get", 2, fsutil_get},
    #endif
    		{NULL, 0, NULL},
    	};
    
    	while (*argv != NULL) {
    		const struct action *a;
    		int i;
    
    		/* Find action name. */
    		for (a = actions; ; a++)
    			if (a->name == NULL)
    				PANIC ("unknown action `%s' (use -h for help)", *argv);
    			else if (!strcmp (*argv, a->name))
    				break;
    
    		/* Check for required arguments. */
    		for (i = 1; i < a->argc; i++)
    			if (argv[i] == NULL)
    				PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
    
    		/* Invoke action and advance. */
    		a->function (argv);
    		argv += a->argc;
    	}
    
    }
    ```

- run_task()

    threads/init.c

    ```c
    static void
    run_task (char **argv) {
    	const char *task = argv[1];
    
    	printf ("Executing '%s':\\n", task);
    #ifdef USERPROG
    	if (thread_tests){
    		run_test (task);
    	} else {
    		process_wait (process_create_initd (task));
    	}
    #else
    	run_test (task);
    #endif
    	printf ("Execution of '%s' complete.\\n", task);
    }
    ```

- process_create_initd (const char *file_name)

    userprog/process.c

    ```c
    tid_t
    process_create_initd (const char *file_name) {
    	char *fn_copy;
    	tid_t tid;
    
    	/* Make a copy of FILE_NAME.
    	 * Otherwise there's a race between the caller and load(). */
    	fn_copy = palloc_get_page (0);
    	if (fn_copy == NULL)
    		return TID_ERROR;
    	strlcpy (fn_copy, file_name, PGSIZE);
    
    	/* Create a new thread to execute FILE_NAME. */
    	tid = thread_create (file_name, PRI_DEFAULT, initd, fn_copy);
    	if (tid == TID_ERROR)
    		palloc_free_page (fn_copy);
    	return tid;
    }
    ```

    - ì½”ë“œ ê²°ê³¼

        file_name: args-single onearg

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95bbcf87-151b-43e7-9fab-0d0dab334656/Untitled.png)

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d4f041ca-0c74-4fc6-b33f-05b7ad9a198f/Untitled.png)

- void initd (void *f_name)

    ```c
    static void initd (void *f_name) {
    #ifdef VM
    	supplemental_page_table_init (&thread_current ()->spt);
    #endif
    
    	process_init ();
    
    	if (process_exec (f_name) < 0)
    		PANIC("Fail to launch initd\\n");
    	NOT_REACHED ();
    }
    ```

- process_exec()

    userprog/process.c

    ```c
    int
    process_exec (void *f_name) {
    	char *file_name = f_name;
    	bool success;
    
    	/* We cannot use the intr_frame in the thread structure.
    	 * This is because when current thread rescheduled,
    	 * it stores the execution information to the member. */
    	struct intr_frame _if;
    	_if.ds = _if.es = _if.ss = SEL_UDSEG;
    	_if.cs = SEL_UCSEG;
    	_if.eflags = FLAG_IF | FLAG_MBS;
    
    	/* We first kill the current context */
    	process_cleanup ();
    
    	/* And then load the binary */
    	success = load (file_name, &_if);
    
    	/* If load failed, quit. */
    	palloc_free_page (file_name);
    	if (!success)
    		return -1;
    
    	/* Start switched process. */
    	do_iret (&_if);
    	NOT_REACHED ();
    }
    ```

    ë“¤ì–´ì˜¤ëŠ” ì¸ì

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e8438ac-e4b6-410f-b0b4-f8cbfc402053/Untitled.png)

- thread_create()

    threads/tread.c

    ```c
    tid_t thread_create(const char *name, int priority,
    					thread_func *function, void *aux)
    {
    	struct thread *t;
    	tid_t tid;
    
    	ASSERT(function != NULL);
    
    	t = palloc_get_page(PAL_ZERO);
    	if (t == NULL)
    		return TID_ERROR;
    
    	init_thread(t, name, priority);
    	tid = t->tid = allocate_tid();
    
    	t->tf.rip = (uintptr_t)kernel_thread;
    	t->tf.R.rdi = (uint64_t)function;
    	t->tf.R.rsi = (uint64_t)aux;
    	t->tf.ds = SEL_KDSEG;
    	t->tf.es = SEL_KDSEG;
    	t->tf.ss = SEL_KDSEG;
    	t->tf.cs = SEL_KCSEG;
    	t->tf.eflags = FLAG_IF;
    
    	thread_unblock(t); // të¥¼ ready listì— ì¶”ê°€í•¨.
    
    	test_max_priority(); // ì¤€ì½” ì—¬ê¸° ë¹„êµ, yield ë‹¤ìˆìœ¼ë‹ˆê¹Œ
    
    	return tid;
    }
    ```

- process_wait()

    userprog/process.c

    ```c
    int
    process_wait (tid_t child_tid UNUSED) {
    	/* XXX: Hint) The pintos exit if process_wait (initd), we recommend you
    	 * XXX:       to add infinite loop here before
    	 * XXX:       implementing the process_wait. */
    	return -1;
    }
    ```

- load()

    ```c
    static bool
    load (const char *file_name, struct intr_frame *if_) {
    	struct thread *t = thread_current ();
    	struct ELF ehdr;
    	struct file *file = NULL;
    	off_t file_ofs;
    	bool success = false;
    	int i;
    
    	/* Allocate and activate page directory. */
    	t->pml4 = pml4_create ();
    	if (t->pml4 == NULL)
    		goto done;
    	process_activate (thread_current ());
    
    	/* Open executable file. */
    	file = filesys_open (file_name);
    	if (file == NULL) {
    		printf ("load: %s: open failed\\n", file_name);
    		goto done;
    	}
    
    	/* Read and verify executable header. */
    	if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
    			|| memcmp (ehdr.e_ident, "\\177ELF\\2\\1\\1", 7)
    			|| ehdr.e_type != 2
    			|| ehdr.e_machine != 0x3E // amd64
    			|| ehdr.e_version != 1
    			|| ehdr.e_phentsize != sizeof (struct Phdr)
    			|| ehdr.e_phnum > 1024) {
    		printf ("load: %s: error loading executable\\n", file_name);
    		goto done;
    	}
    
    	/* Read program headers. */
    	file_ofs = ehdr.e_phoff;
    	for (i = 0; i < ehdr.e_phnum; i++) {
    		struct Phdr phdr;
    
    		if (file_ofs < 0 || file_ofs > file_length (file))
    			goto done;
    		file_seek (file, file_ofs);
    
    		if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
    			goto done;
    		file_ofs += sizeof phdr;
    		switch (phdr.p_type) {
    			case PT_NULL:
    			case PT_NOTE:
    			case PT_PHDR:
    			case PT_STACK:
    			default:
    				/* Ignore this segment. */
    				break;
    			case PT_DYNAMIC:
    			case PT_INTERP:
    			case PT_SHLIB:
    				goto done;
    			case PT_LOAD:
    				if (validate_segment (&phdr, file)) {
    					bool writable = (phdr.p_flags & PF_W) != 0;
    					uint64_t file_page = phdr.p_offset & ~PGMASK;
    					uint64_t mem_page = phdr.p_vaddr & ~PGMASK;
    					uint64_t page_offset = phdr.p_vaddr & PGMASK;
    					uint32_t read_bytes, zero_bytes;
    					if (phdr.p_filesz > 0) {
    						/* Normal segment.
    						 * Read initial part from disk and zero the rest. */
    						read_bytes = page_offset + phdr.p_filesz;
    						zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
    								- read_bytes);
    					} else {
    						/* Entirely zero.
    						 * Don't read anything from disk. */
    						read_bytes = 0;
    						zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
    					}
    					if (!load_segment (file, file_page, (void *) mem_page,
    								read_bytes, zero_bytes, writable))
    						goto done;
    				}
    				else
    					goto done;
    				break;
    		}
    	}
    
    	/* Set up stack. */
    	if (!setup_stack (if_))
    		goto done;
    
    	/* Start address. */
    	if_->rip = ehdr.e_entry;
    
    	/* TODO: Your code goes here.
    	 * TODO: Implement argument passing (see project2/argument_passing.html). */
    
    	success = true;
    
    done:
    	/* We arrive here whether the load is successful or not. */
    	file_close (file);
    	return success;
    }
    ```

------

# Argument Passing ì¸ìì „ë‹¬(ì›”ìš”ì¼)

- í•´ë‹¹í•¨ìˆ˜ë¥¼ ìˆ˜í–‰í•˜ëŠ” ì»¤ë„ìŠ¤ë ˆë“œ ìƒì„± - ì´ë¯¸ ë˜ì–´ìˆìŒ

    : pintOSì—ì„œ 64bitë¡œ ë°”ë€Œë©´ì„œ tid_t thread_create()í•¨ìˆ˜ ì•ˆì— ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œëœ ì¤„ì´ defaultë¡œ ì¶”ê°€ë˜ì—ˆë‹¤. í•´ë‹¹ ë‚´ìš©ì€ struct threadì•ˆì— ì„ ì–¸ë˜ì–´ ìˆëŠ” `struct intr_frame tf`êµ¬ì¡°ì²´ ì•ˆì— ê°’ì„ ì´ˆê¸°í™” í•´ì£¼ëŠ” ë‚´ìš©ì´ë‹¤.

    - **interrupt frame** ì»¤ë„ ìŠ¤íƒì— ì €ì¥ ì–´ì…ˆë¸”ë¦¬ì–´

        <aside> ğŸ’¡ **interrupt frameì€ ì»¤ë„ ìŠ¤íƒì— ì €ì¥**ë©ë‹ˆë‹¤. ì¸í„°ëŸ½íŠ¸ ë°œìƒ ì‹œ í˜„ì¬ ìˆ˜í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ì˜ ìƒíƒœë¥¼ ë³´ì¡´í•˜ê¸° ìœ„í•´ **ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ê°€ ìˆ˜í–‰ë˜ê¸° ì „ì— ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„ì´ ì»¤ë„ ìŠ¤íƒì— ì €ì¥**ë©ë‹ˆë‹¤. ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ëŠ” ì»¤ë„ ëª¨ë“œì—ì„œ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì— ì»¤ë„ ìŠ¤íƒì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ë©´ í˜„ì¬ ì‚¬ìš©ì ëª¨ë“œì—ì„œ ìˆ˜í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ì˜ ìƒíƒœê°€ ì»¤ë„ ìŠ¤íƒì— ì €ì¥ë˜ê³ , ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì—ì„œ í•´ë‹¹ ìƒíƒœë¥¼ ë³µì›í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

        </aside>

        threads/intr-stubs.S

        ```c
        #include "threads/loader.h"
        
        /* Main interrupt entry point.
        
           An internal or external interrupt starts in one of the
           intrNN_stub routines, which push the `struct intr_frame'
           frame_pointer, error_code, and vec_no members on the stack,
           then jump here.
        
           We save the rest of the `struct intr_frame' members to the
           stack, set up some registers as needed by the kernel, and then
           call intr_handler(), which actually handles the interrupt.
        */
        .section .text
        .func intr_entry
        intr_entry:
        	/* Save caller's registers. */
        	subq $16,%rsp
        	movw %ds,8(%rsp)
        	movw %es,0(%rsp)
        	subq $120,%rsp
        	movq %rax,112(%rsp)
        	movq %rbx,104(%rsp)
        	movq %rcx,96(%rsp)
        	movq %rdx,88(%rsp)
        	movq %rbp,80(%rsp)
        	movq %rdi,72(%rsp)
        	movq %rsi,64(%rsp)
        	movq %r8,56(%rsp)
        	movq %r9,48(%rsp)
        	movq %r10,40(%rsp)
        	movq %r11,32(%rsp)
        	movq %r12,24(%rsp)
        	movq %r13,16(%rsp)
        	movq %r14,8(%rsp)
        	movq %r15,0(%rsp)
        	cld			/* String instructions go upward. */
        	movq $SEL_KDSEG, %rax
        	movw %ax, %ds
        	movw %ax, %es
        	movw %ax, %ss
        	movw %ax, %fs
        	movw %ax, %gs
        	movq %rsp,%rdi
        	call intr_handler
        	movq 0(%rsp), %r15
        	movq 8(%rsp), %r14
        	movq 16(%rsp), %r13
        	movq 24(%rsp), %r12
        	movq 32(%rsp), %r11
        	movq 40(%rsp), %r10
        	movq 48(%rsp), %r9
        	movq 56(%rsp), %r8
        	movq 64(%rsp), %rsi
        	movq 72(%rsp), %rdi
        	movq 80(%rsp), %rbp
        	movq 88(%rsp), %rdx
        	movq 96(%rsp), %rcx
        	movq 104(%rsp), %rbx
        	movq 112(%rsp), %rax
        	addq $120, %rsp
        	movw 8(%rsp), %ds
        	movw (%rsp), %es
        	addq $32, %rsp
        	iretq
        .endfunc
        
        /* Interrupt stubs.
        
           This defines 256 fragments of code, named `intr00_stub'
           through `intrff_stub', each of which is used as the entry
           point for the corresponding interrupt vector.  It also puts
           the address of each of these functions in the correct spot in
           `intr_stubs', an array of function pointers.
        
           Most of the stubs do this:
        
                1. Push %ebp on the stack (frame_pointer in `struct intr_frame').
        
                2. Push 0 on the stack (error_code).
        
                3. Push the interrupt number on the stack (vec_no).
        
           The CPU pushes an extra "error code" on the stack for a few
           interrupts.  Because we want %ebp to be where the error code
           is, we follow a different path:
        
                1. Push a duplicate copy of the error code on the stack.
        
                2. Replace the original copy of the error code by %ebp.
        
                3. Push the interrupt number on the stack. */
        
        /* This implements steps 1 and 2, described above, in the common
           case where we just push a 0 error code. */
        #define zero pushq $0;
        
        /* This implements steps 1 and 2, described above, in the case
           where the CPU already pushed an error code. */
        #define REAL
        
        .section .data
        .globl intr_stubs
        intr_stubs:
        
        /* Emits a stub for interrupt vector NUMBER.
           TYPE is `zero', for the case where we push a 0 error code,
           or `REAL', if the CPU pushes an error code for us. */
        #define STUB(NUMBER, TYPE)                      \\
        .section .text;                                  \\
        .globl intr##NUMBER##_stub;                     \\
        .func intr##NUMBER##_stub;			\\
        intr##NUMBER##_stub:                            \\
        	TYPE;                                   \\
        	push $0x##NUMBER;                       \\
        	jmp intr_entry;                         \\
        .endfunc; \\
        .section .data; \\
        .quad intr##NUMBER##_stub;
        
        /* All the stubs. */
        STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
        STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
        STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
        STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
        
        STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
        STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
        STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
        STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
        
        STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
        STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
        STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
        STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
        
        STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
        STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
        STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
        STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
        
        STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
        STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
        STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
        STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
        
        STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
        STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
        STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
        STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
        
        STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
        STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
        STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
        STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
        
        STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
        STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
        STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
        STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
        
        STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
        STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
        STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
        STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
        
        STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
        STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
        STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
        STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
        
        STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
        STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
        STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
        STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
        
        STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
        STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
        STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
        STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
        
        STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
        STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
        STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
        STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
        
        STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
        STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
        STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
        STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
        
        STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
        STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
        STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
        STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
        
        STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
        STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
        STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
        STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
        ```

    ```c
    tid_t thread_create(const char *name, int priority,
    					thread_func *function, void *aux)
    {
    	struct thread *t;
    	tid_t tid;
    	
    	ASSERT(function != NULL);
    
    	t = palloc_get_page(PAL_ZERO); /* í˜ì´ì§€í• ë‹¹*/
    	if (t == NULL)
    		return TID_ERROR;
    
    	init_thread(t, name, priority); /* thread êµ¬ì¡°ì²´ ì´ˆê¸°í™”*/
    	tid = t->tid = allocate_tid();	/* tidí• ë‹¹*/
    
    	t->tf.rip = (uintptr_t)kernel_thread;
    	t->tf.R.rdi = (uint64_t)function;
    	t->tf.R.rsi = (uint64_t)aux;
    	t->tf.ds = SEL_KDSEG;
    	t->tf.es = SEL_KDSEG;
    	t->tf.ss = SEL_KDSEG;
    	t->tf.cs = SEL_KCSEG;
    	t->tf.eflags = FLAG_IF;
    
    	thread_unblock(t); // të¥¼ ready listì— ì¶”ê°€í•¨.
    
    	test_max_priority(); // ì¤€ì½” ì—¬ê¸° ë¹„êµ, yield ë‹¤ìˆìœ¼ë‹ˆê¹Œ
    
    	return tid;
    }
    ```

- í”„ë¡œê·¸ë¨ì„ ë©”ëª¨ë¦¬ì— ì ì¬í•˜ê³  ì‹¤í–‰í•˜ëŠ”í•¨ìˆ˜ - ì´ë¯¸ ë˜ì–´ìˆìŒ

    :process_exec()í•¨ìˆ˜ì•ˆì— ì´ë¯¸ load()í•¨ìˆ˜ê°€ ì í˜€ìˆìŒ

    - userprog/process.c/process_exec()

        ```c
        int
        process_exec (void *f_name) {
        	char *file_name = f_name;
        	bool success;
        
        	/* We cannot use the intr_frame in the thread structure.
        	 * This is because when current thread rescheduled,
        	 * it stores the execution information to the member. */
        	struct intr_frame _if;
        	_if.ds = _if.es = _if.ss = SEL_UDSEG;
        	_if.cs = SEL_UCSEG;
        	_if.eflags = FLAG_IF | FLAG_MBS;
        
        	/* We first kill the current context */
        	process_cleanup ();
        
        	/* And then load the binary */
        	success = load (file_name, &_if);
        
        	/* If load failed, quit. */
        	palloc_free_page (file_name);
        	if (!success)
        		return -1;
        
        	/* Start switched process. */
        	do_iret (&_if);
        	NOT_REACHED ();
        }
        ```

        - do_iret()

            **`do_iret()`** í•¨ìˆ˜ëŠ” ì´ì „ì— ì¸í„°ëŸ½íŠ¸ë‚˜ ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— ì €ì¥ëœ ë ˆì§€ìŠ¤í„° ê°’ë“¤ì„ ìŠ¤íƒì—ì„œ ë³µì›í•˜ê³ , **`IRET`** ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ì—¬ ë³µê·€í•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ì»¤ë„ ë‚´ë¶€ì—ì„œ ì‚¬ìš©ë˜ë©°, ì¼ë°˜ ì‚¬ìš©ì í”„ë¡œê·¸ë¨ì—ì„œ ì§ì ‘ í˜¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

        - esp: ìŠ¤íƒ í¬ì¸í„° ì£¼ì†Œ (64bitì—ì„œëŠ” rsp)

        - eip: ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘ ì£¼ì†Œ ((64bitì—ì„œëŠ” rip)

            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d2dc31ae-600f-4493-b9a3-bec3e27ecce5/Untitled.png)

    - load()

        ```c
        static bool
        load (const char *file_name, struct intr_frame *if_) {
        	struct thread *t = thread_current ();
        	struct ELF ehdr;
        	struct file *file = NULL;
        	off_t file_ofs;
        	bool success = false;
        	int i;
        
        	/* Allocate and activate page directory. */
        	t->pml4 = pml4_create ();
        	if (t->pml4 == NULL)
        		goto done;
        	process_activate (thread_current ());
        
        	/* Open executable file. */
        	file = filesys_open (file_name);
        	if (file == NULL) {
        		printf ("load: %s: open failed\\n", file_name);
        		goto done;
        	}
        
        	/* Read and verify executable header. */
        	if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
        			|| memcmp (ehdr.e_ident, "\\177ELF\\2\\1\\1", 7)
        			|| ehdr.e_type != 2
        			|| ehdr.e_machine != 0x3E // amd64
        			|| ehdr.e_version != 1
        			|| ehdr.e_phentsize != sizeof (struct Phdr)
        			|| ehdr.e_phnum > 1024) {
        		printf ("load: %s: error loading executable\\n", file_name);
        		goto done;
        	}
        
        	/* Read program headers. */
        	file_ofs = ehdr.e_phoff;
        	for (i = 0; i < ehdr.e_phnum; i++) {
        		struct Phdr phdr;
        
        		if (file_ofs < 0 || file_ofs > file_length (file))
        			goto done;
        		file_seek (file, file_ofs);
        
        		if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
        			goto done;
        		file_ofs += sizeof phdr;
        		switch (phdr.p_type) {
        			case PT_NULL:
        			case PT_NOTE:
        			case PT_PHDR:
        			case PT_STACK:
        			default:
        				/* Ignore this segment. */
        				break;
        			case PT_DYNAMIC:
        			case PT_INTERP:
        			case PT_SHLIB:
        				goto done;
        			case PT_LOAD:
        				if (validate_segment (&phdr, file)) {
        					bool writable = (phdr.p_flags & PF_W) != 0;
        					uint64_t file_page = phdr.p_offset & ~PGMASK;
        					uint64_t mem_page = phdr.p_vaddr & ~PGMASK;
        					uint64_t page_offset = phdr.p_vaddr & PGMASK;
        					uint32_t read_bytes, zero_bytes;
        					if (phdr.p_filesz > 0) {
        						/* Normal segment.
        						 * Read initial part from disk and zero the rest. */
        						read_bytes = page_offset + phdr.p_filesz;
        						zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
        								- read_bytes);
        					} else {
        						/* Entirely zero.
        						 * Don't read anything from disk. */
        						read_bytes = 0;
        						zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
        					}
        					if (!load_segment (file, file_page, (void *) mem_page,
        								read_bytes, zero_bytes, writable))
        						goto done;
        				}
        				else
        					goto done;
        				break;
        		}
        	}
        
        	/* Set up stack. */
        	if (!setup_stack (if_))
        		goto done;
        
        	/* Start address. */
        	if_->rip = ehdr.e_entry;
        
        	/* TODO: Your code goes here.
        	 * TODO: Implement argument passing (see project2/argument_passing.html). */
        
        	success = true;
        
        done:
        	/* We arrive here whether the load is successful or not. */
        	file_close (file);
        	return success;
        }
        ```

- ë¬¸ìì—´ì„ íŒŒì‹±í•˜ê³  ìœ ì €ìŠ¤íƒì— ì¸ìê°’ì´ ì €ì¥ë˜ë„ë¡ ìˆ˜ì •

    - process_create_initd()í•¨ìˆ˜ ìˆ˜ì •

        file_name ë¬¸ìì—´ì„ íŒŒì‹±

        ì²«ë²ˆì§¸í† í°ì„ thread_create()í•¨ìˆ˜ì— ìŠ¤ë ˆë“œ ì´ë¦„ìœ¼ë¡œ ì „ë‹¬

        - êµ¬í˜„ ì½”ë“œ

            ```c
            /* = process_execute()í•¨ìˆ˜
            ì£¼ì–´ì§„ file_nameì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ initd ìŠ¤ë ˆë“œë¥¼ ë§Œë“¤ê³ , ì´ ìŠ¤ë ˆë“œì—ê²Œ file_nameê³¼ fn_copyë¥¼ ì „ë‹¬í•˜ëŠ” í•¨ìˆ˜ */
            tid_t process_create_initd (const char *file_name) {
            	char *fn_copy, *save_ptr;
            	tid_t tid;
            
            	/* Make a copy of FILE_NAME.
            	 * Otherwise there's a race between the caller and load(). */
            	fn_copy = palloc_get_page(0);
            	if (fn_copy == NULL)
            		return TID_ERROR;
            	strlcpy(fn_copy, file_name, PGSIZE);
            
            	
            	/*-------week09 ì¶”ê°€---------*/
            	strtok_r(file_name, " ", &save_ptr);
            	/*-------week09 ì¶”ê°€ ë---------*/
            	/* Create a new thread to execute FILE_NAME. */
            	tid = thread_create(file_name, PRI_DEFAULT, initd, fn_copy);
            	if (tid == TID_ERROR)
            		palloc_free_page(fn_copy);
            
            	return tid;
            }
            ```

    - process_exec()í•¨ìˆ˜ ìˆ˜ì •

        ë­‰í……ì´ â€œargs-single oneargâ€ë¥¼ ìë¥´ê¸° ìœ„í•´ â€œ â€œë‹¨ìœ„ë¡œ ìë¥¸ tokenì„ values[i]ì— ì°¨ê³¡ì°¨ê³¡ ì €ì¥. values[]ì™€ ëª‡ iê¹Œì§€ ì €ì¥ë˜ì—ˆëŠ”ì§€ë¥¼ argument_stackìœ¼ë¡œ ë„˜ê¸°ê³ , &_ifì— ê·¸ ê°’ë“¤ì„ ì €ì¥í•˜ì—¬ ë°˜í™˜í•˜ì.

        â†’file_name ë¬¸ìì—´ì„ íŒŒì‹± : ì¸ìë“¤ì„ í† í°í™”(strtok_r(), string.h) ë° í† í°ì˜ ê°œìˆ˜ ê³„ì‚° , argument_stack() í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ìŠ¤íƒì— í† í°ë“¤ì„ ì €ì¥

        - êµ¬í˜„ì½”ë“œ

            ```c
            /* Switch the current execution context to the f_name.
             * Returns -1 on fail. */
            /* = start_process() 
            í”„ë¡œì„¸ìŠ¤ì˜ ì‹¤í–‰ íŒŒì¼ì„ ë¶ˆëŸ¬ì™€ ì¸ìê°’ì„ ì²˜ë¦¬í•˜ê³  ì‹¤í–‰ì‹œí‚¤ëŠ” í•¨ìˆ˜*/
            int process_exec (void *f_name) {
            	char *file_name = f_name;
            	bool success;
            
            	struct intr_frame _if;
            	_if.ds = _if.es = _if.ss = SEL_UDSEG;
            	_if.cs = SEL_UCSEG;
            	_if.eflags = FLAG_IF | FLAG_MBS;
            	/* ----------week09 ì¶”ê°€-------------*/
            	char *token, *save_ptr;
            	char *values[128];
            	int i = 0;
            	/* ----------week09 ì¶”ê°€-------------*/
            	/* We first kill the current context */
            	process_cleanup ();
            
            	/* And then load the binary */
            	success = load (file_name, &_if);
            
            	/* If load failed, quit. */
            	palloc_free_page (file_name);
            	if (!success)
            		return -1;
            
            	/* ----------week09 ì¶”ê°€-------------*/
            	token = strtok_r(f_name, " ", &save_ptr); // f_name ë¬¸ìì—´ì„ ê³µë°±(" ")ìœ¼ë¡œ ë¶„ë¦¬í•˜ì—¬ í† í°ìœ¼ë¡œ ë§Œë“¤ê³ , token ë³€ìˆ˜ì— ì €ì¥
            	values[i] = token;						  // ë¶„ë¦¬í•œ í† í°ì„ values ë°°ì—´ì— ì €ì¥
            	while (token != NULL)
            	{
            		token = strtok_r(NULL, " ", &save_ptr);
            		i++;
            		values[i] = token;
            	}
            
            	argument_stack(values,i, &_if); // ìŠ¤íƒì— í•¨ìˆ˜ ì¸ìë¥¼ ì €ì¥í•˜ëŠ” í•¨ìˆ˜ í˜¸ì¶œ
            
            	hex_dump(_if.rsp, _if.rsp, USER_STACK - _if.rsp, true);
            	/* ----------week09 ì¶”ê°€ ë-------------*/
            
            	/* Start switched process. */
            	do_iret (&_if);
            	NOT_REACHED ();
            }
            ```

    - void argument_stack() í•¨ìˆ˜ êµ¬í˜„

        ```c
        void argument_stack(char **argv, int argc, struct intr_frame *if_)
        {
        	char *value_address[128];
        	/* ìŠ¤íƒì˜ í™•ì¥ì€ ìœ„->ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ì§„í–‰ë˜ë¯€ë¡œ, argvì˜ ê¸¸ì´ë§Œí¼ í¬ì¸í„°ë¥¼ ë‚´ë¦° ë’¤ ë©”ëª¨ë¦¬ ì‚¬ìš©*/
        	for (int i = argc - 1; i >= 0; i--)
        	{
        		int parse_len = strlen(argv[i]) +EOL; /* ë‚´ë ¤ì•¼í•˜ëŠ” ê¸¸ì´ êµ¬í•˜ê¸° arg[ë]ë¶€í„° ì ê¸° ex:arg4->arg3->...*/
        		if_->rsp -= (parse_len);			  /* rspë¥¼ êµ¬í•œ ê¸¸ì´ë§Œí¼ ë‚´ë¦¼*/
        		memcpy(if_->rsp, argv[i], parse_len); /* stackì— ë°ì´í„° í¬ì¸í„° ì ê¸°*/
        		value_address[i] = if_->rsp;		  /* í•´ë‹¹ arg[i]ì˜ í¬ì¸í„° ì£¼ì†Œ ì‹œì‘ì ì„ value_addressì— ì €ì¥*/
        	}
        	// ìŠ¤íƒ í¬ì¸í„° rspê°€ 8ì˜ ë°°ìˆ˜ê°€ ë  ë•Œê¹Œì§€ 0ìœ¼ë¡œ ì±„ìš°ê¸°
        	while (if_->rsp % SAU != 0) 
        	{
        		if_->rsp--;
        		memset(if_->rsp, 0, sizeof(uint8_t));
        	}
        	// ì¸ìì˜ í¬ì¸í„° ì£¼ì†Œë¥¼ ì €ì¥í•  í¬ì¸í„° ë°°ì—´ value_addressë¥¼ ì—­ìˆœìœ¼ë¡œ ìŠ¤íƒì— ì €ì¥
        	for (int i = argc; i >= 0; i--)
        	{
        		if_->rsp -= SAU; // ìŠ¤íƒ í¬ì¸í„°ë¥¼ 8ë°”ì´íŠ¸ ë§Œí¼ ë‚´ë¦¬ê¸°
        		if (i == argc)	 // ë§Œì•½ í˜„ì¬ ì¸ë±ìŠ¤ê°€ argcì™€ ê°™ë‹¤ë©´, ì¦‰ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë¼ë©´ NULL ê°’ì„ ì €ì¥
        			memset(if_->rsp, 0, sizeof(char **));
        		else // ë¬¸ìì—´ì˜ ì‹œì‘ í¬ì¸í„°ê°€ ì €ì¥ë˜ì–´ì•¼ í•œë‹¤ë©´ ê·¸ ì£¼ì†Œê°’ì„ ì €ì¥
        		{
        			memcpy(if_->rsp, &value_address[i], sizeof(char **));
        		}
        	}
        	// ìŠ¤íƒ í¬ì¸í„° rspë¥¼ ë‹¤ì‹œ 8ë°”ì´íŠ¸ ë§Œí¼ ë‚´ë¦¬ê³ , ë¦¬í„´ ì£¼ì†Œë¥¼ ì €ì¥í•  ê³µê°„ì„ ë§Œë“¤ê¸°
        	if_->rsp -= sizeof(void *);
        	memset(if_->rsp, 0, sizeof(void *)); // ë¦¬í„´ ì£¼ì†Œë¥¼ ì €ì¥í•  ê³µê°„ì— 0ìœ¼ë¡œ ì´ˆê¸°í™”
        
        	if_->R.rdi = argc; // ë ˆì§€ìŠ¤í„°ì— ì¸ì ê°œìˆ˜ë¥¼ ì €ì¥
        	if_->R.rsi = if_->rsp + SAU; // ë ˆì§€ìŠ¤í„°ì— ìŠ¤íƒì— ì €ì¥ëœ ì¸ìë“¤ì˜ ì£¼ì†Œë¥¼ ì €ì¥
        }
        ```

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/553d32fa-3c63-431f-aa45-c07fcd772c36/Untitled.png)

        ìœ„ ê·¸ë¦¼ì„ êµ¬í˜„í•˜ëŠ” í•¨ìˆ˜

        ì´ë¯¸ì§€ì™€ ê°™ì´ parsingí•œ ì…ë ¥ ë¬¸ìì—´ì„ stackì— ì°¨ê³¡ì°¨ê³¡ ìŒ“ê³ , interrupt frameì˜ rsp(32bit ì»´í“¨í„°ì—ì„œëŠ” esp)ë¥¼ ê°€ë¥´í‚¤ëŠ” í¬ì¸í„°ê°€ stack topì— ìœ„ì¹˜í•˜ë„ë¡ ì½”ë“œë¥¼ êµ¬í˜„í•˜ì.

    - ì‚¬ìš©í•œ í•¨ìˆ˜

        lib/string.c/strtok_r()

        ```c
        char *
        strtok_r (char *s, const char *delimiters, char **save_ptr) {
        	char *token;
        
        	ASSERT (delimiters != NULL);
        	ASSERT (save_ptr != NULL);
        
        	/* If S is nonnull, start from it.
        	   If S is null, start from saved position. */
        	if (s == NULL)
        		s = *save_ptr;
        	ASSERT (s != NULL);
        
        	/* Skip any DELIMITERS at our current position. */
        	while (strchr (delimiters, *s) != NULL) {
        		/* strchr() will always return nonnull if we're searching
        		   for a null byte, because every string contains a null
        		   byte (at the end). */
        		if (*s == '\\0') {
        			*save_ptr = s;
        			return NULL;
        		}
        
        		s++;
        	}
        
        	/* Skip any non-DELIMITERS up to the end of the string. */
        	token = s;
        	while (strchr (delimiters, *s) == NULL)
        		s++;
        	if (*s != '\\0') {
        		*s = '\\0';
        		*save_ptr = s + 1;
        	} else
        		*save_ptr = s;
        	return token;
        }
        ```

- pintOS ë””ë²„ê¹…í•¨ìˆ˜ hex_dump() ì‚¬ìš©ë²•

    - ìˆ˜ì •í•´ì•¼ë˜ëŠ” ì½”ë“œ

        ```c
        int
        process_wait (tid_t child_tid UNUSED) {
        	/* XXX: Hint) The pintos exit if process_wait (initd), we recommend you
        	 * XXX:       to add infinite loop here before
        	 * XXX:       implementing the process_wait. */
        	while(1){
        		
        	}
        	return -1;
        }
        ```

    - í…ŒìŠ¤íŠ¸ ëª…ë ¹ì–´

        `pintos -T 20 --fs-disk=10 -p tests/userprog/args-multiple:args-multiple -- -q -f run 'args-multiple arg1 hey2 hw3 til4â€™`

    - ê²°ê³¼

        ```c
        qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]
        Kernel command line: -q -f put args-multiple run 'args-multiple arg1 hey2 hw3 til4'
        0 ~ 9fc00 1
        100000 ~ ffe0000 1
        Pintos booting with: 
                base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
                ext_mem: 0x100000 ~ 0xffe0000 (Usable: 260,992 kB)
        Calibrating timer...  156,876,800 loops/s.
        hd0:0: detected 313 sector (156 kB) disk, model "QEMU HARDDISK", serial "QM00001"
        hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
        hd1:0: detected 102 sector (51 kB) disk, model "QEMU HARDDISK", serial "QM00003"
        Formatting file system...done.
        Boot complete.
        Putting 'args-multiple' into the file system...
        Executing 'args-multiple arg1 hey2 hw3 til4':
        000000004747ffa0  00 00 00 00 00 00 00 00-df ff 47 47 00 00 00 00 |..........GG....|
        000000004747ffb0  ed ff 47 47 00 00 00 00-f2 ff 47 47 00 00 00 00 |..GG......GG....|
        000000004747ffc0  f7 ff 47 47 00 00 00 00-fb ff 47 47 00 00 00 00 |..GG......GG....|
        000000004747ffd0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 61 |...............a|
        000000004747ffe0  72 67 73 2d 6d 75 6c 74-69 70 6c 65 00 61 72 67 |rgs-multiple.arg|
        000000004747fff0  31 00 68 65 79 32 00 68-77 33 00 74 69 6c 34 00 |1.hey2.hw3.til4.|
        system call!
        ```

# User Memory Access ìœ ì € ë©”ëª¨ë¦¬ ì ‘ê·¼(í™”ìš”ì¼)

- í•´ì•¼í•  ì¼

    - ì‹œìŠ¤í…œì½œ êµ¬í˜„ ì „, ìœ ì €ê°€ ì˜ëª»ëœ ê²½ë¡œì— ì ‘ê·¼í–ˆì„ ë•Œ í”„ë¡œê·¸ë¨ ì¢…ë£Œ
    - ì¦‰, ìœ ì €ê°€ ë³´ë‚¸ í¬ì¸í„°ê°€ ìœ íš¨í•œì§€ ì²´í¬(ì»¤ë„ì„ ê°€ë¦¬í‚¤ê±°ë‚˜ í• ë‹¹ë˜ì§€ ì•Šì€ ë©”ëª¨ë¦¬ë¥¼ ê°€ë¦¬í‚¤ë©´ ì•ˆë¨)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e40a0d18-1005-47c4-9b91-82b9b3cd374d/Untitled.png)

- kernel mode â†” user mode ë³€í™˜ method

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/abee797d-db37-4ce8-a8fb-a90b0f200628/Untitled.png)

    - process_exec()

        userprog/process.c

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/212d25d8-9306-4c05-9d0f-c29c73d588fe/Untitled.png)

        ```c
        int process_exec(void *f_name)
        {
        	char *file_name = f_name;
        	bool success;
        	// memcpy(values, file_name, strlen(file_name) + 1);
        
        	/* We cannot use the intr_frame in the thread structure.
        	 * This is because when current thread rescheduled,
        	 * it stores the execution information to the member. */
        /* ë¶€íŒ… í›„ kernelë‹¨ì—ì„œ ëŒì•„ê°€ë˜ processë‚´ìš©ì„ userí•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³  
        kernelë‹¨ìœ¼ë¡œ ë³µê·€í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” êµ¬ì¡°ì²´,
        interrupt_frameìœ¼ë¡œ ê¸°ì¡´ì— kernel processì˜ ì‹¤í–‰ëœ ì •ë³´ë¥¼ ì €ì¥ */
        	struct intr_frame _if;
        	_if.ds = _if.es = _if.ss = SEL_UDSEG;
        	_if.cs = SEL_UCSEG;
        	_if.eflags = FLAG_IF | FLAG_MBS;
        
        	/* We first kill the current context */
        	process_cleanup();
        
        	char *token, *save_ptr;
        	char *values[128];
        	int i = 0;
        
        	token = strtok_r(f_name, " ", &save_ptr);
        	values[i] = token;
        
        	while (token != NULL)
        	{
        		token = strtok_r(NULL, " ", &save_ptr);
        		i++;
        		values[i] = token;
        	}
        
        	/* And then load the binary */
        	success = load(file_name, &_if);
        
        	/* If load failed, quit. */
        	if (!success)
        	{
        		return -1;
        	}
        
        	/* ìœ ì €ìŠ¤íƒì— ì¸ì ì €ì¥ */
        	argument_stack(values, i, &_if);
        	// hex_dump(_if.rsp, _if.rsp, USER_STACK - _if.rsp, true);
        
        	palloc_free_page(file_name);
        
        	/* Start switched process. */
        	do_iret(&_if);
        	NOT_REACHED();
        }
        ```

    - syscall_init(void)

        <aside> ğŸ’¡ **`syscall_init()`** í•¨ìˆ˜ëŠ” ì‹œìŠ¤í…œ ì½œì„ ì´ˆê¸°í™”í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.

        ì²« ë²ˆì§¸ë¡œ, **`write_msr()`** í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ **`MSR_STAR`** ë ˆì§€ìŠ¤í„°ì— ê°’ì„ ì“°ë©´ì„œ, ìœ ì € ëª¨ë“œì™€ ì»¤ë„ ëª¨ë“œì—ì„œì˜ ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸ì™€ ìŠ¤íƒ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. **`SEL_UCSEG`**ëŠ” ìœ ì € ëª¨ë“œ ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸, **`SEL_KCSEG`**ëŠ” ì»¤ë„ ëª¨ë“œ ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

        ë‘ ë²ˆì§¸ë¡œ, **`MSR_LSTAR`** ë ˆì§€ìŠ¤í„°ì— **`syscall_entry`** í•¨ìˆ˜ì˜ ì£¼ì†Œë¥¼ ì“°ë©´ì„œ, **`syscall_entry()`** í•¨ìˆ˜ë¥¼ ì‹œìŠ¤í…œ ì½œ í•¸ë“¤ëŸ¬ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.

        ì„¸ ë²ˆì§¸ë¡œ, **`MSR_SYSCALL_MASK`** ë ˆì§€ìŠ¤í„°ì—ëŠ” **`syscall_entry()`** í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ ì¸í„°ëŸ½íŠ¸ê°€ ë¹„í™œì„±í™”ë˜ë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤. ì´ëŠ” **`syscall_entry()`** í•¨ìˆ˜ì—ì„œ ìœ ì € ëª¨ë“œì—ì„œ ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜í•  ë•Œ, ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤. ì´ ë•Œ **`FLAG_IF`**ë¥¼ ì„¤ì •í•˜ë©´ ì¸í„°ëŸ½íŠ¸ê°€ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.

        ë”°ë¼ì„œ **`syscall_init()`** í•¨ìˆ˜ëŠ” ì‹œìŠ¤í…œ ì½œì˜ í˜¸ì¶œ ë° ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¤€ë¹„ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

        </aside>

        <aside> ğŸ’¡  # ì£¼ì„ ë‚´ìš© **`FLAG_FL`**ì€ **`EFLAGS`** ë ˆì§€ìŠ¤í„°ì˜ interrupt-enable flagì´ë©°, ì´ í”Œë˜ê·¸ë¥¼ 0ìœ¼ë¡œ ë§ˆìŠ¤í‚¹í•¨ìœ¼ë¡œì¨ ì¸í„°ëŸ½íŠ¸ë¥¼ ë¹„í™œì„±í™”í•˜ê³  ì‹œìŠ¤í…œ ì½œì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ìœ ì € ëª¨ë“œ ìŠ¤íƒì„ ì»¤ë„ ëª¨ë“œ ìŠ¤íƒìœ¼ë¡œ êµì²´í•  ë•Œê¹Œì§€ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤. ë”°ë¼ì„œ **`syscall_entry`**ì—ì„œ ìœ ì € ëª¨ë“œì—ì„œ ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜ë  ë•Œ, interrupt-enable flagê°€ 1ë¡œ ì„¤ì •ë˜ì–´ ì¸í„°ëŸ½íŠ¸ê°€ í™œì„±í™”ë©ë‹ˆë‹¤.

        </aside>

        ```c
        void syscall_init(void) {
        	write_msr(MSR_STAR, ((uint64_t)SEL_UCSEG - 0x10) << 48  |
        			((uint64_t)SEL_KCSEG) << 32);
        	write_msr(MSR_LSTAR, (uint64_t) syscall_entry);
        
        	/* The interrupt service rountine should not serve any interrupts
        	 * until the syscall_entry swaps the userland stack to the kernel
        	 * mode stack. Therefore, we masked the FLAG_FL. */
        	write_msr(MSR_SYSCALL_MASK,
        			FLAG_IF | FLAG_TF | FLAG_DF | FLAG_IOPL | FLAG_AC | FLAG_NT);
        }
        ```

    - syscall_entry

        <aside> ğŸ’¡ x86-64 ì•„í‚¤í…ì²˜ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì‹œìŠ¤í…œ ì½œ ì²˜ë¦¬ ê³¼ì •ì„ êµ¬í˜„í•˜ëŠ” ì½”ë“œì…ë‹ˆë‹¤.

        **ì‹œìŠ¤í…œ ì½œì„ í˜¸ì¶œí•œ ìœ ì € í”„ë¡œê·¸ë¨ì€ `syscall` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•´ ìœ ì € ëª¨ë“œì—ì„œ ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜**í•©ë‹ˆë‹¤. ì´ë•Œ, **`syscall_entry`** ë ˆì´ë¸”ì´ ìˆëŠ” ì½”ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤.

        ì´ ì½”ë“œëŠ” ë¨¼ì € **`syscall_entry`** í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, í˜„ì¬ **ìœ ì € ëª¨ë“œ ìŠ¤íƒì— ìˆëŠ” ê°’ë“¤ì„ ì»¤ë„ ëª¨ë“œ ìŠ¤íƒìœ¼ë¡œ ë³µì‚¬í•˜ê³ , ì¤‘ìš”í•œ ë ˆì§€ìŠ¤í„° ê°’ì„ ë°±ì—…**í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì´í›„ì—, ì¸í„°ëŸ½íŠ¸ í”Œë˜ê·¸ë¥¼ ë¹„íŠ¸ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ í´ë¦¬ì–´í•©ë‹ˆë‹¤.

        ê·¸ ë‹¤ìŒì—, **`syscall_handler`** í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ”ë°, í•´ë‹¹ í•¨ìˆ˜ì—ì„œëŠ” ì¸ì ê°’ë“¤ì„ ê²€ì‚¬í•˜ê³  í•´ë‹¹ ì‹œìŠ¤í…œ ì½œì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

        **ì‹œìŠ¤í…œ ì½œ ì²˜ë¦¬ í›„ì—ëŠ” ì´ì „ì˜ ì¸í„°ëŸ½íŠ¸ ìƒíƒœë¥¼ ë³µêµ¬í•˜ê³ , ìœ ì € ëª¨ë“œë¡œ ë³µê·€**í•©ë‹ˆë‹¤.

        ì´ ì½”ë“œëŠ” **`loader.h`**ì— ì •ì˜ëœ **`struct intr_frame`** êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•´ ìœ ì € ëª¨ë“œ ìŠ¤íƒì˜ ì¸ì ê°’ë“¤ì„ ê²€ì‚¬í•˜ê³ , ì‹œìŠ¤í…œ ì½œì„ ì²˜ë¦¬í•©ë‹ˆë‹¤. **`syscall_init`** í•¨ìˆ˜ëŠ” ì‹œìŠ¤í…œ ì½œì„ ìœ„í•œ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ë¥¼ ë“±ë¡í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.

        </aside>

        userprog/syscall-entry.S

        ```c
        #include "threads/loader.h"
        
        .text
        .globl syscall_entry
        .type syscall_entry, @function
        syscall_entry:
        	movq %rbx, temp1(%rip)
        	movq %r12, temp2(%rip)     /* callee saved registers */
        	movq %rsp, %rbx            /* Store userland rsp    */
        	movabs $tss, %r12
        	movq (%r12), %r12
        	movq 4(%r12), %rsp         /* Read ring0 rsp from the tss */
        	/* Now we are in the kernel stack */
        	push $(SEL_UDSEG)      /* if->ss */
        	push %rbx              /* if->rsp */
        	push %r11              /* if->eflags */
        	push $(SEL_UCSEG)      /* if->cs */
        	push %rcx              /* if->rip */
        	subq $16, %rsp         /* skip error_code, vec_no */
        	push $(SEL_UDSEG)      /* if->ds */
        	push $(SEL_UDSEG)      /* if->es */
        	push %rax
        	movq temp1(%rip), %rbx
        	push %rbx
        	pushq $0
        	push %rdx
        	push %rbp
        	push %rdi
        	push %rsi
        	push %r8
        	push %r9
        	push %r10
        	pushq $0 /* skip r11 */
        	movq temp2(%rip), %r12
        	push %r12
        	push %r13
        	push %r14
        	push %r15
        	movq %rsp, %rdi
        
        check_intr:
        	btsq $9, %r11          /* Check whether we recover the interrupt */
        	jnb no_sti
        	sti                    /* restore interrupt */
        no_sti:
        	movabs $syscall_handler, %r12
        	call *%r12
        	popq %r15
        	popq %r14
        	popq %r13
        	popq %r12
        	popq %r11
        	popq %r10
        	popq %r9
        	popq %r8
        	popq %rsi
        	popq %rdi
        	popq %rbp
        	popq %rdx
        	popq %rcx
        	popq %rbx
        	popq %rax
        	addq $32, %rsp
        	popq %rcx              /* if->rip */
        	addq $8, %rsp
        	popq %r11              /* if->eflags */
        	popq %rsp              /* if->rsp */
        	sysretq
        
        .section .data
        .globl temp1
        temp1:
        .quad	0
        .globl temp2
        temp2:
        .quad	0
        ```

- resister ì¢…ë¥˜ ì„¤ëª…

    [x64 ABI ê·œì¹™ | Microsoft Learn](https://learn.microsoft.com/ko-kr/cpp/build/x64-software-conventions?view=msvc-170)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7079d182-69f2-4f5f-bca1-89cd68afd5a5/Untitled.png)

    <aside> ğŸ’¡ í•„ìš”í•œ ì¸ì : 1ë²ˆì§¸ ì¸ì: %rdi // ë©”ëª¨ë¦¬ë¥¼ ì´ë™í•˜ê³  ë¹„êµí•  ë•Œ ê·¸ ëª©ì ì§€ ì£¼ì†Œ 2ë²ˆì§¸ ì¸ì: %rsi // ë©”ëª¨ë¦¬ë¥¼ ì´ë™í•˜ê³  ë¹„êµí•  ë•Œ ê·¸ ì¶œë°œì§€ ì£¼ì†Œ 3ë²ˆì§¸ ì¸ì: %rdx 4ë²ˆì§¸ ì¸ì: %r10 5ë²ˆì§¸ ì¸ì: %r8 6ë²ˆì§¸ ì¸ì: %r9

    </aside>

### check_address() êµ¬í˜„

:ì£¼ì†Œìœ íš¨ì„± ê²€ì‚¬:í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œê°€ ì‚¬ìš©ìì˜ì—­(0x8048000~0xc0000000)ì¸ì§€ í™•ì¸ â†’ ìœ ì €ì˜ì—­ì„ë²—ì–´ë‚œì˜ì—­ì¼ê²½ìš°í”„ë¡œì„¸ìŠ¤ì¢…ë£Œ(exit(-1))

- êµ¬í˜„ ì½”ë“œ

    ```c
    void check_address(const void *addr)
    {
    	/* ì£¼ì†Œê°€ NULLì´ë©´ ì˜ˆì™¸ ì²˜ë¦¬ ,ì£¼ì†Œê°€ ìœ ì € ì˜ì—­ì´ ì•„ë‹ˆë©´ ì˜ˆì™¸ ì²˜ë¦¬*/
    	if (addr == NULL || is_kernel_vaddr(addr))
    	{
    		exit(-1);
    	}
    }
    ```

    addrì˜ validation ë¯¸í¡

    ------

- ìˆ˜ì • ì½”ë“œ

    ```c
    void check_address(const void *addr)
    {
    	/* ì£¼ì†Œê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì˜ˆì™¸ ì²˜ë¦¬ ,ì£¼ì†Œê°€ ìœ ì € ì˜ì—­ì´ ì•„ë‹ˆë©´ ì˜ˆì™¸ ì²˜ë¦¬*/
    	if (addr == NULL || pml4_get_page(&thread_current()->pml4, addr) == NULL || is_kernel_vaddr(addr))
    	{
    		exit(1);
    	}
    }
    ```

- ì‚¬ìš© í•¨ìˆ˜

    threads/mmu.c

    ```c
    /* Looks up the physical address that corresponds to user virtual
     * address UADDR in pml4.  Returns the kernel virtual address
     * corresponding to that physical address, or a null pointer if
     * UADDR is unmapped. */
    void *
    pml4_get_page (uint64_t *pml4, const void *uaddr) {
    	ASSERT (is_user_vaddr (uaddr));
    
    	uint64_t *pte = pml4e_walk (pml4, (uint64_t) uaddr, 0);
    
    	if (pte && (*pte & PTE_P))
    		return ptov (PTE_ADDR (*pte)) + pg_ofs (uaddr);
    	return NULL;
    }
    ```

    ì´ í•¨ìˆ˜ëŠ” **ê°€ìƒ ì£¼ì†Œ(uaddr)ì— í•´ë‹¹í•˜ëŠ” ë¬¼ë¦¬ ì£¼ì†Œë¥¼ ì°¾ëŠ” í•¨ìˆ˜**ì…ë‹ˆë‹¤. ë¨¼ì € uaddrê°€ ìœ ì € ì˜ì—­ì˜ ì£¼ì†Œì¸ì§€ ê²€ì‚¬í•˜ê³ , PML4 í…Œì´ë¸”ì—ì„œ ê°€ìƒ ì£¼ì†Œì— ëŒ€í•œ PML4 ì—”íŠ¸ë¦¬ë¥¼ ì°¾ìŠµë‹ˆë‹¤. ì´ë•Œ, PML4 í…Œì´ë¸”ì—ì„œ ê°€ìƒ ì£¼ì†Œë¥¼ ì°¾ì•„ ê°€ë¦¬í‚¤ëŠ” í˜ì´ì§€ í…Œì´ë¸” ì—”íŠ¸ë¦¬(PTE)ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

    ë§Œì•½ í˜ì´ì§€ í…Œì´ë¸” ì—”íŠ¸ë¦¬ê°€ ìœ íš¨í•˜ê³ , í•´ë‹¹ í˜ì´ì§€ê°€ ë©”ëª¨ë¦¬ì— ì ì¬ë˜ì–´ ìˆë‹¤ë©´(pt_present) ì´ **í˜ì´ì§€ì˜ ë¬¼ë¦¬ ì£¼ì†Œë¥¼ ê³„ì‚°í•˜ê³  ë°˜í™˜**í•©ë‹ˆë‹¤. ê³„ì‚°í•  ë•ŒëŠ” ë¬¼ë¦¬ ì£¼ì†Œ = (PTE & 0x000ffffffffff000) | (uaddr & 0x0000000000000fff) ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤. ì´ë•Œ, ptov() í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ê°€ìƒ ì£¼ì†Œë¡œë¶€í„° ì»¤ë„ ì£¼ì†Œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

    ë°˜í™˜ê°’ìœ¼ë¡œëŠ” **uaddrì— í•´ë‹¹í•˜ëŠ” ë¬¼ë¦¬ ì£¼ì†Œë¥¼ ë°˜í™˜í•˜ê±°ë‚˜, í•´ë‹¹ í˜ì´ì§€ê°€ ë©”ëª¨ë¦¬ì— ì—†ê±°ë‚˜ PTEê°€ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš° NULLì„ ë°˜í™˜**í•©ë‹ˆë‹¤.

### get_argument() êµ¬í˜„â†’ í•„ìš”ì—†ìŒ

:  pintOSê°€ 64bitë¡œ ë°”ë€Œë©´ì„œ **`syscall_entry`** , **`syscall_handler`** ì½”ë“œê°€ ì¶”ê°€ë˜ì—ˆë‹¤. í•´ë‹¹ ì½”ë“œ ë•ë¶„ì— get_argument()í•¨ìˆ˜ê°™ì´ **ì‹œìŠ¤í…œ ì½œ ì¸ìë¥¼ ì»¤ë„(arg ë°°ì—´)ì— ë³µì‚¬í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•  í•„ìš”ê°€ ì—†ì–´ì¡Œë‹¤. (ë” ìì„¸í•œ ì„¤ëª…ì€ â€˜**kernel mode â†” user mode ë³€í™˜ methodâ€™ì˜ syscall_entryì •ë¦¬ ë‚´ìš©ì„ ì°¸ê³ í•´ì£¼ì„¸ìš”)

ë©‹ëª¨ë¥¼ ë•Œ êµ¬í˜„í•œ ì½”ë“œëŠ” ì•„ë˜ì—

- logic

    **ì‹œìŠ¤í…œ ì½œ ì¸ìë¥¼ ì»¤ë„(arg ë°°ì—´)ì— ë³µì‚¬**í•œë‹¤.

    **ìŠ¤íƒ í¬ì¸í„°ë¥¼ ì°¸ì¡°í•´ì„œ countë§Œí¼ ìŠ¤íƒì— ì €ì¥ëœ ì¸ìë“¤ì„ arg ë°°ì—´ë¡œ ë³µì‚¬**í•œë‹¤.

    â†’ ìŠ¤íƒì—ì„œ ì¸ìë“¤ì„ 4byte í¬ê¸°ë¡œêº¼ë‚´ì–´ argë°°ì—´ì— ìˆœì°¨ì ìœ¼ë¡œ ì €ì¥

    â†’  count ê°œìˆ˜ë§Œí¼ì˜ ì¸ìë¥¼ ìŠ¤íƒì—ì„œ ê°€ì ¸ì˜´

    ì´ ë•Œ í•´ë‹¹ ì¸ìë“¤ì´ ì €ì¥ëœ ë©”ëª¨ë¦¬ ì£¼ì†Œê°€ ìœ ì € ì˜ì—­ì¸ì§€ í™•ì¸í•œë‹¤.

- êµ¬í˜„ ì½”ë“œ

    userprog/syscall.c

    ```c
    void get_argument(void *rsp, int *arg, int count)
    {
    	void *find = rsp + 8;
    
    	for (int i=0; i<=count; i++)
    	{
    		check_address(find);
    		
    		memcpy(find, &arg[i], 8);
    		find +=8;
    	}
    }
    ```

- ì°¸ê³  ì½”ë“œ

    ```c
    void get_argument(void *rsp, int **arg, int count){
    	rsp = (int64_t *)rsp + 2;  // ì›ë˜ stack pointerì—ì„œ 2ì¹¸(16byte) ì˜¬ë¼ê° : |argc|"argv"|...
    	for (int i=0; i<count; i++){
    		arg[i] = rsp;
    		rsp = (int64_t *)rsp + 1;
    	}
    }
    ```

- ìˆ˜ì • ì½”ë“œ

    ```c
    void get_argument(void *rsp, int **arg, int count)
    {
    	rsp = (int64_t *)rsp + 2; // ì›ë˜ stack pointerì—ì„œ 2ì¹¸(16byte) ì˜¬ë¼ê° : |argc|"argv"|...
    	for (int i = 0; i < count; i++)
    	{
    		check_address(rsp); //ì§„êµ ì¶”ê°€
    		arg[i] = rsp;
    		rsp = (int64_t *)rsp + 1;
    	}
    }
    ```

### syscall_handler() êµ¬í˜„

- logic

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/909d5d2d-d3ad-4b23-b019-f193b49e6a40/Untitled.png)

    <aside> ğŸ’¡  syscall_handler()ë€?

    - syscallN()í•¨ìˆ˜ê°€ ë ˆì§€ìŠ¤í„°ì˜ ê°’ì„ syscall_handlerë¥¼ ìœ„í•´ ì„¸íŒ…í•´ì¤Œ
    - ì‹œìŠ¤í…œì½œ í•¸ë“¤ëŸ¬ì—ì„œ ì‹œìŠ¤í…œ ì½œë²ˆí˜¸ì— í•´ë‹¹í•˜ëŠ” ì‹œìŠ¤í…œì½œ í˜¸ì¶œ (%rax ì— ê·¸ ë²ˆí˜¸ê°€ ë‹´ê¸´ systemcallì„ ë¶€ë¥´ê²Œë¨.)
    - ì‹œìŠ¤í…œì½œ í•¸ë“¤ëŸ¬ì—ì„œ ìœ ì €ìŠ¤íƒ í¬ì¸í„°(esp) ì£¼ì†Œì™€ ì¸ìê°€ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œ(í¬ì¸í„°)ê°€ ìœ ì €ì˜ì—­ì¸ì§€ í™•ì¸
    - ìœ ì €ìŠ¤íƒì— ìˆëŠ” ì¸ìë“¤ì„ ì»¤ë„ì— ì €ì¥
    - ì‹œìŠ¤í…œì½œì˜ í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì€ ì¸í„°ëŸ½íŠ¸í”„ë ˆì„ì˜ raxì— ì €ì¥ </aside>

- êµ¬í˜„ ì½”ë“œ

    userprog>syscall.c

    ```c
    void
    syscall_handler (struct intr_frame *f) {
    	check_address(f->rsp);
    
    	int count = f->R.rdi;
    	void *check_ptr = f->R.rsi;
    	void* tmp;
    	void* args[count];
    	
    
    	for(int i=1; i <= count; i++)
    	{
    		memcpy(check_ptr, &tmp, 8);
    		check_address(tmp);
    		args[i]= tmp;
    	}
    	
    	switch (count)
    	{
    		case SYS_HALT:
    			halt();
    			break;
    		case SYS_EXIT:
    			exit(args[1]);
    			break;
    		case SYS_FORK:
    			fork(args[1]);
    			break;
    		case SYS_EXEC:
    			exec(args[1]);
    			break;
    		case SYS_WAIT:
    			wait(args[1]);
    			break;
    		case SYS_CREATE:
    			create(args[1],args[2]);
    			break;
    		case SYS_REMOVE:
    			remove(args[1]);
    			break;
    		case SYS_OPEN:
    			open(args[1]);
    			break;
    		case SYS_FILESIZE:
    			filesize(args[1]);
    			break;
    		case SYS_READ:
    			read(args[1], args[2], args[3]);
    			break;
    		case SYS_WRITE:
    			write(args[1], args[2], args[3]);
    			break;
    		case SYS_SEEK:
    			seek(args[1], args[2]);
    			break;
    		case SYS_TELL:
    			tell(args[1]);
    			break;
    		case SYS_CLOSE:
    			close(args[1]);
    			break;
    		case SYS_DUP2:
    			dup2(args[1], args[2]);
    			break;
    		case SYS_MMAP:
    			mmap(args[1], args[2], args[3], args[4], args[5]);
    			break;
    		case SYS_MUNMAP:
    			munmap(args[1]);
    			break;
    		case SYS_CHDIR:
    			chdir(args[1]);
    			break;
    		case SYS_MKDIR:
    			mkdir(args[1]);
    			break;
    		case SYS_READDIR:
    			readdir(args[1], args[2]);
    			break;
    		case SYS_ISDIR:
    			isdir(args[1]);
    			break;
    		case SYS_INUMBER:
    			inumber(args[1]);
    			break;
    		case SYS_SYMLINK:
    			symlink(args[1], args[2]);
    			break;
    		case SYS_MOUNT:
    			mount(args[1], args[2], args[3]);
    			break;
    		case SYS_UMOUNT:
    			umount(args[1]);
    			break;
    		default:
    			thread_exit();
    	}
    
    	printf("system call!\\n");
    	thread_exit ();
    }
    ```

- ì°¸ê³  ì½”ë“œ

    ```c
    void
    syscall_handler (struct intr_frame *f UNUSED) {
    	/* ìœ ì € ìŠ¤íƒì— ì €ì¥ë˜ì–´ ìˆëŠ” ì‹œìŠ¤í…œ ì½œ ë„˜ë²„ë¥¼ ê°€ì ¸ì™€ì•¼ì§€ ì¼ë‹¨ */
    	int sys_number = f->R.rax; // rax: ì‹œìŠ¤í…œ ì½œ ë„˜ë²„
        /* 
    	ì¸ì ë“¤ì–´ì˜¤ëŠ” ìˆœì„œ:
    	1ë²ˆì§¸ ì¸ì: %rdi
    	2ë²ˆì§¸ ì¸ì: %rsi
    	3ë²ˆì§¸ ì¸ì: %rdx
    	4ë²ˆì§¸ ì¸ì: %r10
    	5ë²ˆì§¸ ì¸ì: %r8
    	6ë²ˆì§¸ ì¸ì: %r9 
    	*/
    	// TODO: Your implementation goes here.
    	switch(sys_number) {
    		case SYS_HALT:
    			halt();
    		case SYS_EXIT:
    			exit(f->R.rdi);
    		case SYS_FORK:
    			fork(f->R.rdi);		
    		case SYS_EXEC:
    			exec(f->R.rdi);
    		case SYS_WAIT:
    			wait(f->R.rdi);
    		case SYS_CREATE:
    			create(f->R.rdi, f->R.rsi);		
    		case SYS_REMOVE:
    			remove(f->R.rdi);		
    		case SYS_OPEN:
    			open(f->R.rdi);		
    		case SYS_FILESIZE:
    			filesize(f->R.rdi);
    		case SYS_READ:
    			read(f->R.rdi, f->R.rsi, f->R.rdx);
    		case SYS_WRITE:
    			write(f->R.rdi, f->R.rsi, f->R.rdx);		
    		case SYS_SEEK:
    			seek(f->R.rdi, f->R.rsi);		
    		case SYS_TELL:
    			tell(f->R.rdi);		
    		case SYS_CLOSE:
    			close(f->R.rdi);	
    	}
    	printf ("system call!\\n");
    	thread_exit ();
    }
    ```

- ìˆ˜ì •ì½”ë“œ

    ```c
    void syscall_handler(struct intr_frame *f)
    {
    	/* í¬ì¸í„° ë ˆì§€ìŠ¤í„°ì¸ rsp ì£¼ì†Œ í™•ì¸ í•„ìš”*/
    	check_address(&f->rsp);
    
    	switch (f->R.rax) // raxê°’ì´ ë“¤ì–´ê°€ì•¼í•¨.
    	{
    	case SYS_HALT:
    		halt();
    		break;
    	case SYS_EXIT:
    		exit(f->R.rdi);
    		break;
    	case SYS_FORK:
    		fork(f->R.rdi);
    		break;
    	case SYS_EXEC:
    		exec(f->R.rdi);
    		break;
    	case SYS_WAIT:
    		wait(f->R.rdi);
    		break;
    	case SYS_CREATE:
    		f->R.rax = create(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_REMOVE:
    		f->R.rax = remove(f->R.rdi);
    		break;
    	case SYS_OPEN:
    		open(f->R.rdi);
    		break;
    	case SYS_FILESIZE:
    		f->R.rax = filesize(f->R.rdi);
    		break;
    	case SYS_READ:
    		read(f->R.rdi, f->R.rsi, f->R.rdx);
    		break;
    	case SYS_WRITE:
    		write(f->R.rdi, f->R.rsi, f->R.rdx);
    		break;
    	case SYS_SEEK:
    		seek(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_TELL:
    		tell(f->R.rdi);
    		break;
    	case SYS_CLOSE:
    		close(f->R.rdi);
    		break;
    	case SYS_DUP2:
    		dup2(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_MMAP:
    		mmap(f->R.rdi, f->R.rsi, f->R.rdx, f->R.r10, f->R.r8);
    		break;
    	case SYS_MUNMAP:
    		munmap(f->R.rdi);
    		break;
    	case SYS_CHDIR:
    		chdir(f->R.rdi);
    		break;
    	case SYS_MKDIR:
    		mkdir(f->R.rdi);
    		break;
    	case SYS_READDIR:
    		readdir(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_ISDIR:
    		isdir(f->R.rdi);
    		break;
    	case SYS_INUMBER:
    		inumber(f->R.rdi);
    		break;
    	case SYS_SYMLINK:
    		symlink(f->R.rdi, f->R.rsi);
    		break;
    	case SYS_MOUNT:
    		mount(f->R.rdi, f->R.rsi, f->R.rdx);
    		break;
    	case SYS_UMOUNT:
    		umount(f->R.rdi);
    		break;
    	default:
    		thread_exit();
    	}
    
    	printf("system call!\\n");
    	thread_exit();
    }
    ```

    s**ystemcall_handler()ì—ì„œ rsi, rdi, rbp, rspì™€ ê°™ì€ ë ˆì§€ìŠ¤í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œê°€ ìœ íš¨í•œ user addressì¸ì§€ í™•ì¸í•˜ëŠ” ê²ƒì€ ë§¤ìš° ì¤‘ìš”**í•©ë‹ˆë‹¤. ì´ëŠ” ìœ ì € ìŠ¤íƒì´ë‚˜ ìœ ì € ë°ì´í„°ë¥¼ ì½ê±°ë‚˜ ì“¸ ë•Œ í”„ë¡œê·¸ë¨ì˜ ì•ˆì •ì„±ê³¼ ë³´ì•ˆì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•œ ì‘ì—…ì…ë‹ˆë‹¤. ë”°ë¼ì„œ systemcall_handler()ì—ì„œ ì´ëŸ¬í•œ ì£¼ì†Œë“¤ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ëŠ” ê²ƒì€ ì¢‹ì€ ìŠµê´€ì…ë‹ˆë‹¤.

# system call ì‹œìŠ¤í…œì½œ(ìˆ˜,ëª©ìš”ì¼)

ì‹œìŠ¤í…œ ì½œ(System Call)ì€ ì»´í“¨í„° í”„ë¡œê·¸ë¨ì´ ìš´ì˜ ì²´ì œì˜ ì»¤ë„ì—ì„œ ì„œë¹„ìŠ¤ë¥¼ ìš”ì²­í•˜ëŠ” í”„ë¡œê·¸ë¨ ë°©ì‹ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ í˜¸ì¶œì€ ì¼ë°˜ì ìœ¼ë¡œ Cë¡œ ì‘ì„±ëœ ë£¨í‹´ìœ¼ë¡œ ì œê³µë©ë‹ˆë‹¤.

- í•¨ìˆ˜ flow

    <aside> ğŸ’¡ user funcâ†’ syscallNâ†’syscall()â†’syscall_entry.Sâ†’syscall_handler()â†’ìš°ë¦¬ê°€ ì‘ì„±í•œ systemcall()

    </aside>

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/254e4f61-7d69-477d-b385-3cb3df2e75a2/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9f67f038-a057-4104-a1b6-09f4dd77f656/Untitled.png)

- logic

    - writing a simple program to read data from one file and copy them to another file

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b0bbf95-9c36-4a7e-879a-b018db86eaee/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/79d7db57-1e65-4f28-8b6a-a2081f34371b/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/79ce3e7a-95a0-4905-bd55-272dd726ab59/Untitled.png)

    1. Acquire input filename: ì–´ë–¤ íŒŒì¼ì— inputí• ê±´ì§€, ì–´ë–¤ íŒŒì¼ì„ inputí• ê±´ì§€ filenameí•„ìš”

        ì…ë ¥ë°›ê±°ë‚˜, selecter

    2. write prompt to screen: device systemcall í•„ìš”

    3. accept input: systemcall í•„ìš”

    https://youtu.be/v30ilCpITnY

    ------

- ê´€ë ¨ ë§¤í¬ë¡œ&í•¨ìˆ˜

    1. NOT_REACHED()

        ```c
        #define NOT_REACHED() PANIC ("executed an unreachable statement");
        ```

        <aside> ğŸ’¡ **`NOT_REACHED()`**ì€ ë§¤í¬ë¡œ í•¨ìˆ˜ë¡œ, ì ˆëŒ€ë¡œ ë„ë‹¬í•˜ì§€ ì•Šì•„ì•¼ í•˜ëŠ” ì½”ë“œê°€ ì‹¤í–‰ëœ ê²½ìš° panic ìƒíƒœì— ë¹ ì§€ë„ë¡ í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, **`switch`**ë¬¸ ë“±ì—ì„œ default caseì— **`NOT_REACHED()`**ë¥¼ ì‘ì„±í•˜ë©´, case ì¤‘ í•˜ë‚˜ê°€ ì•„ë‹Œ ë‹¤ë¥¸ ê°’ì„ ë°›ì•„ë“¤ì´ëŠ” ê²½ìš°, ì´ ì½”ë“œëŠ” ì‹¤í–‰ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì½”ë“œê°€ ì˜ëª» ì‘ì„±ë˜ì—ˆìŒì„ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì´ ë§¤í¬ë¡œëŠ” ë””ë²„ê¹…ì„ ì‰½ê²Œ í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

        </aside>

    2. syscallN()

        <aside> ğŸ’¡ **`syscall()`** í•¨ìˆ˜ëŠ” ì£¼ì–´ì§„ ì‹œìŠ¤í…œ ì½œ ë²ˆí˜¸(**`NUMBER`**)ë¥¼ í˜¸ì¶œí•˜ê³ , ì¸ìë¥¼ ì „ë‹¬í•˜ì§€ ì•Šê³  ì‹¤í–‰í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì‹¤í–‰ ê²°ê³¼ë¥¼ **`int`** í˜•íƒœë¡œ ë°˜í™˜í•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ì´ ì»¤ë„ì— ìˆëŠ” ì„œë¹„ìŠ¤ë¥¼ ìš”ì²­í•˜ê³ , ê·¸ ê²°ê³¼ë¥¼ í”„ë¡œê·¸ë¨ì— ë°˜í™˜í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.

        ì˜ˆë¥¼ ë“¤ì–´, **`syscall(SYS_EXIT, 0)`**ëŠ” í˜„ì¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•˜ë„ë¡ ì»¤ë„ì— ìš”ì²­í•˜ê³ , ì¢…ë£Œ ì½”ë“œ 0ì„ ë°˜í™˜í•©ë‹ˆë‹¤. **`syscall(SYS_WRITE, 1, "Hello, world!\\n", 14)`**ëŠ” "Hello, world!" ë¬¸ìì—´ì„ í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ì¶œë ¥í•˜ë„ë¡ ì»¤ë„ì— ìš”ì²­í•˜ê³ , ì¶œë ¥í•œ ë°”ì´íŠ¸ ìˆ˜(14)ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

        </aside>

        ```c
        #define syscall0(NUMBER) ( \\
        		syscall(((uint64_t) NUMBER), 0, 0, 0, 0, 0, 0))
        
        /* Invokes syscall NUMBER, passing argument ARG0, and returns the
           return value as an `int'. */
        #define syscall1(NUMBER, ARG0) ( \\
        		syscall(((uint64_t) NUMBER), \\
        			((uint64_t) ARG0), 0, 0, 0, 0, 0))
        /* Invokes syscall NUMBER, passing arguments ARG0 and ARG1, and
           returns the return value as an `int'. */
        #define syscall2(NUMBER, ARG0, ARG1) ( \\
        		syscall(((uint64_t) NUMBER), \\
        			((uint64_t) ARG0), \\
        			((uint64_t) ARG1), \\
        			0, 0, 0, 0))
        
        #define syscall3(NUMBER, ARG0, ARG1, ARG2) ( \\
        		syscall(((uint64_t) NUMBER), \\
        			((uint64_t) ARG0), \\
        			((uint64_t) ARG1), \\
        			((uint64_t) ARG2), 0, 0, 0))
        
        .
        .
        .
        ```

## process descriptor (ìˆ˜ìš”ì¼)

- logic

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e2aceacf-2c75-4a7e-a16f-bd821aa43c3d/Untitled.png)

    <aside> ğŸ’¡ í”„ë¡œì„¸ìŠ¤ ë””ìŠ¤í¬ë¦½í„°(Process descriptor)ëŠ” ìš´ì˜ ì²´ì œì—ì„œ í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ **í”„ë¡œì„¸ìŠ¤ì— ëŒ€í•œ ì •ë³´ë¥¼ ìœ ì§€í•˜ê³  ìˆëŠ” ë°ì´í„° êµ¬ì¡°**ì…ë‹ˆë‹¤. í”„ë¡œì„¸ìŠ¤ ë””ìŠ¤í¬ë¦½í„°ëŠ” ì¼ë°˜ì ìœ¼ë¡œ í”„ë¡œì„¸ìŠ¤ì˜ ID, ìƒíƒœ, ìš°ì„  ìˆœìœ„, í”„ë¡œì„¸ìŠ¤ í…Œì´ë¸” í•­ëª© ë“±ì˜ ì •ë³´ë¥¼ ì €ì¥í•©ë‹ˆë‹¤. ë˜í•œ, í”„ë¡œì„¸ìŠ¤ ë””ìŠ¤í¬ë¦½í„°ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ìŠ¤ì¼€ì¤„ë§, ë©”ëª¨ë¦¬ í• ë‹¹, íŒŒì¼ ì‹œìŠ¤í…œ ë“±ê³¼ ê°™ì€ ìš´ì˜ ì²´ì œ ì„œë¹„ìŠ¤ì— í•„ìš”í•œ ì •ë³´ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤. ë”°ë¼ì„œ í”„ë¡œì„¸ìŠ¤ ë””ìŠ¤í¬ë¦½í„°ëŠ” ìš´ì˜ ì²´ì œì—ì„œ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ì— ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.

    </aside>

- struct thread ìˆ˜ì •

    include/threads/thread.h

    - êµ¬í˜„ ì½”ë“œ1

        ```c
        /* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/* ì¤€ì½” user program */
        	struct thread* pp_fd;
        	struct list_elem children_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        	int exit_status;
        ```

    - êµ¬í˜„ ì½”ë“œ2

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion ê´€ë ¨ element ì¶”ê°€ */
        	int init_priority;				// donationì´í›„ ìš°ì„ ìˆœìœ„ë¥¼ ì´ˆê¸°í™”í•˜ê¸° ìœ„í•´ ì´ˆê¸°ê°’ ì €ì¥
        	struct lock *wait_on_lock;		// í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°í•˜ê³  ìˆëŠ” lockìë£Œêµ¬ì¡° ì£¼ì†Œ ì €ì¥
        	struct list donations;			// multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        	struct list_elem donation_elem; // multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        									/*----------------[project1]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/* ì¤€ì½”'s user program */
        	/* parent-children hierachy */
        
        	struct thread* parent_pd; // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ì˜ ë””ìŠ¤í¬ë¦½í„°
        	struct list_elem children_elem;
        	struct list children_list;
        
        	/* ì¤€ì½” : ì¼ë‹¨ ë§Œë“¤ì–´ ë†“ì  */
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	int exit_status;
        
        	/* ì¤€ì½” */
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        };
        ```

    - ìµœì¢… ìˆ˜ì •

        include/threads/thread.h

        ```c
        /*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ì˜ ë””ìŠ¤í¬ë¦½í„°
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        	/*----------------[project2]-------------------*/
        ```

- threads/thread.c/thread_create() ì¶”ê°€

    - êµ¬í˜„ ì½”ë“œ1

        ```c
        /* project2 í”„ë¡œì„¸ìŠ¤ ê³„ì¸µ êµ¬ì¡° êµ¬í˜„  */
        	struct thread *curr = thread_current();
        	if( curr != NULL){
        		t->parent_pd = curr;
        		sema_init(&curr->exit_sema, 0);
        		sema_init(&curr->load_sema, 0);
        		sema_init(&curr->wait_sema, 0);
        	}
        ```

        ì˜ëª»ëœ ìƒê°

        : sema initì„ ì—¬ê¸°ì„œ í•´ì•¼ëœë‹¤ê³  ìƒê°í•¨.

        chileren_listê´€ë¦¬ë¥¼ ì•ˆí•¨ : í˜„ì¬ thread(ë¶€ëª¨)ì— ë°©ê¸ˆ ìƒì„±ëœ thread(ìì‹)ì˜ elemì„ ì¶”ê°€í•´ì•¼ë¨.

    - ìˆ˜ì • ì½”ë“œ1 : thread_create()

        ```c
        // if (curr != NULL)
        	// {
        	// 	t->parent_pd = curr;
        	// 	sema_init(&curr->exit_sema, 0);
        	// 	sema_init(&curr->load_sema, 0);
        	// 	sema_init(&curr->wait_sema, 0);
        	// }
        	list_push_back(&curr->children_list, &t->child_elem);
        ```

- init_thread() ìˆ˜ì •

    sema initë¥¼ init_thread()ì—ì„œ í•˜ë„ë¡ ìˆ˜ì •

    ```c
    list_init(&t->donations);
    	/*----------------[project1]-------------------*/
    	list_init(&t->children_list);
    
    	sema_init(&t->wait_sema, 0);
    	sema_init(&t->fork_sema, 0);
    	sema_init(&t->free_sema, 0);
    
    	/*---------------[ì¤€ì½”]------------------------*/
    }
    ```

- threads/thread.c/thread_exit() ì¶”ê°€

    - êµ¬í˜„ ì½”ë“œ

        ```c
        #endif
        
        	intr_disable();
        	sema_up(&list_entry(&thread_current()->elem, struct thread, elem)->wait_sema);
        	list_remove (&thread_current()->elem); // elem? all elem? ğŸ˜¡
        	do_schedule(THREAD_DYING);
        	NOT_REACHED();
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        #endif
        
        	intr_disable();
        	// sema_up(&list_entry(&thread_current()->elem, struct thread, elem)->wait_sema);
        	list_remove(&thread_current()->allelem); // elem? all elem? ğŸ˜¡
        	do_schedule(THREAD_DYING);
        	NOT_REACHED();
        }
        ```

- threads/thread.c/init_thread() ì¶”ê°€

    threads/thread.c

    - êµ¬í˜„ ì½”ë“œ1

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        	/*---------------[ì¤€ì½”]------------------------*/
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        
        	sema_init(&t->wait_sema, 0);
        	sema_init(&t->fork_sema, 0);
        	sema_init(&t->free_sema, 0);
        
        	/*---------------[ì¤€ì½”]------------------------*/
        }
        ```

- userprog/process.c/int process_exec(void *f_name) ì¶”ê°€

    - êµ¬í˜„ ì½”ë“œ : ìˆ˜ì •ì‚¬í•­ ì—†ìŒ ğŸ’•

        ```c
        /* And then load the binary */
        	success = load(file_name, &_if);
        
        	/* project2 system call */
        	if (success)
        	{
        		struct thread *curr = thread_current();
        		struct thread *target = list_entry(&curr->child_elem, struct thread, child_elem);
        		sema_up(&target->wait_sema);
        	}
        ```

- userprog/process.c/int process_wait(tid_t child_tid UNUSED) êµ¬í˜„

    - êµ¬í˜„ ì½”ë“œ

        ```c
        int process_wait(tid_t child_tid UNUSED)
        {
        	struct thread *child = get_child_process(pid);
        	struct thread *curr = thread_current();
        	if(child = NULL){
        		return -1;
        	}
        	sema_down(&curr->wait_sema);
        	thread_exit();
        	return &child->status;
        
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        int process_wait(tid_t child_tid UNUSED)
        {
        	struct thread *child = get_child_process(child_tid);
        	struct thread *curr = thread_current();
        	if (child = NULL)
        	{
        		return -1;
        	}
        	sema_down(&curr->wait_sema);
        	// thread_exit();
        	list_remove(&child->child_elem);
        	sema_up(&child->free_sema);
        	return &child->exit_status;
        }
        ```

- userprog/process.c/struct thread *get_child_process(int pid) êµ¬í˜„

    - êµ¬í˜„ ì½”ë“œ : ìˆ˜ì •ì‚¬í•­ ì—†ìŒ ğŸ’•

        ```c
        struct thread *get_child_process(int pid)
        {
        	struct thread *curr = thread_current();
        	struct list_elem *find = list_begin(&curr->children_list);
        	while (find != NULL)
        	{
        		if (list_entry(find, struct thread, child_elem)->tid = pid)
        		{
        			return list_entry(find, struct thread, child_elem);
        		}
        		else
        		{
        			find = list_next(find);
        		}
        	}
        	return NULL;
        }
        ```

- userprog/process.c/remove_child_process(struct thread *cp) êµ¬í˜„

    - êµ¬í˜„ ì½”ë“œ : ìˆ˜ì •ì‚¬í•­ ì—†ìŒ ğŸ’•

        ```c
        void remove_child_process(struct thread *cp)
        {
        	list_remove(&cp->child_elem);
        	free(*cp);
        }
        ```

- userprog/syscall.c/int exec(const *cmd_line) êµ¬í˜„

    - êµ¬í˜„ ì½”ë“œ : ìˆ˜ì •ì‚¬í•­ ì—†ìŒ ğŸ’•

        ```c
        int exec(const *cmd_line)
        {
        	struct thread *curr = thread_current();
        	tid_t pid = process_create_initd(cmd_line);	   // cmd_line parsingí•´ì„œ file_name ì¶”ì¶œí•´ì„œ ë„£ìŒ.
        												   /* sema_down ì˜›í„°  */
        	struct thread *child = get_child_process(pid); // ìƒì„±ëœ ìì‹ í”„ë¡œì„¸ìŠ¤ì˜ ë””ìŠ¤í¬ë¦½í„° ê²€ìƒ‰ ë¯¸êµ¬í˜„ ğŸ˜¡
        	int result = process_wait(child);			   // ìì‹ í”„ë¡œì„¸ìŠ¤ì˜ í”„ë¡œê·¸ë¨ ì ì¬ ëŒ€ê¸°ğŸ˜¡
        	list_push_back(&curr->children_list, &child->child_elem);
        
        	if (result = 1) // ì ì¬ ì„±ê³µì‹œ
        	{
        		return pid;
        	}
        	else
        	{ // ì ì¬ ì‹¤íŒ¨ì‹œ
        		return -1;
        	}
        }
        ```

## file descriptor(ëª©ìš”ì¼)

- struct thread ì¶”ê°€

    include/threads/thread.h

    - êµ¬í˜„ ì½”ë“œ

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion ê´€ë ¨ element ì¶”ê°€ */
        	int init_priority;				// donationì´í›„ ìš°ì„ ìˆœìœ„ë¥¼ ì´ˆê¸°í™”í•˜ê¸° ìœ„í•´ ì´ˆê¸°ê°’ ì €ì¥
        	struct lock *wait_on_lock;		// í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°í•˜ê³  ìˆëŠ” lockìë£Œêµ¬ì¡° ì£¼ì†Œ ì €ì¥
        	struct list donations;			// multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        	struct list_elem donation_elem; // multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        									/*----------------[project1]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ì˜ ë””ìŠ¤í¬ë¦½í„°
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        
        	struct file **fdt;
        	int next_fd;
        
        	/*----------------[project2]-------------------*/
        };
        ```

    - ì°¸ê³  ì½”ë“œ

        ```c
        struct thread {
        	/* Owned by thread.c. */
        	tid_t tid;                          /* Thread identifier. */
        	enum thread_status status;          /* Thread state. */
        	char name[16];                      /* Name (for debugging purposes). */
        	int priority;                       /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem;              /* List element. */
        
        	/* ==================== project1 ==================== */
        	/* priority donation */
        	/* priorityë¥¼ ì–‘ë„ ë°›ê³  ë°˜í™˜í•˜ê³ ë‚˜ì„œ ì›ë˜ priorityë¥¼ ë³µì›í•˜ê¸° ìœ„í•´ ê¸°ë¡*/
        	int init_priority; 
        	/* threadê°€ í˜„ì¬ ì–»ê¸° ìœ„í•´ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ” lock ìœ¼ë¡œ ìŠ¤ë ˆë“œëŠ” ì´ lock ì´ release ë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦°ë‹¤. */
        	struct lock *wait_on_lock; 
        	/* ìì‹ ì—ê²Œ priority ë¥¼ ë‚˜ëˆ„ì–´ì¤€ threadë“¤ì˜ ë¦¬ìŠ¤íŠ¸ì´ê³  */
        	struct list donations; 
        	 /*  donations ë¦¬ìŠ¤íŠ¸ë¥¼ ê´€ë¦¬í•˜ê¸° ìœ„í•œ element ë¡œ thread êµ¬ì¡°ì²´ì˜ ê·¸ëƒ¥ elem ê³¼ êµ¬ë¶„í•˜ì—¬ ì‚¬ìš©í•˜ë„ë¡ í•œë‹¤. */
        	struct list_elem donation_elem;
        	
        	/* Wake Up Time Tick (ì‹œìŠ¤í…œì´ ì‹œì‘ëœ ì´í›„ë¶€í„° ì–¸ì œ ì¼ì–´ë‚˜ì•¼ë˜ëŠ”ì§€ ì•Œë ¤ì£¼ëŠ” ì‹œê°„) */
        	int64_t wake_ticks;
        	/* ==================== project1 ==================== */
        
        	/* ==================== project2 ==================== */
        	// 2-3 Parent-child hierarchy
        	struct list child_list;		 // keep children
        	struct list_elem child_elem; // used to put current thread into 'children' list
        	// 2-3 wait syscall
        	// struct semaphore wait_sema; // used by parent to wait for child
        	int exit_status;			// used to deliver child exit_status to parent
        	// 2-3 fork syscall
        	struct intr_frame parent_if; // to preserve my current intr_frame and pass it down to child in fork ('parent_if' in child's perspective)
        	// struct semaphore fork_sema;	 // parent wait (process_wait) until child fork completes (__do_fork)
        	// struct semaphore free_sema;	 // Postpone child termination (process_exit) until parent receives its exit_status in 'wait' (process_wait)
        	// 2-4 file descripter
        	struct file **fdTable; // allocation in threac_create (thread.c)
        	int fdIdx;			   // an index of an open spot in fdTable
        	// 2-5 deny exec writes
        	struct file *running; // executable ran by current process (process.c load, process_exit)
        	// 2-extra - count the number of open stdin/stdout
        	// dup2 may copy stdin or stdout; stdin or stdout is not really closed until these counts goes 0
        	int stdin_count;
        	int stdout_count;
        	/* ==================== project2 ==================== */
        	
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4;                     /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf;               /* Information for switching */
        	unsigned magic;                     /* Detects stack overflow. */
        };
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion ê´€ë ¨ element ì¶”ê°€ */
        	int init_priority;				// donationì´í›„ ìš°ì„ ìˆœìœ„ë¥¼ ì´ˆê¸°í™”í•˜ê¸° ìœ„í•´ ì´ˆê¸°ê°’ ì €ì¥
        	struct lock *wait_on_lock;		// í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°í•˜ê³  ìˆëŠ” lockìë£Œêµ¬ì¡° ì£¼ì†Œ ì €ì¥
        	struct list donations;			// multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        	struct list_elem donation_elem; // multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        									/*----------------[project1]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        
        	/*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ì˜ ë””ìŠ¤í¬ë¦½í„°
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        
        	struct file **fdt;
        	int next_fd;
        	/* ğŸ¤” */
        	struct file *running; // í˜„ì¬ ìŠ¤ë ˆë“œê°€ ì‚¬ìš© ì¤‘ì¸ íŒŒì¼(loadí•˜ê³  ìˆëŠ” íŒŒì¼)
        	int stdin_count;
        	int stdout_count;
        	/*----------------[project2]-------------------*/
        };
        ```

- init_thread() ìˆ˜ì •

    - êµ¬í˜„ì½”ë“œ

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        
        	sema_init(&t->wait_sema, 0);
        	sema_init(&t->fork_sema, 0);
        	sema_init(&t->free_sema, 0);
        	
        	/* project 2: system call*/
        	t->exit_status = 0;
        	/*---------------[ì¤€ì½”]------------------------*/
        }
        ```

- thread_create() ì¶”ê°€

    threads/thread.c

    - êµ¬í˜„ ì½”ë“œ

        ```c
        tid_t thread_create(const char *name, int priority,
        					thread_func *function, void *aux)
        {
        	struct thread *t;
        	tid_t tid;
        
        	ASSERT(function != NULL);
        
        	t = palloc_get_page(PAL_ZERO);
        	if (t == NULL)
        		return TID_ERROR;
        
        	init_thread(t, name, priority);
        	tid = t->tid = allocate_tid();
        
        	t->tf.rip = (uintptr_t)kernel_thread;
        	t->tf.R.rdi = (uint64_t)function;
        	t->tf.R.rsi = (uint64_t)aux;
        	t->tf.ds = SEL_KDSEG;
        	t->tf.es = SEL_KDSEG;
        	t->tf.ss = SEL_KDSEG;
        	t->tf.cs = SEL_KCSEG;
        	t->tf.eflags = FLAG_IF;
        
        	/* project2 í”„ë¡œì„¸ìŠ¤ ê³„ì¸µ êµ¬ì¡° êµ¬í˜„  */
        	struct thread *curr = thread_current();
        
        	list_push_back(&curr->children_list, &t->child_elem);
        
        	/* ìŠ¤ë ˆë“œ ìƒì„±ì‹œ File Descriptor ì´ˆê¸°í™” */
        	t->fdt = palloc_get_page(0);
        	for(int i=0; i<128; i++){
        		t->fdt[i]=NULL;
        	}
        	t->next_fd = 2;
        
        	thread_unblock(t); // të¥¼ ready listì— ì¶”ê°€í•¨.
        
        	test_max_priority(); // ì¤€ì½” ì—¬ê¸° ë¹„êµ, yield ë‹¤ìˆìœ¼ë‹ˆê¹Œ
        						 // ì—¬ê¸°ëŠ” 5ì›” 2ì¼ ì¤€ì½” ë°˜ê°‘ë‹¤!
        
        	return tid;
        }
        ```

    - êµ¬í˜„ ì½”ë“œ2

        ```c
        tid_t thread_create(const char *name, int priority,
        					thread_func *function, void *aux)
        {
        	struct thread *t;
        	tid_t tid;
        
        	ASSERT(function != NULL);
        
        	t = palloc_get_page(PAL_ZERO);
        	if (t == NULL)
        		return TID_ERROR;
        
        	init_thread(t, name, priority);
        	tid = t->tid = allocate_tid();
        
        	t->tf.rip = (uintptr_t)kernel_thread;
        	t->tf.R.rdi = (uint64_t)function;
        	t->tf.R.rsi = (uint64_t)aux;
        	t->tf.ds = SEL_KDSEG;
        	t->tf.es = SEL_KDSEG;
        	t->tf.ss = SEL_KDSEG;
        	t->tf.cs = SEL_KCSEG;
        	t->tf.eflags = FLAG_IF;
        
        	/* project2 í”„ë¡œì„¸ìŠ¤ ê³„ì¸µ êµ¬ì¡° êµ¬í˜„  */
        	struct thread *curr = thread_current();
        
        	list_push_back(&curr->children_list, &t->child_elem);
        
        	/*  94p
        		ğŸ˜¡ í”„ë¡œê·¸ë¨ì´ ë¡œë“œë˜ì§€ ì•ŠìŒ
        		ğŸ˜¡ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì§€ ì•ŠìŒ
        		ğŸ˜¡ìì‹ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€		*/
        
        	/* ìŠ¤ë ˆë“œ ìƒì„±ì‹œ File Descriptor ì´ˆê¸°í™” */
        	t->fdt = palloc_get_multiple(PAL_ZERO, FDT_PAGES);
        	if (t->fdt == NULL)
        	{
        		return TID_ERROR;
        	}
        	t->next_fd = 2;
        	t->fdt[0] = 1;
        	t->fdt[1] = 2;
        
        	thread_unblock(t); // të¥¼ ready listì— ì¶”ê°€í•¨.
        
        	test_max_priority(); // ì¤€ì½” ì—¬ê¸° ë¹„êµ, yield ë‹¤ìˆìœ¼ë‹ˆê¹Œ
        						 // ì—¬ê¸°ëŠ” 5ì›” 2ì¼ ì¤€ì½” ë°˜ê°‘ë‹¤!
        
        	return tid;
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [PintOS Project 2 - User Program (7) System Call(ì •ê¸€ì‚¬ê´€í•™êµ 69ì¼ì°¨ TIL) - íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ê´€ë ¨ system call êµ¬í˜„ (tistory.com)](https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-7-System-Callì •ê¸€ì‚¬ê´€í•™êµ-69ì¼ì°¨-TIL)

        ```c
        tid_t
        thread_create (const char *name, int priority,
        		thread_func *function, void *aux) {
        	
            (...)
        
        	/* --- project 2: system call --- */
        	t->file_descriptor_table = palloc_get_multiple(PAL_ZERO, FDT_PAGES);
        	if (t->file_descriptor_table == NULL) {
        		return TID_ERROR;
        	}
        	t->fdidx = 2; // 0ì€ stdin, 1ì€ stdoutì— ì´ë¯¸ í• ë‹¹
        	t->file_descriptor_table[0] = 1; // stdin ìë¦¬: 1 ë°°ì •
        	t->file_descriptor_table[1] = 2; // stdout ìë¦¬: 2 ë°°ì •
        
        }
        ```

        ë…¸ì…˜ ì½”ë“œ

        ```c
        tid_t thread_create (const char *name, int priority, thread_func *function, void *aux){
        ...
        	t->fdTable = palloc_get_multiple(PAL_ZERO, FDT_PAGES);  // í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ì˜ FDT ê³µê°„ í• ë‹¹
          if (t->fdTable == NULL)  // ì œëŒ€ë¡œ ê³µê°„ì´ í• ë‹¹ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì—ëŸ¬.
              return TID_ERROR;
        
          t->fdIdx = 2;       // 0 : stdin, 1 : stdoutì´ë¯€ë¡œ ìƒˆ íŒŒì¼ì´ open()í•˜ë©´ 2ë¶€í„° ì‹œì‘.
          t->fdTable[0] = 1;  // ì˜ë¯¸ê°€ ìˆëŠ” ìˆ«ìëŠ” ì•„ë‹ˆë‹¤. ë‹¤ë§Œ í•´ë‹¹ ì¸ë±ìŠ¤(ì‹ë³„ì)ë¥¼ ì‚¬ìš©í•˜ëŠ” íŒŒì¼ì´ ì¡´ì¬í•˜ë¯€ë¡œ ë„£ì–´ì¤€ ê²ƒ.
          t->fdTable[1] = 2;  // NULL ë§Œë“¤ì§€ ì•Šìœ¼ë ¤ê³ . ì›ë˜ëŠ” í•´ë‹¹ íŒŒì¼ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ê°€ ë“¤ì–´ê°€ì•¼í•¨
        	t->stdin_count = 1; // ì´ í”„ë¡œì„¸ìŠ¤ì˜ í‘œì¤€ ì…ë ¥ íŒŒì¼ì´ ì—´ë ¤ìˆëŠ”ì§€ë¥¼ í™•ì¸í•˜ëŠ” flag
          t->stdout_count = 1; // ì´ í”„ë¡œì„¸ìŠ¤ì˜ í‘œì¤€ ì¶œë ¥ íŒŒì¼ì´ ì—´ë ¤ìˆëŠ”ì§€ë¥¼ í™•ì¸í•˜ëŠ” flag
        ...
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        tid_t thread_create(const char *name, int priority,
        					thread_func *function, void *aux)
        {
        	struct thread *t;
        	tid_t tid;
        
        	ASSERT(function != NULL);
        
        	t->fdt = palloc_get_multiple(PAL_ZERO, 3); /* ğŸ¤” */
        	if (t->fdt == NULL)
        		return TID_ERROR;
        
        	/* ìŠ¤ë ˆë“œ ìƒì„±ì‹œ File Descriptor ì´ˆê¸°í™” */
        	// t->fdt = palloc_get_page(0);
        	// for (int i = 0; i < 128; i++)
        	// {
        	// 	t->fdt[i] = NULL;
        	// }
        	t->next_fd = 2;
        	/* ğŸ¤” */
        	t->fdt[0] = 1; // ì˜ë¯¸ê°€ ìˆëŠ” ìˆ«ìëŠ” ì•„ë‹ˆë‹¤. ë‹¤ë§Œ í•´ë‹¹ ì¸ë±ìŠ¤(ì‹ë³„ì)ë¥¼ ì‚¬ìš©í•˜ëŠ” íŒŒì¼ì´ ì¡´ì¬í•˜ë¯€ë¡œ ë„£ì–´ì¤€ ê²ƒ.
        	t->fdt[1] = 2; // NULL ë§Œë“¤ì§€ ì•Šìœ¼ë ¤ê³ . ì›ë˜ëŠ” í•´ë‹¹ íŒŒì¼ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ê°€ ë“¤ì–´ê°€ì•¼í•¨
        
        	init_thread(t, name, priority);
        	tid = t->tid = allocate_tid();
        
        	t->tf.rip = (uintptr_t)kernel_thread;
        	t->tf.R.rdi = (uint64_t)function;
        	t->tf.R.rsi = (uint64_t)aux;
        	t->tf.ds = SEL_KDSEG;
        	t->tf.es = SEL_KDSEG;
        	t->tf.ss = SEL_KDSEG;
        	t->tf.cs = SEL_KCSEG;
        	t->tf.eflags = FLAG_IF;
        
        	/* project2 í”„ë¡œì„¸ìŠ¤ ê³„ì¸µ êµ¬ì¡° êµ¬í˜„  */
        	struct thread *curr = thread_current();
        	// if (curr != NULL)
        	// {
        	// 	t->parent_pd = curr;
        	// 	sema_init(&curr->exit_sema, 0);
        	// 	sema_init(&curr->load_sema, 0);
        	// 	sema_init(&curr->wait_sema, 0);
        	// }
        	list_push_back(&curr->children_list, &t->child_elem);
        
        	/*  94p
        		ğŸ˜¡ í”„ë¡œê·¸ë¨ì´ ë¡œë“œë˜ì§€ ì•ŠìŒ
        		ğŸ˜¡ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì§€ ì•ŠìŒ
        		ğŸ˜¡ìì‹ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€		*/
        
        	thread_unblock(t); // të¥¼ ready listì— ì¶”ê°€í•¨.
        
        	test_max_priority(); // ì¤€ì½” ì—¬ê¸° ë¹„êµ, yield ë‹¤ìˆìœ¼ë‹ˆê¹Œ
        						 // ì—¬ê¸°ëŠ” 5ì›” 2ì¼ ì¤€ì½” ë°˜ê°‘ë‹¤!
        
        	return tid;
        }
        ```

    - ì‚¬ìš© í•¨ìˆ˜

        - palloc_get_multiple()

            <aside> ğŸ’¡ ì£¼ì„ ì„¤ëª… PAGE_CNT ê°œì˜ ì—°ì†ì ì¸ ë¹ˆ í˜ì´ì§€ ê·¸ë£¹ì„ ê°€ì ¸ì™€ ë°˜í™˜í•©ë‹ˆë‹¤. ë§Œì•½ PAL_USERê°€ ì„¤ì •ë˜ì–´ ìˆë‹¤ë©´, í˜ì´ì§€ë“¤ì€ ì‚¬ìš©ì í’€ì—ì„œ ì–»ì–´ì§‘ë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì»¤ë„ í’€ì—ì„œ ì–»ì–´ì§‘ë‹ˆë‹¤. FLAGSì—ì„œ PAL_ZEROê°€ ì„¤ì •ë˜ì–´ ìˆë‹¤ë©´, í˜ì´ì§€ë“¤ì€ 0ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤. ì‚¬ìš© ê°€ëŠ¥í•œ í˜ì´ì§€ê°€ ì¶©ë¶„í•˜ì§€ ì•Šìœ¼ë©´, null í¬ì¸í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë‹¨, FLAGSì—ì„œ PAL_ASSERTê°€ ì„¤ì •ë˜ì–´ ìˆë‹¤ë©´, ì»¤ë„ì´ íŒ¨ë‹‰ ìƒíƒœì— ë¹ ì§‘ë‹ˆë‹¤.

            </aside>

            <aside> ğŸ’¡ gptì˜ ì„¤ëª…

            ì´ í•¨ìˆ˜ëŠ” **`palloc_get_multiple`**ì´ë¼ëŠ” ì´ë¦„ì˜ í˜ì´ì§€ í• ë‹¹ í•¨ìˆ˜ì…ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ì£¼ì–´ì§„ **`flags`**ì™€ **`page_cnt`**ì— ë”°ë¼ ì—°ì†ëœ ì—¬ëŸ¬ í˜ì´ì§€ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.

            í•¨ìˆ˜ ì¸ì:

            1. **`flags`**: í˜ì´ì§€ í• ë‹¹ì— ëŒ€í•œ ì˜µì…˜ì„ ë‚˜íƒ€ë‚´ëŠ” ì—´ê±°í˜•(enum)ì…ë‹ˆë‹¤. ê°€ëŠ¥í•œ ê°’ì€ **`PAL_USER`**, **`PAL_ZERO`**, **`PAL_ASSERT`**ì…ë‹ˆë‹¤.
            2. **`page_cnt`**: ì—°ì†ì ìœ¼ë¡œ í• ë‹¹í•˜ë ¤ëŠ” í˜ì´ì§€ ìˆ˜ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

            í•¨ìˆ˜ ì‘ë™ ê³¼ì •:

            1. ì‚¬ìš©ì í’€ ë˜ëŠ” ì»¤ë„ í’€ ì¤‘ ì–´ëŠ í’€ì—ì„œ í˜ì´ì§€ë¥¼ í• ë‹¹í• ì§€ ê²°ì •í•©ë‹ˆë‹¤. **`flags`**ì— **`PAL_USER`**ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ì‚¬ìš©ì í’€ì„ ì‚¬ìš©í•˜ê³ , ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì»¤ë„ í’€ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
            2. í’€ì˜ ì ê¸ˆì„ íšë“í•©ë‹ˆë‹¤.
            3. **`bitmap_scan_and_flip`** í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ì†ì ì¸ í˜ì´ì§€ë¥¼ ì°¾ê³ , í•´ë‹¹ í˜ì´ì§€ë“¤ì„ ì‚¬ìš© ì¤‘ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
            4. í’€ì˜ ì ê¸ˆì„ í•´ì œí•©ë‹ˆë‹¤.
            5. í˜ì´ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ í• ë‹¹ëœ ê²½ìš°, í˜ì´ì§€ì˜ ì‹œì‘ ì£¼ì†Œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ **`pages`**ë¥¼ NULLë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
            6. í˜ì´ì§€ê°€ í• ë‹¹ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ë§Œì•½ í˜ì´ì§€ê°€ í• ë‹¹ë˜ì—ˆë‹¤ë©´, **`flags`**ì— **`PAL_ZERO`**ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ í˜ì´ì§€ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
            7. í˜ì´ì§€ê°€ í• ë‹¹ë˜ì§€ ì•Šì•˜ê³ , **`flags`**ì— **`PAL_ASSERT`**ê°€ ì„¤ì •ë˜ì–´ ìˆë‹¤ë©´, ì»¤ë„ íŒ¨ë‹‰ ìƒíƒœë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
            8. í• ë‹¹ëœ í˜ì´ì§€ì˜ ì‹œì‘ ì£¼ì†Œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. í˜ì´ì§€ê°€ í• ë‹¹ë˜ì§€ ì•Šì•˜ë‹¤ë©´ NULLì„ ë°˜í™˜í•©ë‹ˆë‹¤.

            ì´ í•¨ìˆ˜ëŠ” ì£¼ì–´ì§„ í”Œë˜ê·¸ì™€ í˜ì´ì§€ ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í˜ì´ì§€ë¥¼ í• ë‹¹í•˜ê³  ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ë°˜í™˜ ê°’ì€ í• ë‹¹ëœ í˜ì´ì§€ ë¸”ë¡ì˜ ì‹œì‘ ì£¼ì†Œì…ë‹ˆë‹¤.

            </aside>

            ```c
            /* Obtains and returns a group of PAGE_CNT contiguous free pages.
               If PAL_USER is set, the pages are obtained from the user pool,
               otherwise from the kernel pool.  If PAL_ZERO is set in FLAGS,
               then the pages are filled with zeros.  If too few pages are
               available, returns a null pointer, unless PAL_ASSERT is set in
               FLAGS, in which case the kernel panics. */
            void *
            palloc_get_multiple (enum palloc_flags flags, size_t page_cnt) {
            	struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
            
            	lock_acquire (&pool->lock);
            	size_t page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
            	lock_release (&pool->lock);
            	void *pages;
            
            	if (page_idx != BITMAP_ERROR)
            		pages = pool->base + PGSIZE * page_idx;
            	else
            		pages = NULL;
            
            	if (pages) {
            		if (flags & PAL_ZERO)
            			memset (pages, 0, PGSIZE * page_cnt);
            	} else {
            		if (flags & PAL_ASSERT)
            			PANIC ("palloc_get: out of pages");
            	}
            
            	return pages;
            }
            ```

- process_add_file() êµ¬í˜„

    userprog/process.c

    - êµ¬í˜„ ì½”ë“œ

        ```c
        int process_add_file(struct file *f)
        {
        	struct thread *curr = thread_current();
        	curr -> fdt[curr->next_fd] = f;
        	curr->next_fd += 1;
        	return curr->next_fd - 1 ;
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [PintOS Project 2 - User Program (7) System Call(ì •ê¸€ì‚¬ê´€í•™êµ 69ì¼ì°¨ TIL) - íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ê´€ë ¨ system call êµ¬í˜„ (tistory.com)](https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-7-System-Callì •ê¸€ì‚¬ê´€í•™êµ-69ì¼ì°¨-TIL)

        ```c
        @userprog/syscall.c
        
         /* íŒŒì¼ì„ í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ fdtì— ì¶”ê°€ */
        int add_file_to_fd_table(struct file *file) {
        	struct thread *t = thread_current();
        	struct file **fdt = t->file_descriptor_table;
        	int fd = t->fdidx; //fdê°’ì€ 2ë¶€í„° ì¶œë°œ
        	
        	while (t->file_descriptor_table[fd] != NULL && fd < FDCOUNT_LIMIT) {
        		fd++;
        	}
        
        	if (fd >= FDCOUNT_LIMIT) {
        		return -1;
        	}
        	t->fdidx = fd;
        	fdt[fd] = file;
        	return fd;
        
        }
        ```

        ë…¸ì…˜ ì½”ë“œ

        ```c
        int add_file_to_fdt(struct file *file){
        	struct thread* cur = thread_current();
        	struct file** fdt = cur->fdTable;  /* í˜„ì¬ ìŠ¤ë ˆë“œì˜ íŒŒì¼ í…Œì´ë¸” */
        	int fdIdx;  /* í˜„ì¬ opení•˜ëŠ” íŒŒì¼ì´ ë°›ì„ ìƒˆ ì‹ë³„ì */
        
        	ASSERT(file != NULL);
        
        	/* íŒŒì¼ ì‹ë³„ìëŠ” ì‹ë³„ì ë²”ìœ„ ë‚´ì— ë“¤ì–´ì™€ì•¼ í•œë‹¤(1024). */
        	if (cur->fdIdx >= FDCOUNT_LIMIT)
        		return -1;
        	// í•´ë‹¹ ì—ëŸ¬ê°€ ëœ¨ëŠ” íŒŒì¼ì€ open
        
        	/* ìƒˆ íŒŒì¼ ì‹ë³„ìë¥¼ ì¸ë±ìŠ¤ë¡œ í•˜ëŠ” fdtì™€, í•´ë‹¹ íŒŒì¼ì„ ê°€ë¦¬í‚¤ê³  ìˆëŠ” í¬ì¸í„°ì™€ ë§µí•‘. 
        	   íŒŒì¼ ì‹ë³„ìë¥¼ ì§€ì •í•´ì¤€ ë‹¤ìŒì—” ê·¸ ë‹¤ìŒ íŒŒì¼ì„ ìœ„í•´ íŒŒì¼ ì‹ë³„ìë¥¼ +1 í•´ì¤€ë‹¤.*/
        	fdIdx = cur->fdIdx;
        	fdt[fdIdx] = file;
        	cur->fdIdx++;
        
        	return fdIdx;  // í˜„ì¬ ìƒˆë¡œ opení•œ íŒŒì¼ì˜ ì‹ë³„ì ë¦¬í„´
        }
        ---
        ë‹¤ë¥¸ ë²„ì „.
        int add_file_to_fdt(struct file *file)
        {
        	struct thread *cur = thread_current();
        	struct file **fdt = cur->fdTable; /* í˜„ì¬ ìŠ¤ë ˆë“œì˜ íŒŒì¼ í…Œì´ë¸” */
        	int fdIdx;						  /* í˜„ì¬ opení•˜ëŠ” íŒŒì¼ì´ ë°›ì„ ìƒˆ ì‹ë³„ì */
        
        	ASSERT(file != NULL);
        
        	while (cur->fdIdx < FDCOUNT_LIMIT && fdt[cur->fdIdx]){
        		cur->fdIdx++;
        	}
        
        	/* íŒŒì¼ ì‹ë³„ìëŠ” ì‹ë³„ì ë²”ìœ„ ë‚´ì— ë“¤ì–´ì™€ì•¼ í•œë‹¤(1024). */
        	if (cur->fdIdx >= FDCOUNT_LIMIT)
        	{
        		return -1;
        	}
        
        	/* ìƒˆ íŒŒì¼ ì‹ë³„ìë¥¼ ì¸ë±ìŠ¤ë¡œ í•˜ëŠ” fdtì™€, í•´ë‹¹ íŒŒì¼ì„ ê°€ë¦¬í‚¤ê³  ìˆëŠ” í¬ì¸í„°ì™€ ë§µí•‘. 
        	   íŒŒì¼ ì‹ë³„ìë¥¼ ì§€ì •í•´ì¤€ ë‹¤ìŒì—” ê·¸ ë‹¤ìŒ íŒŒì¼ì„ ìœ„í•´ íŒŒì¼ ì‹ë³„ìë¥¼ +1 í•´ì¤€ë‹¤.*/
        	fdt[cur->fdIdx] = file;
        	return cur->fdIdx; // í˜„ì¬ ìƒˆë¡œ opení•œ íŒŒì¼ì˜ ì‹ë³„ì ë¦¬í„´
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        int process_add_file(struct file *f)
        {
        	struct thread *curr = thread_current();
        	int findIdx = curr->next_fd; /* íƒìƒ‰ í¬ì¸í„° */
        	ASSERT(f != NULL);
        
        	while (findIdx < 128 && curr->fdt[findIdx])
        	{
        		findIdx++;
        	}
        	if (findIdx >= 128)
        	{
        		return -1;
        	}
        	curr->next_fd = findIdx;
        	curr->fdt[findIdx]=f;
        	
        	return findIdx;
        }
        ```

- process_get_file() êµ¬í˜„

    - êµ¬í˜„ ì½”ë“œ

        ```c
        struct file *process_get_file(int fd)
        {
        	struct thread *curr = thread_current();
        	if(curr -> fdt[fd])
        	{return curr -> fdt[fd];}
        	else{
        		return NULL;
        	} 
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [PintOS Project 2 - User Program (7) System Call(ì •ê¸€ì‚¬ê´€í•™êµ 69ì¼ì°¨ TIL) - íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ê´€ë ¨ system call êµ¬í˜„ (tistory.com)](https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-7-System-Callì •ê¸€ì‚¬ê´€í•™êµ-69ì¼ì°¨-TIL)

        ```c
        /*  fd ê°’ì„ ë„£ìœ¼ë©´ í•´ë‹¹ fileì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ */
        struct file *fd_to_struct_filep(int fd) {
        	if (fd < 0 || fd >= FDCOUNT_LIMIT) {
        		return NULL;
        	}
        	
        	struct thread *t = thread_current();
        	struct file **fdt = t->file_descriptor_table;
        	
        	struct file *file = fdt[fd];
        	return file;
        }
        ```

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        static struct file *find_file_by_fd(int fd){
        	struct thread* cur = thread_current();
        	
        	/* ì´ìƒí•œ ê°’ì´ ë“¤ì–´ì˜¤ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸ */
        	if (fd < 0 || fd >= FDCOUNT_LIMIT)
        		return NULL;
        
        	struct file** fdt = cur->fdTable;
        
        	return fdt[fd];
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        struct file *process_get_file(int fd)
        {
        	struct thread *curr = thread_current();
        	if (fd < 0 || fd >= 128 || !(curr -> fdt[fd])) {
        		return NULL;
        	}
        	return curr -> fdt[fd];}
        }
        ```

- process_close_file() êµ¬í˜„

    - êµ¬í˜„ ì½”ë“œ

        ```c
        void process_close_file(int fd)
        {
        	struct thread *curr = thread_current();
        	// close(curr->fdt[fd]);
        	// curr->fdt[fd] = NULL or 0; 
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        void close_file_from_fdt(int fd){
        	struct thread* cur = thread_current();
        
        	if (fd < 0 || fd >= FDCOUNT_LIMIT)
        		return;
        	
        	cur->fdTable[fd] = NULL;
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        void process_close_file(int fd)
        {
        	struct thread *curr = thread_current();
        	if (fd < 0 || fd >= FDCOUNT_LIMIT)
        		return;
        
        	curr->fdt[fd] = NULL;
        }
        ```

- process_exit()

    - êµ¬í˜„ ì½”ë“œ

        ```c
        void process_exit(void)
        {
        	struct thread *curr = thread_current();
        	int index = 2;
        	for(int i=2;i<128;i++)
        	{
        		process_close_file(i);
        	}
        	free(curr->fdt);
        	/* closeë§Œë“¤ê³  ë‹¤ì‹œ ë³¼ ì˜ˆì • ğŸ˜¡ */
        	
        
        	/* TODO: Your code goes here.
        	 * TODO: Implement process termination message (see
        	 * TODO: project2/process_termination.html).
        	 * TODO: We recommend you to implement process resource cleanup here. */
        
        	process_cleanup();
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        struct threadì— flagì‚¬ìš©

        ```c
        void process_exit (void) {
        	struct thread *curr = thread_current ();
        
        	/* í”„ë¡œì„¸ìŠ¤ì˜ ëª¨ë“  íŒŒì¼ë“¤ì„ ë‹«ì•„ì£¼ê³  fdtì˜ ë©”ëª¨ë¦¬ë„ freeí•´ì¤€ë‹¤. */
        	for (int i = 0; i < FDCOUNT_LIMIT; i++)
        		close(i);
        	palloc_free_multiple(curr->fdTable, FDT_PAGES);  // thread_create
        	
        	/* load()ì—ì„œ ì´ˆê¸°í™”í•œ í˜„ì¬ ì‹¤í–‰ë˜ê³  ìˆëŠ” í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ íŒŒì¼ë„ ë‹«ì•„ì¤€ë‹¤. */
        	file_close(curr->running);
        
        	/* í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ í˜ì´ì§€ ë””ë ‰í† ë¦¬(pml4)ì„ ì—†ì•¤ë‹¤. */
        	process_cleanup ();
        
        	/* í˜„ì¬ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆìœ¼ë¯€ë¡œ, ìì‹ ì˜ ì¢…ë£Œë¥¼ wait()í•˜ëŠ” ë¶€ëª¨ë¥¼ ìœ„í•´
        	   ë¶€ëª¨ê°€ ëŒ€ê¸°í•˜ê³  ìˆëŠ” semaì˜ valueë¥¼ UPí•´ì¤€ë‹¤. */
        	sema_up(&curr->wait_sema);
        
        	/* ê·¸ë¦¬ê³  ì™„ì „íˆ ì¢…ë£Œë˜ê¸° ì „ ìì‹ ì˜ free_semaì—ì„œ BLOCKë˜ë©´ì„œ ì¢€ë¹„ í”„ë¡œì„¸ìŠ¤ë¡œ ë‚¨ëŠ”ë‹¤.
        	   ê·¸ë˜ì•¼ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ê°€ ì•ˆì „í•˜ê²Œ ìì‹ ì˜ ì „ë‹¬ê°’ì„ ë°›ì„ ìˆ˜ ìˆë‹¤.
        	   ì „ë‹¬ê°’ì—ëŠ” ìì‹ ì˜ exit_statusì™€ child_process_list(ë¶€ëª¨ê°€ ì—¬ê¸°ì„œ ìì‹ ì„ ë¹¼ì•¼ í•¨)ì´ ìˆë‹¤.
        	   ë¶€ëª¨ê°€ sema UPí•´ì¤„ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤. */
        	sema_down(&curr->free_sema);
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        void process_exit(void)
        {
        	struct thread *curr = thread_current();
        	for (int i = 0; i < 128; i++)
        	{
        		process_close_file(i);
        	}
        	palloc_free_multiple(curr->fdt, 3);
        	/* ğŸ¤” */
        	file_close(curr->running);
        	process_cleanup();
        	sema_up(&curr->wait_sema);
        	sema_down(&curr->free_sema);
        	/* closeë§Œë“¤ê³  ë‹¤ì‹œ ë³¼ ì˜ˆì • ğŸ˜¡ */
        
        	/* TODO: Your code goes here.
        	 * TODO: Implement process termination message (see
        	 * TODO: project2/process_termination.html).
        	 * TODO: We recommend you to implement process resource cleanup here. */
        
        	process_cleanup();
        }
        ```

- userprog/exception.c/page_fault() ìˆ˜ì •

    - êµ¬í˜„ ì½”ë“œ

        ```c
        static void
        page_fault (struct intr_frame *f) {
        	bool not_present;  /* True: not-present page, false: writing r/o page. */
        	bool write;        /* True: access was write, false: access was read. */
        	bool user;         /* True: access by user, false: access by kernel. */
        	void *fault_addr;  /* Fault address. */
        
        	/* Obtain faulting address, the virtual address that was
        	   accessed to cause the fault.  It may point to code or to
        	   data.  It is not necessarily the address of the instruction
        	   that caused the fault (that's f->rip). */
        
        	fault_addr = (void *) rcr2();
        
        	/* Turn interrupts back on (they were only off so that we could
        	   be assured of reading CR2 before it changed). */
        	intr_enable ();
        
        	/* Determine cause. */
        	not_present = (f->error_code & PF_P) == 0;
        	write = (f->error_code & PF_W) != 0;
        	user = (f->error_code & PF_U) != 0;
        	if(!not_present || !write || !user)
        	{
        		exit(-1);
        	}
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        page_fault(struct intr_frame *f)
        {
        	bool not_present; /* True: not-present page, false: writing r/o page. */
        	bool write;		  /* True: access was write, false: access was read. */
        	bool user;		  /* True: access by user, false: access by kernel. */
        	void *fault_addr; /* Fault address. */
        
        	/* Obtain faulting address, the virtual address that was
        	   accessed to cause the fault.  It may point to code or to
        	   data.  It is not necessarily the address of the instruction
        	   that caused the fault (that's f->rip). */
        
        	fault_addr = (void *)rcr2();
        
        	/* Turn interrupts back on (they were only off so that we could
        	   be assured of reading CR2 before it changed). */
        	intr_enable();
        
        	/* Determine cause. */
        	not_present = (f->error_code & PF_P) == 0;
        	write = (f->error_code & PF_W) != 0;
        	user = (f->error_code & PF_U) != 0;
        	// if(!not_present || !write || !user)
        	// {
        	// 	exit(-1);
        	// }
        
        #ifdef VM
        	/* For project 3 and later. */
        	if (vm_try_handle_fault(f, fault_addr, user, write, not_present))
        		return;
        #endif
        
        	/* Count page faults. */
        	page_fault_cnt++;
        
        	/* If the fault is true fault, show info and exit. */
        	printf("Page fault at %p: %s error %s page in %s context.\\n",
        		   fault_addr,
        		   not_present ? "not present" : "rights violation",
        		   write ? "writing" : "reading",
        		   user ? "user" : "kernel");
        	// kill (f);
        	exit(-1); /* ğŸ¤” */
        ```

## ì‘ì„±í•´ì•¼ë˜ëŠ” system callí•¨ìˆ˜ (ì›”,í™”,ìˆ˜,ëª© ìš”ì¼)

userprog/syscall.c

- void halt (void)

    - êµ¬í˜„ lib/user/syscall.c

        ```c
        void halt (void) {
        	syscall0 (SYS_HALT);
        	NOT_REACHED ();
        
        	power_off();
        }
        ```

    - ì°¸ê³ 

        ```c
        /* pintos ì¢…ë£Œì‹œí‚¤ëŠ” í•¨ìˆ˜ */
        void halt(void){
        	power_off();
        }
        ```

    - ìˆ˜ì •

        ```c
        /* pintos ì¢…ë£Œì‹œí‚¤ëŠ” í•¨ìˆ˜ */
        void halt(void){
        	power_off();
        }
        ```

    - ê´€ë ¨ í•¨ìˆ˜

        qemu ì—ë®¬ë ˆì´í„°ë¥¼ ì¢…ë£Œì‹œí‚´ìœ¼ë¡œì¨ ì‹œìŠ¤í…œì„ ì¢…ë£Œ

        ```c
        void power_off (void) {
        //#ifdef FILESYS
        //	filesys_done ();
        //#endif
        
        	print_stats (); // í˜„ì¬ ì‹œìŠ¤í…œì˜ íƒ€ì´ë¨¸, ìŠ¤ë ˆë“œë‹¹ tick ìˆ˜ ë“±ì„ í˜„ì¬ ì‹œìŠ¤í…œ ì •ë³´ë“¤ì„ ì¶œë ¥í•œë‹¤.
        
        	printf ("Powering off...\\n");
        	outw (0x604, 0x2000);               /* Poweroff command for qemu */
        	for (;;);
        }
        
        ----
        # io.h/outw()
        
        /* Writes the 16-bit DATA to PORT. */
        static inline void outw (uint16_t port, uint16_t data) {
        	/* See [IA32-v2b] "OUT". */
        	asm volatile ("outw %0,%w1" : : "a" (data), "d" (port));
        }
        ```

- void exit (int status)

    - êµ¬í˜„ì½”ë“œ

        lib/user/syscall.c

        ```c
        void
        exit (int status) {
        	syscall1 (SYS_EXIT, status);
        	NOT_REACHED ();
        
        	printf("%c :exit(%d)", thread_name(), status);
        	thread_exit();
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        ```c
        void exit (int status){  // ì¢…ë£Œ statusë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤. exit(0)ì´ë©´ ì„±ê³µ, ì•„ë‹˜ ì‹¤íŒ¨
        	struct thread* cur = thread_current();
        	cur->exit_status = status;
        	printf("%s: exit(%d)\\n", cur->name, status);
        	thread_exit();  // ìŠ¤ë ˆë“œê°€ ì£½ëŠ”ë‹¤.
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        void exit (int status){  // ì¢…ë£Œ statusë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤. exit(0)ì´ë©´ ì„±ê³µ, ì•„ë‹˜ ì‹¤íŒ¨
        	struct thread* cur = thread_current();
        
        	cur->exit_status = status;
        	printf("%s: exit(%d)\\n", cur->name, status);
        	thread_exit();  // ìŠ¤ë ˆë“œê°€ ì£½ëŠ”ë‹¤.
        }
        ```

- pid_t fork (const char *thread_name);

    - êµ¬í˜„ ì½”ë“œ

        ```c
        pid_t fork(const char *thread_name)
        {
        	struct thread *curr = thread_current();
        
        	return process_fork(thread_name, &curr->tf);
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        tid_t fork (const char *thread_name, struct intr_frame *f) {
            // check_address(thread_name);
            return process_fork(thread_name, f);
        }
        ```

- int exec (const char *cmd_line);

    - êµ¬í˜„ ì½”ë“œ

        ```c
        int exec(const *cmd_line)
        {
        	struct thread *curr = thread_current();
        	tid_t pid = process_create_initd(cmd_line);	   // cmd_line parsingí•´ì„œ file_name ì¶”ì¶œí•´ì„œ ë„£ìŒ.
        												   /* sema_down ì˜›í„°  */
        	struct thread *child = get_child_process(pid); // ìƒì„±ëœ ìì‹ í”„ë¡œì„¸ìŠ¤ì˜ ë””ìŠ¤í¬ë¦½í„° ê²€ìƒ‰ ë¯¸êµ¬í˜„ ğŸ˜¡
        	int result = process_wait(child);			   // ìì‹ í”„ë¡œì„¸ìŠ¤ì˜ í”„ë¡œê·¸ë¨ ì ì¬ ëŒ€ê¸°ğŸ˜¡
        	list_push_back(&curr->children_list, &child->child_elem);
        
        	if (result = 1) // ì ì¬ ì„±ê³µì‹œ
        	{
        		return pid;
        	}
        	else
        	{ // ì ì¬ ì‹¤íŒ¨ì‹œ
        		return -1;
        	}
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        int exec(const char *cmd_line)
        {
        	check_address(cmd_line);
        
        	/* ì¸ìë¡œ ë°›ì€ íŒŒì¼ ì´ë¦„ ë¬¸ìì—´ì„ ë³µì‚¬í•˜ì—¬ ì´ ë³µì‚¬ë³¸ì„ ì¸ìë¡œ process_exec() ì‹¤í–‰*/
        	int size = strlen(cmd_line) + 1;
        	char *fn_copy = palloc_get_page(PAL_ZERO);
        	if(fn_copy == NULL)
        		exit(-1);
        	strlcpy(fn_copy, cmd_line, size);
        
        	if(process_exec(fn_copy) == -1)
        		return -1;
        	
        	/* Caller í”„ë¡œì„¸ìŠ¤ëŠ” do_iret() í›„ ëŒì•„ì˜¤ì§€ ëª»í•œë‹¤. */
        	NOT_REACHED();
        
        	return 0;  //ì´ ê°’ì€ ë¦¬í„´ë˜ì§€ ì•ŠëŠ”ë‹¤. ì¦‰, exec()ì€ ì˜¤ì§ ì—ëŸ¬ê°€ ë°œìƒí–ˆì„ ë•Œë§Œ ë¦¬í„´í•œë‹¤.
        }
        ```

    - ìˆ˜ì •

        ```c
        int exec(const char *cmd_line)
        {
        	check_address(cmd_line);
        
        	/* ì¸ìë¡œ ë°›ì€ íŒŒì¼ ì´ë¦„ ë¬¸ìì—´ì„ ë³µì‚¬í•˜ì—¬ ì´ ë³µì‚¬ë³¸ì„ ì¸ìë¡œ process_exec() ì‹¤í–‰*/
        	int size = strlen(cmd_line) + 1;
        	char *fn_copy = palloc_get_page(0);
        	if (fn_copy == NULL)
        		exit(-1);
        	strlcpy(fn_copy, cmd_line, size);
        
        	if (process_exec(fn_copy) == -1) /* process_execì—ì„œ freeí•´ì¤Œ */
        		return -1;
        
        	/* Caller í”„ë¡œì„¸ìŠ¤ëŠ” do_iret() í›„ ëŒì•„ì˜¤ì§€ ëª»í•œë‹¤. */
        	NOT_REACHED();
        
        	return 0; // ì´ ê°’ì€ ë¦¬í„´ë˜ì§€ ì•ŠëŠ”ë‹¤. ì¦‰, exec()ì€ ì˜¤ì§ ì—ëŸ¬ê°€ ë°œìƒí–ˆì„ ë•Œë§Œ ë¦¬í„´í•œë‹¤.
        }
        ```

- int wait (tid_t pid);

    userprog/syscall/c

    - êµ¬í˜„ ì½”ë“œ

        ```c
        êµ¬í˜„ ê¹œë°•í•¨ ğŸ˜œ
        ```

    - ì°¸ê³  ì½”ë“œ

        ```c
        int wait(pid_t pid)
        {
        	return process_wait(pid);
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        int wait(pid_t pid)
        {
        	return process_wait(pid);
        }
        ```

- bool create (const char *file, unsigned initial_size)

    - êµ¬í˜„ lib/user/syscall.c

        ```c
        bool
        create (const char *file, unsigned initial_size) {
        
        	syscall2(SYS_CREATE, file, initial_size);
        
        	bool success = filesys_create(file, initial_size);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	save_regi = success;
        	return success;
        }
        ```

    - ì°¸ê³ 

        ```c
        bool create (const char *file , unsigned initial_size){
        	check_address(file);
        	return filesys_create(file, initial_size);
        }
        ```

    - êµ¬í˜„ì½”ë“œ 2

        ```c
        bool create (const char *file , unsigned initial_size){
        	check_address(file);
        	return filesys_create(file, initial_size);
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        bool create (const char *file, unsigned initial_size) {
            check_address(file);
            if (filesys_create(file, initial_size)) {
                return true;
            } else {
                return false;
            }
            /*return filesys_create(file, initial_size);*/
        }
        ```

- bool remove (const char *file)

    - êµ¬í˜„ lib/user/syscall.c

        ```c
        bool
        remove (const char *file) {
        	syscall1 (SYS_REMOVE, file);
        	filesys_remove(file);
        	bool success = filesys_remove(file);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	save_regi = success;
        	return success;
        }
        ```

    - ì°¸ê³ 

        ```c
        bool remove (const char *file){
        	check_address(file);
        	return filesys_remove(file);
        }
        ```

    - ìˆ˜ì •

        ```c
        bool remove (const char *file){
        	check_address(file);
        	return filesys_remove(file);
        }
        ```

- int open (const char *file);

    - êµ¬í˜„ ì½”ë“œ

        ```c
        int
        open (const char *file) {
        	syscall1 (SYS_OPEN, file);
        	struct file *fd = filesys_open(file);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	if(fd){
        		save_regi = fd;
        		return fd;
        	}
        	else{
        		save_regi = -1;
        		return -1;
        	}
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        int open(const char *file)
        {
        	check_address(file);
        	struct file *fileobj = filesys_open(file); // í•´ë‹¹ ì´ë¦„ì„ ê°€ì§„ íŒŒì¼ì„ ì°¾ì•„ì„œ ì—°ë‹¤.
        
        	if (fileobj == NULL) // ì‹¤íŒ¨í•˜ë©´ NULLì„ ë¦¬í„´í•œë‹¤.
        		return -1;
        
        	int fd = add_file_to_fdt(fileobj); // í•´ë‹¹ íŒŒì¼ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ fdtì— ë„£ì–´ì£¼ê³  ì‹ë³„ì ë¦¬í„´
        
        	if (fd == -1)  // ì‹ë³„ì ìˆ«ì ë²”ìœ„ë¥¼ ì´ˆê³¼í•˜ë©´ í•´ë‹¹ íŒŒì¼ì„ ë‹«ì•„ì¤€ë‹¤.
        		file_close(fileobj);
        
        	return fd;
        }
        ```

    - êµ¬í˜„ ì½”ë“œ 2

        ```c
        int open(const char *file)
        {
        	struct file *fileobj = filesys_open(file);
        	if (fileobj == NULL)
        	{
        		return -1;
        	}
        	int fd = process_add_file(fileobj); // í•´ë‹¹ íŒŒì¼ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ fdtì— ë„£ì–´ì£¼ê³  ì‹ë³„ì ë¦¬í„´
        
        	// struct thread *curr = thread_current();
        	// curr->fdt[curr->next_fd] = file;
        
        	if (fd == -1)
        	{
        		file_close(fileobj);
        	}
        	return fd;
        }
        ```

    - ìˆ˜ì •ì½”ë“œ

        ```c
        int open(const char *file)
        {
        	check_address(file);
        	lock_acquire(&filesys_lock);
        	struct file *fileobj = filesys_open(file);
        	if (fileobj == NULL)
        	{
        		return -1;
        	}
        	int fd = process_add_file(fileobj); // í•´ë‹¹ íŒŒì¼ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ fdtì— ë„£ì–´ì£¼ê³  ì‹ë³„ì ë¦¬í„´
        
        	// struct thread *curr = thread_current();
        	// curr->fdt[curr->next_fd] = file;
        
        	if (fd == -1)
        	{
        		file_close(fileobj);
        	}
        	lock_release(&filesys_lock);
        	return fd;
        }
        ```

- int filesize (int fd)

    - êµ¬í˜„ lib/user/syscall.c

        ```c
        int
        filesize (int fd) {
        	syscall1 (SYS_FILESIZE, fd);
        	off_t size = file_length(fd);
        	struct intr_frame *f = &thread_current()->tf;
        	uint64_t save_regi = &f->R.rax;
        	save_regi = size;
        	return size;
        }
        ```

    - ì°¸ê³ 

        ```c
        int filesize (int fd)
        {
        	struct file* fileobj = find_file_from_fd(fd);
        
        	if (fileobj == NULL)
        		return -1;
        	
        	return file_length(fileobj);
        }
        ```

    - ìˆ˜ì •

        ```c
        int filesize (int fd)
        {
        	struct file* fileobj = find_file_from_fd(fd);
        
        	if (fileobj == NULL)
        		return -1;
        	
        	return file_length(fileobj);
        }
        ```

    - í•„ìš” í•¨ìˆ˜

        **filesys/file.c/file_length()**

        ```c
        /* Returns the size of FILE in bytes. */
        off_t file_length (struct file *file) {
        	ASSERT (file != NULL);
        	return inode_length (file->inode);
        }
        ```

        **filesys/inode.c/inode_length()**

        ```c
        /* Returns the length, in bytes, of INODE's data. */
        off_t inode_length (const struct inode *inode) {
        	return inode->data.length;
        }
        ```

- int write (int fd, const void *buffer, unsigned size)

    - êµ¬í˜„ ì½”ë“œ

        ```c
        int write(int fd, void *buffer, unsigned size)
        {
        	lock_acquire(&filesys_lock);
        	if(fd==1)
        	{
        		putbuf(buffer, size);
        		return sizeof(buffer); 
        	}
        	else
        	{
        		file_write(process_get_file(fd), buffer, size);
        		return size; //size? filesize? ğŸ˜¡
        	}
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        int write(int fd, const void *buffer, unsigned size){
        	check_address(buffer);
        	int write_count;
        	struct thread *cur = thread_current();
        
        	struct file* fileobj = find_file_by_fd(fd);
        	if (fileobj == NULL)
        		return -1;
        	
        	if (fileobj == STDOUT){
        		if (cur->stdout_count == 0){ /* ì–˜ë„ ì—†ì–´ë„ ëŒì•„ê°€ê¸´ í•œë‹¤.*/
        			NOT_REACHED();
        			remove_file_from_fdt(fd);
        			write_count = -1;
        		}
        		else{
        			/* bufferì— ìˆëŠ” ë°ì´í„°ë¥¼ size byte ë§Œí¼ consoleì— ë³´ë‚´ ì¶œë ¥í•˜ê²Œ í•œë‹¤.
        			ì¶œë ¥ ì¤‘ì—ëŠ” consoleì„ íšë“í•œ í”„ë¡œì„¸ìŠ¤ë§Œì´ consoleì— ì“¸ ìˆ˜ ìˆë‹¤. */
        			putbuf(buffer, size);
        			write_count = size;
        		}
        	}
        	else if(fileobj == STDIN){
        		write_count = -1;
        	}
        	else{
        		/* í˜„ì¬ í”„ë¡œì„¸ìŠ¤ê°€ í•´ë‹¹ íŒŒì¼ì— ë°ì´í„°ë¥¼ ì“°ëŠ” ë™ì•ˆ
        		   ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ê·¸ íŒŒì¼ì„ ì“°ë©´ ì•ˆ ë˜ë¯€ë¡œ. */
        		lock_acquire(&filesys_lock);
        		write_count = file_write(fileobj, buffer, size);
        		lock_release(&filesys_lock);
        	}
        
        	return write_count;  // ì¶œë ¥í•œ ë°ì´í„°ì˜ byteë¥¼ ë°˜í™˜í•œë‹¤.
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        int write(int fd, const void *buffer, unsigned size)
        {
        	check_address(buffer);
        	int write_count;
        	struct thread *cur = thread_current();
        
        	struct file *fileobj = process_get_file(fd);
        	if (fileobj == NULL)
        		return -1;
        
        	if (fileobj == STDOUT)
        	{
        		if (cur->stdout_count == 0)
        		{ /* ì–˜ë„ ì—†ì–´ë„ ëŒì•„ê°€ê¸´ í•œë‹¤.*/
        			NOT_REACHED();
        			process_close_file(fd);
        			write_count = -1;
        		}
        		else
        		{
        			/* bufferì— ìˆëŠ” ë°ì´í„°ë¥¼ size byte ë§Œí¼ consoleì— ë³´ë‚´ ì¶œë ¥í•˜ê²Œ í•œë‹¤.
        			ì¶œë ¥ ì¤‘ì—ëŠ” consoleì„ íšë“í•œ í”„ë¡œì„¸ìŠ¤ë§Œì´ consoleì— ì“¸ ìˆ˜ ìˆë‹¤. */
        			putbuf(buffer, size);
        			write_count = size;
        		}
        	}
        	else if (fileobj == STDIN)
        	{
        		write_count = -1;
        	}
        	else
        	{
        		/* í˜„ì¬ í”„ë¡œì„¸ìŠ¤ê°€ í•´ë‹¹ íŒŒì¼ì— ë°ì´í„°ë¥¼ ì“°ëŠ” ë™ì•ˆ
        		   ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ê·¸ íŒŒì¼ì„ ì“°ë©´ ì•ˆ ë˜ë¯€ë¡œ. */
        		lock_acquire(&filesys_lock);
        		write_count = file_write(fileobj, buffer, size);
        		lock_release(&filesys_lock);
        	}
        
        	return write_count; // ì¶œë ¥í•œ ë°ì´í„°ì˜ byteë¥¼ ë°˜í™˜í•œë‹¤.
        }
        ```

- int read(int fd, void *buffer, unsigned size)

    - êµ¬í˜„ì½”ë“œ

        ```c
        /* ì´ê±´ ë‹¤ì‹œ ìƒê°í•´ë´ì•¼ í•  ê²ƒ ê°™ì•„... íŒíŠ¸) í‘œì¤€ ì…ë ¥ */
        int read(int fd, void *buffer, unsigned size)
        {
        	lock_acquire(&filesys_lock);
        	if (fd)
        	{
        		if (!file_read(process_get_file(fd), buffer, size))
        		{
        			return -1;
        		}
        		return file_read(process_get_file(fd), buffer, size);
        	}
        	else
        	{
        		buffer = input_getc();
        		return sizeof(buffer);
        	}
        }
        ```

    - ì°¸ê³ ì½”ë“œ

        ```c
        int read(int fd, void *buffer, unsigned size) {
        	// ìœ íš¨í•œ ì£¼ì†Œì¸ì§€ë¶€í„° ì²´í¬
        	check_address(buffer); // ë²„í¼ ì‹œì‘ ì£¼ì†Œ ì²´í¬
        	check_address(buffer + size -1); // ë²„í¼ ë ì£¼ì†Œë„ ìœ ì € ì˜ì—­ ë‚´ì— ìˆëŠ”ì§€ ì²´í¬
        	unsigned char *buf = buffer;
        	int read_count;
        	
        	struct file *fileobj = fd_to_struct_filep(fd);
        
        	if (fileobj == NULL) {
        		return -1;
        	}
        
        	/* STDINì¼ ë•Œ: */
        	if (fd == STDIN_FILENO) {
        		char key;
        		for (int read_count = 0; read_count < size; read_count++) {
        			key  = input_getc();
        			*buf++ = key;
        			if (key == '\\0') { // ì—”í„°ê°’
        				break;
        			}
        		}
        	}
        	/* STDOUTì¼ ë•Œ: -1 ë°˜í™˜ */
        	else if (fd == STDOUT_FILENO){
        		return -1;
        	}
        
        	else {
        		lock_acquire(&filesys_lock);
        		read_count = file_read(fileobj, buffer, size); // íŒŒì¼ ì½ì–´ë“¤ì¼ ë™ì•ˆë§Œ lock ê±¸ì–´ì¤€ë‹¤.
        		lock_release(&filesys_lock);
        
        	}
        	return read_count;
        }
        ```

    - ìˆ˜ì •ì½”ë“œ

        ```c
        int read(int fd, void *buffer, unsigned size)
        {
        	// ìœ íš¨í•œ ì£¼ì†Œì¸ì§€ë¶€í„° ì²´í¬
        	check_address(buffer);			  // ë²„í¼ ì‹œì‘ ì£¼ì†Œ ì²´í¬
        	check_address(buffer + size - 1); // ë²„í¼ ë ì£¼ì†Œë„ ìœ ì € ì˜ì—­ ë‚´ì— ìˆëŠ”ì§€ ì²´í¬
        	unsigned char *buf = buffer;
        	int read_count;
        	struct thread *cur = thread_current();
        	struct file *fileobj = cur->fdt[fd];
        
        	if (fileobj == NULL)
        	{
        		return -1;
        	}
        
        	/* STDINì¼ ë•Œ: */
        	if (fd == 0)
        	{
        		char key;
        		for (int read_count = 0; read_count < size; read_count++)
        		{
        			key = input_getc();
        			*buf++ = key;
        			if (key == '\\0')
        			{ // ì—”í„°ê°’
        				break;
        			}
        		}
        	}
        	/* STDOUTì¼ ë•Œ: -1 ë°˜í™˜ */
        	else if (fd == 1)
        	{
        		return -1;
        	}
        
        	else
        	{
        		lock_acquire(&filesys_lock);
        		read_count = file_read(fileobj, buffer, size); // íŒŒì¼ ì½ì–´ë“¤ì¼ ë™ì•ˆë§Œ lock ê±¸ì–´ì¤€ë‹¤.
        		lock_release(&filesys_lock);
        	}
        	return read_count;
        }
        ```

- void seek (int fd, unsigned position)

    - êµ¬í˜„ ì½”ë“œ

        ```c
        void seek(int fd, unsigned position)
        {
        	file_seek(process_get_file(fd), position);
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        void seek(int fd, unsigned position){
        	struct file *fileobj = find_file_by_fd(fd);
        	
        	/* fileì´ fdtì— ì—†ê±°ë‚˜ í•´ë‹¹ íŒŒì¼ì´ í‘œì¤€ ì…ì¶œë ¥ íŒŒì¼ì¸ ê²½ìš°. */
        	if(fileobj == NULL || fileobj <= 2)
        		return;
        	
        	fileobj->pos = position;
        } 
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        void seek(int fd, unsigned position)
        {
        	struct file *fileobj = process_get_file(fd);
        	if (fileobj == NULL || fileobj < 2)
        		return;
        
        	file_seek(fileobj, position);
        }
        ```

- unsigned tell (int fd)

    - êµ¬í˜„ ì½”ë“œ

        ```c
        unsigned tell(int fd)
        {
        	file_tell(process_get_file(fd));
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        unsigned tell (int fd){
        	struct file* fileobj = find_file_by_fd(fd);
        
        	if (fileobj == NULL || fileobj <= 2)
        		return -1;
        	return file_tell(fileobj);
        }
        ```

    - ìˆ˜ì • ì½”ë“œ

        ```c
        unsigned tell(int fd)
        {
        	struct file *fileobj = process_get_file(fd);
        
        	if (fileobj == NULL || fileobj <= 2) /* ì¡°ê±´ ë¹ ì§ */
        		return -1;
        
        	return file_tell(fileobj);
        }
        ```

- void close (int fd)

    - êµ¬í˜„ ì½”ë“œ

        ```c
        void close(int fd)
        {
        	file_close(process_get_file(fd));
        }
        ```

    - ì°¸ê³  ì½”ë“œ

        [Part 3 : System Calls (notion.site)](https://www.notion.so/1e1c8c9636e74dd9ac86fba60adbe7d9)

        ```c
        void close (int fd){
        	struct thread* cur = thread_current();
        	struct file* fileobj = find_file_by_fd(fd);
        
        	if (fileobj == STDIN){  // 1
        		cur->stdin_count--;
        	}
        	if (fileobj == STDOUT) { // 2
        		cur->stdout_count--;
        	}
        
        	remove_file_from_fdt(fd);
        }
        ```

    - ìˆ˜ì •

        ```c
        void close(int fd)
        {
        	struct thread *cur = thread_current();
        	struct file *fileobj = process_get_file(fd);
        
        	if (fileobj == STDIN)
        	{
        		cur->stdin_count--;
        	}
        	if (fileobj == STDOUT)
        	{
        		cur->stdout_count--;
        	}
        
        	process_close_file(fd);
        }
        ```

## ë””ë²„ê¹… (ê¸ˆìš”ì¼)

```c
root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog# make check
cd build && make check
make[1]: Entering directory '/root/pintos-kaist/userprog/build'
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-none:args-none -- -q   -f run args-none < /dev/null 2> tests/userprog/args-none.errors > tests/userprog/args-none.output
perl -I../.. ../../tests/userprog/args-none.ck tests/userprog/args-none tests/userprog/args-none.result
FAIL tests/userprog/args-none
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-single:args-single -- -q   -f run 'args-single onearg' < /dev/null 2> tests/userprog/args-single.errors > tests/userprog/args-single.output
perl -I../.. ../../tests/userprog/args-single.ck tests/userprog/args-single tests/userprog/args-single.result
FAIL tests/userprog/args-single
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-multiple:args-multiple -- -q   -f run 'args-multiple some arguments for you!' < /dev/null 2> tests/userprog/args-multiple.errors > tests/userprog/args-multiple.output
perl -I../.. ../../tests/userprog/args-multiple.ck tests/userprog/args-multiple tests/userprog/args-multiple.result
FAIL tests/userprog/args-multiple
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-many:args-many -- -q   -f run 'args-many a b c d e f g h i j k l m n o p q r s t u v' < /dev/null 2> tests/userprog/args-many.errors > tests/userprog/args-many.output
perl -I../.. ../../tests/userprog/args-many.ck tests/userprog/args-many tests/userprog/args-many.result
FAIL tests/userprog/args-many
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-dbl-space:args-dbl-space -- -q   -f run 'args-dbl-space two  spaces!' < /dev/null 2> tests/userprog/args-dbl-space.errors > tests/userprog/args-dbl-space.output
perl -I../.. ../../tests/userprog/args-dbl-space.ck tests/userprog/args-dbl-space tests/userprog/args-dbl-space.result
FAIL tests/userprog/args-dbl-space
Run didn't shut down properly: no "Timer: # ticks" message
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/halt:halt -- -q   -f run halt < /dev/null 2> tests/userprog/halt.errors > tests/userprog/halt.output
^Cmake[1]: *** Deleting file 'tests/userprog/halt.output'
../../tests/Make.tests:75: recipe for target 'tests/userprog/halt.output' failed
make[1]: *** [tests/userprog/halt.output] Interrupt
../Makefile.kernel:10: recipe for target 'check' failed
make: *** [check] Interrupt

root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog# cd build
root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog/build# pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-single:args-single -- -q   -f run 'args-single onearg'
qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]
Kernel command line: -q -f put args-single run 'args-single onearg'
0 ~ 9fc00 1
100000 ~ 13e0000 1
Pintos booting with: 
        base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
        ext_mem: 0x100000 ~ 0x13e0000 (Usable: 19,328 kB)
Calibrating timer...  117,760,000 loops/s.
hd0:0: detected 321 sector (160 kB) disk, model "QEMU HARDDISK", serial "QM00001"
hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
hd1:0: detected 102 sector (51 kB) disk, model "QEMU HARDDISK", serial "QM00003"
Formatting file system...done.
Boot complete.
Putting 'args-single' into the file system...
Executing 'args-single onearg':
Page fault at 0x188: not present error reading page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
Page fault at 0: not present error writing page in kernel context.
main: exit(-1)
root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog/build#
pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/userprog/args-none:args-none -- -q   -f run args-none
```

- ì–¹ì–´ë³¸ í•¨ìˆ˜ë“¤

    process.c

    void argument_stack(char **parse, int count, struct intr_frame *_if)

    tid_t process_create_initd (const char *file_name) {

    tid_t process_fork(const char *name, struct intr_frame *if_ UNUSED)â†’ ì›ë˜ ë˜‘ê°™ìŒ ã…

    int process_exec (void *f_name) {

    struct thread *get_child_process(int pid)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ffc29a8-78e8-43ee-8528-b04c314abffb/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aadb0fec-adb5-4be0-b277-d1f03f1ef796/Untitled.png)

# **Process Termination Message í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ë©”ì„¸ì§€**

<aside> ğŸ’¡ í•´ì•¼í•  ì¼:  `exit` í•¨ìˆ˜ë¥¼ í˜¸ì¶œ í–ˆê±°ë‚˜ ë‹¤ë¥¸ ì–´ë–¤ ì´ìœ ë“¤ë¡œ ìœ ì € í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë  ë•Œ ë§ˆë‹¤  í”„ë¡œì„¸ìŠ¤ì˜ ì´ë¦„ê³¼ exit ì½”ë“œë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤. ë§ˆì¹˜ ì•„ë˜ printf ë¬¸ì„ í†µí•´ ì¶œë ¥ëœ ê²ƒê³¼ ê°™ì€ í˜•ì‹ìœ¼ë¡œ ë§ì´ì£ .

</aside>

- êµ¬í˜„ ì½”ë“œ

    userprog/syscall.c

    ```c
    void exit(int status)
    { // ì¢…ë£Œ statusë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤. exit(0)ì´ë©´ ì„±ê³µ, ì•„ë‹˜ ì‹¤íŒ¨
    	struct thread *cur = thread_current();
    	cur->exit_status = status;
    	printf("%s: exit(%d)\\n", thread_name(), status);
    	thread_exit(); // ìŠ¤ë ˆë“œê°€ ì£½ëŠ”ë‹¤.
    }
    ```

# **Deny Write on Executables ì‹¤í–‰ íŒŒì¼ì— ì“°ê¸° ê±°ë¶€**

- í•´ì•¼í•  ì¼

    <aside> ğŸ’¡ ì‹¤í–‰ì¤‘ì¸ íŒŒì¼, ì¦‰ ì‹¤í–‰ íŒŒì¼ì— ì“°ê¸°ë¥¼ ê±°ë¶€í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”.

    </aside>

    <aside> ğŸ’¡ ì—´ë ¤ìˆëŠ” íŒŒì¼ì— ì“°ê¸°ë¥¼ ë°©ì§€í•˜ë ¤ë©´ `file_deny_write()`  í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.

    ê·¸ë¦¬ê³  `file_allow_write()`ë¥¼ íŒŒì¼ ì•ˆì—ì„œ í˜¸ì¶œí•˜ë©´ ë‹¤ì‹œ ì“°ê¸°ê°€ ê°€ëŠ¥í•´ì§€ë„ë¡ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ì´ íŒŒì¼ì„ ì—¬ëŠ” ë˜ë‹¤ë¥¸ ë¬´ì–¸ê°€ì— ì˜í•´ ì“°ê¸°ê°€ ê±°ë¶€ë˜ì§€ë§Œ ì•ŠëŠ”ë‹¤ë©´).

    ê·¸ë¦¬ê³  íŒŒì¼ì„ ë‹«ì•„ë„ ë‹¤ì‹œ ì“°ê¸°ê°€ ê°€ëŠ¥í•´ì§€ê²Œ ë©ë‹ˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ, í”„ë¡œì„¸ìŠ¤ì˜ ì‹¤í–‰ íŒŒì¼ì— ì“°ê¸°ë¥¼ ê³„ì† ê±°ë¶€í•˜ë ¤ë©´, í”„ë¡œì„¸ìŠ¤ê°€ ëŒì•„ê°€ëŠ” ë™ì•ˆì—ëŠ” ì‹¤í–‰ íŒŒì¼ì´ ì­‰ ì—´ë ¤ ìˆê²Œë” í•´ì•¼ í•©ë‹ˆë‹¤.

    </aside>

- ê´€ë ¨ í•¨ìˆ˜

    - file_deny_write ()

        filesys/file.c

        ```c
        /* Prevents write operations on FILE's underlying inode
         * until file_allow_write() is called or FILE is closed. */
        void
        file_deny_write (struct file *file) {
        	ASSERT (file != NULL);
        	if (!file->deny_write) {
        		file->deny_write = true;
        		inode_deny_write (file->inode);
        	}
        }
        ```

    - file_allow_write ()

        filesys/file.c

        ```c
        /* Re-enables write operations on FILE's underlying inode.
         * (Writes might still be denied by some other file that has the
         * same inode open.) */
        void
        file_allow_write (struct file *file) {
        	ASSERT (file != NULL);
        	if (file->deny_write) {
        		file->deny_write = false;
        		inode_allow_write (file->inode);
        	}
        }
        ```

- êµ¬í˜„ ì½”ë“œ

    - thread êµ¬ì¡°ì²´ ì¶”ê°€

        ```c
        struct thread
        {
        	/* Owned by thread.c. */
        	tid_t tid;				   /* Thread identifier. */
        	enum thread_status status; /* Thread state. */
        	char name[16];			   /* Name (for debugging purposes). */
        	int priority;			   /* Priority. */
        
        	/* Shared between thread.c and synch.c. */
        	struct list_elem elem; /* List element. */
        
        	/* local tick */
        	int64_t wake_up_tick;
        
        	/*----------------[project1]-------------------*/
        	/* priority donaion ê´€ë ¨ element ì¶”ê°€ */
        	int init_priority;				// donationì´í›„ ìš°ì„ ìˆœìœ„ë¥¼ ì´ˆê¸°í™”í•˜ê¸° ìœ„í•´ ì´ˆê¸°ê°’ ì €ì¥
        	struct lock *wait_on_lock;		// í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°í•˜ê³  ìˆëŠ” lockìë£Œêµ¬ì¡° ì£¼ì†Œ ì €ì¥
        	struct list donations;			// multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        	struct list_elem donation_elem; // multiple donation ì„ ê³ ë ¤í•˜ê¸° ìœ„í•´ì‚¬ìš©
        	/*----------------[project1]-------------------*/
        
        	/*----------------[project2]-------------------*/
        	/* parent-children hierachy */
        	struct thread *parent_pd; // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ì˜ ë””ìŠ¤í¬ë¦½í„°
        	struct list_elem child_elem;
        	struct list children_list;
        
        	bool isload;
        	bool isexit;
        
        	struct semaphore wait_sema;
        	struct semaphore fork_sema;
        	struct semaphore free_sema;
        	int exit_status;
        
        	struct intr_frame parent_if;
        	struct semaphore exit_sema;
        	struct semaphore load_sema;
        
        	struct file **fdt;
        	int next_fd;
        	/* ğŸ¤” */
        	struct file *running; // í˜„ì¬ ìŠ¤ë ˆë“œê°€ ì‚¬ìš© ì¤‘ì¸ íŒŒì¼(loadí•˜ê³  ìˆëŠ” íŒŒì¼)
        	int stdin_count;
        	int stdout_count;
        	/*----------------[project2]-------------------*/
        #ifdef USERPROG
        	/* Owned by userprog/process.c. */
        	uint64_t *pml4; /* Page map level 4 */
        #endif
        #ifdef VM
        	/* Table for whole virtual memory owned by thread. */
        	struct supplemental_page_table spt;
        #endif
        
        	/* Owned by thread.c. */
        	struct intr_frame tf; /* Information for switching */
        	unsigned magic;		  /* Detects stack overflow. */
        };
        ```

    - init_thread() ì¶”ê°€

        ```c
        static void
        init_thread(struct thread *t, const char *name, int priority)
        {
        	ASSERT(t != NULL);
        	ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
        	ASSERT(name != NULL);
        
        	memset(t, 0, sizeof *t);
        	t->status = THREAD_BLOCKED;
        	strlcpy(t->name, name, sizeof t->name);
        	t->tf.rsp = (uint64_t)t + PGSIZE - sizeof(void *);
        	t->priority = priority;
        	t->magic = THREAD_MAGIC;
        	/*----------------[project1]-------------------*/
        	t->init_priority = priority;
        	t->wait_on_lock = NULL;
        	list_init(&t->donations);
        	/*----------------[project1]-------------------*/
        	list_init(&t->children_list);
        
        	sema_init(&t->wait_sema, 0);
        	sema_init(&t->fork_sema, 0);
        	sema_init(&t->free_sema, 0);
        	t->running = NULL;
        	t->exit_status = 0;
        	/*---------------[ì¤€ì½”]------------------------*/
        }
        ```

    - process_exit() ìˆ˜ì •

        ```c
        /* Exit the process. This function is called by thread_exit (). */
        void process_exit(void)
        {
            struct thread *curr = thread_current();
            for (int i = 0; i < FDCOUNT_LIMIT; i++)
            {
                close(i);
            }
            palloc_free_multiple(curr->fdt, FDT_PAGES);
            /* ğŸ¤” */
            file_close(curr->running);
        
            sema_up(&curr->wait_sema);
            sema_down(&curr->free_sema);
        
            process_cleanup();
        
            /* TODO: Your code goes here.
             * TODO: Implement process termination message (see
             * TODO: project2/process_termination.html).
             * TODO: We recommend you to implement process resource cleanup here. */
        }
        ```

    - load() ìˆ˜ì •

        ```c
        static bool
        load(const char *file_name, struct intr_frame *if_)
        {
            struct thread *t = thread_current();
            struct ELF ehdr;
            struct file *file = NULL;
            off_t file_ofs;
            bool success = false;
            int i;
        
            /* Allocate and activate page directory. */
            t->pml4 = pml4_create();
            if (t->pml4 == NULL)
                goto done;
            process_activate(thread_current());
        
            /* Open executable file. */
            file = filesys_open(file_name);
            if (file == NULL)
            {
                printf("load: %s: open failed\\n", file_name);
                goto done;
            }
        
            /* ì‹¤í–‰ ì¤‘ì¸ ìŠ¤ë ˆë“œ tì˜ runningì„ ì‹¤í–‰í•  íŒŒì¼ë¡œ ì´ˆê¸°í™”*/
            t->running = file;
        
            /* í˜„ì¬ ì˜¤í”ˆí•œ íŒŒì¼ì— ë‹¤ë¥¸ë‚´ìš© ì“°ì§€ ëª»í•˜ê²Œ í•¨ */
            file_deny_write(file);
        
            /* Read and verify executable header. */
            if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr || memcmp(ehdr.e_ident, "\\177ELF\\2\\1\\1", 7) || ehdr.e_type != 2 || ehdr.e_machine != 0x3E // amd64
                || ehdr.e_version != 1 || ehdr.e_phentsize != sizeof(struct Phdr) || ehdr.e_phnum > 1024)
            {
                printf("load: %s: error loading executable\\n", file_name);
                goto done;
            }
        
            /* Read program headers. */
            file_ofs = ehdr.e_phoff;
            for (i = 0; i < ehdr.e_phnum; i++)
            {
                struct Phdr phdr;
        
                if (file_ofs < 0 || file_ofs > file_length(file))
                    goto done;
                file_seek(file, file_ofs);
        
                if (file_read(file, &phdr, sizeof phdr) != sizeof phdr)
                    goto done;
                file_ofs += sizeof phdr;
                switch (phdr.p_type)
                {
                case PT_NULL:
                case PT_NOTE:
                case PT_PHDR:
                case PT_STACK:
                default:
                    /* Ignore this segment. */
                    break;
                case PT_DYNAMIC:
                case PT_INTERP:
                case PT_SHLIB:
                    goto done;
                case PT_LOAD:
                    if (validate_segment(&phdr, file))
                    {
                        bool writable = (phdr.p_flags & PF_W) != 0;
                        uint64_t file_page = phdr.p_offset & ~PGMASK;
                        uint64_t mem_page = phdr.p_vaddr & ~PGMASK;
                        uint64_t page_offset = phdr.p_vaddr & PGMASK;
                        uint32_t read_bytes, zero_bytes;
                        if (phdr.p_filesz > 0)
                        {
                            /* Normal segment.
                             * Read initial part from disk and zero the rest. */
                            read_bytes = page_offset + phdr.p_filesz;
                            zero_bytes = (ROUND_UP(page_offset + phdr.p_memsz, PGSIZE) - read_bytes);
                        }
                        else
                        {
                            /* Entirely zero.
                             * Don't read anything from disk. */
                            read_bytes = 0;
                            zero_bytes = ROUND_UP(page_offset + phdr.p_memsz, PGSIZE);
                        }
                        if (!load_segment(file, file_page, (void *)mem_page,
                                          read_bytes, zero_bytes, writable))
                            goto done;
                    }
                    else
                        goto done;
                    break;
                }
            }
        
            /* Set up stack. */
            if (!setup_stack(if_))
                goto done;
        
            /* Start address. */
            if_->rip = ehdr.e_entry;
        
            /* TODO: Your code goes here.
             * TODO: Implement argument passing (see project2/argument_passing.html). */
        
            success = true;
        
        done:
            /* We arrive here whether the load is successful or not. */
            // file_close(file);
            return success;
        }
        ```

- ì¶”ê°€ ìˆ˜ì •

    - í˜„ì¬ê¹Œì§€ êµ¬í˜„ ê²°ê³¼

        ```c
        pass tests/threads/priority-donate-chain
        pass tests/userprog/args-none
        pass tests/userprog/args-single
        pass tests/userprog/args-multiple
        pass tests/userprog/args-many
        pass tests/userprog/args-dbl-space
        pass tests/userprog/halt
        pass tests/userprog/exit
        pass tests/userprog/create-normal
        pass tests/userprog/create-empty
        pass tests/userprog/create-null
        pass tests/userprog/create-bad-ptr
        pass tests/userprog/create-long
        pass tests/userprog/create-exists
        pass tests/userprog/create-bound
        pass tests/userprog/open-normal
        pass tests/userprog/open-missing
        pass tests/userprog/open-boundary
        pass tests/userprog/open-empty
        pass tests/userprog/open-null
        pass tests/userprog/open-bad-ptr
        pass tests/userprog/open-twice
        pass tests/userprog/close-normal
        pass tests/userprog/close-twice
        pass tests/userprog/close-bad-fd
        pass tests/userprog/read-normal
        pass tests/userprog/read-bad-ptr
        pass tests/userprog/read-boundary
        pass tests/userprog/read-zero
        pass tests/userprog/read-stdout
        pass tests/userprog/read-bad-fd
        pass tests/userprog/write-normal
        pass tests/userprog/write-bad-ptr
        pass tests/userprog/write-boundary
        pass tests/userprog/write-zero
        pass tests/userprog/write-stdin
        pass tests/userprog/write-bad-fd
        pass tests/userprog/fork-once
        pass tests/userprog/fork-multiple
        pass tests/userprog/fork-recursive
        pass tests/userprog/fork-read
        pass tests/userprog/fork-close
        pass tests/userprog/fork-boundary
        pass tests/userprog/exec-once
        pass tests/userprog/exec-arg
        pass tests/userprog/exec-boundary
        pass tests/userprog/exec-missing
        pass tests/userprog/exec-bad-ptr
        pass tests/userprog/exec-read
        pass tests/userprog/wait-simple
        pass tests/userprog/wait-twice
        pass tests/userprog/wait-killed
        pass tests/userprog/wait-bad-pid
        pass tests/userprog/multi-recurse
        pass tests/userprog/multi-child-fd
        pass tests/userprog/rox-simple
        pass tests/userprog/rox-child
        pass tests/userprog/rox-multichild
        pass tests/userprog/bad-read
        pass tests/userprog/bad-write
        pass tests/userprog/bad-read2
        pass tests/userprog/bad-write2
        pass tests/userprog/bad-jump
        pass tests/userprog/bad-jump2
        pass tests/filesys/base/lg-create
        pass tests/filesys/base/lg-full
        pass tests/filesys/base/lg-random
        pass tests/filesys/base/lg-seq-block
        pass tests/filesys/base/lg-seq-random
        pass tests/filesys/base/sm-create
        pass tests/filesys/base/sm-full
        pass tests/filesys/base/sm-random
        pass tests/filesys/base/sm-seq-block
        pass tests/filesys/base/sm-seq-random
        pass tests/filesys/base/syn-read   (ëë‹¤ ì•ˆëë‹¤ í•¨ã…)
        pass tests/filesys/base/syn-remove
        FAIL tests/filesys/base/syn-write
        FAIL tests/userprog/no-vm/multi-oom
        pass tests/threads/alarm-single
        pass tests/threads/alarm-multiple
        pass tests/threads/alarm-simultaneous
        pass tests/threads/alarm-priority
        pass tests/threads/alarm-zero
        pass tests/threads/alarm-negative
        pass tests/threads/priority-change
        pass tests/threads/priority-donate-one
        pass tests/threads/priority-donate-multiple
        pass tests/threads/priority-donate-multiple2
        pass tests/threads/priority-donate-nest
        pass tests/threads/priority-donate-sema
        pass tests/threads/priority-donate-lower
        pass tests/threads/priority-fifo
        pass tests/threads/priority-preempt
        pass tests/threads/priority-sema
        pass tests/threads/priority-condvar
        pass tests/threads/priority-donate-chain
        2 of 95 tests failed.
        ```

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1587a499-d0ca-44e6-9d26-6dc8a1438542/Untitled.png)

    - make check ë©”ì„¸ì§€

        - multi-oom -solved

            ```c
            pintos -v -k -T 600 -m 20 -m 20   --fs-disk=10 -p tests/userprog/no-vm/multi-oom:multi-oom -- -q   -f run multi-oom < /dev/null 2> tests/userprog/no-vm/multi-oom.errors > tests/userprog/no-vm/multi-oom.output
            perl -I../.. ../../tests/userprog/no-vm/multi-oom.ck tests/userprog/no-vm/multi-oom tests/userprog/no-vm/multi-oom.result
            FAIL tests/userprog/no-vm/multi-oom
            run: FAIL to insert page!
            ```

            process_add_file()í•¨ìˆ˜ ë¬¸ì œ

            - ê³ ì¹˜ê¸° ì „

            ```c
            int process_add_file(struct file *f)
            {
            	struct thread *curr = thread_current();
            	int findIdx = curr->next_fd; /* íƒìƒ‰ í¬ì¸í„° */
            	// ASSERT(f != NULL);
            
            	while (findIdx < FDCOUNT_LIMIT && curr->fdt[findIdx])
            	{
            		findIdx++;
            	}
            	if (findIdx >= FDCOUNT_LIMIT)
            	{
            		return -1;
            	}
            	curr->fdt[findIdx] = f;
            	return findIdx;
            }
            ```

            - ê³ ì¹œ í›„

            ```c
            int process_add_file(struct file *f)
            {
            	struct thread *curr = thread_current();
            	struct file **fdt = curr->fdt;
            
            	// Find open spot from the front
            	while (curr->next_fd < FDCOUNT_LIMIT && fdt[curr->next_fd])
            	{
            		curr->next_fd++;
            	}
            
            	// error - fd table full
            	if (curr->next_fd >= FDCOUNT_LIMIT)
            		return -1;
            
            	fdt[curr->next_fd] = f;
            	return curr->next_fd;
            }
            ```

            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efd90f27-6dec-409a-9894-5445edc9b5f0/Untitled.png)

        - sys-read

            ```c
            pintos -v -k -T 300 -m 20   --fs-disk=10 -p tests/filesys/base/syn-read:syn-read -p tests/filesys/base/child-syn-read:child-syn-read -- -q   -f run syn-read < /dev/null 2> tests/filesys/base/syn-read.errors > tests/filesys/base/syn-read.output
            perl -I../.. ../../tests/filesys/base/syn-read.ck tests/filesys/base/syn-read tests/filesys/base/syn-read.result
            FAIL tests/filesys/base/syn-read
            run: wait for child 3 of 10 returned -1 (expected 2): FAILED
            ```

            ```c
            Kernel command line: -q -f put syn-read put child-syn-read run syn-read
            0 ~ 9fc00 1
            100000 ~ 13e0000 1
            Pintos booting with: 
                    base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
                    ext_mem: 0x100000 ~ 0x13e0000 (Usable: 19,328 kB)
            Calibrating timer...  117,760,000 loops/s.
            hd0:0: detected 321 sector (160 kB) disk, model "QEMU HARDDISK", serial "QM00001"
            hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
            hd1:0: detected 225 sector (112 kB) disk, model "QEMU HARDDISK", serial "QM00003"
            Formatting file system...done.
            Boot complete.
            Putting 'syn-read' into the file system...
            Putting 'child-syn-read' into the file system...
            Executing 'syn-read':
            (syn-read) begin
            (syn-read) create "data"
            (syn-read) open "data"
            (syn-read) write "data"
            (syn-read) close "data"
            (syn-read) exec child 1 of 10: "child-syn-read 0"
            (syn-read) exec child 2 of 10: "child-syn-read 1"
            (syn-read) exec child 3 of 10: "child-syn-read 2"
            (syn-read) exec child 4 of 10: "child-syn-read 3"
            (syn-read) exec child 5 of 10: "child-syn-read 4"
            (syn-read) exec child 6 of 10: "child-syn-read 5"
            (syn-read) exec child 7 of 10: "child-syn-read 6"
            (syn-read) exec child 8 of 10: "child-syn-read 7"
            (syn-read) exec child 9 of 10: "child-syn-read 8"
            (syn-read) exec child 10 of 10: "child-syn-read 9"
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-read: exit(-1)
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-read: exit(-1)
            child-syn-read: exit(0)
            (syn-read) wait for child 1 of 10 returned 0 (expected 0)
            child-syn-read: exit(1)
            (syn-read) wait for child 2 of 10 returned 1 (expected 1)
            child-syn-read: exit(3)
            child-syn-read: exit(2)
            (syn-read) wait for child 3 of 10 returned 2 (expected 2)
            (syn-read) wait for child 4 of 10 returned 3 (expected 3)
            child-syn-read: exit(4)
            (syn-read) wait for child 5 of 10 returned 4 (expected 4)
            child-syn-read: exit(5)
            (syn-read) wait for child 6 of 10 returned 5 (expected 5)
            (syn-read) wait for child 7 of 10 returned -1 (expected 6)
            (syn-read) wait for child 7 of 10 returned -1 (expected 6): FAILED
            child-syn-read: exit(8)
            syn-read: exit(1)
            Execution of 'syn-read' complete.
            child-syn-read: exit(9)
            Timer: 905 ticks
            Thread: 347 idle ticks, 38 kernel ticks, 520 user ticks
            hd0:0: 0 reads, 0 writes
            hd0:1: 8909 reads, 504 writes
            hd1:0: 225 reads, 0 writes
            Console: 2345 characters output
            Keyboard: 0 keys pressed
            Exception: 2 page faults
            Powering off...
            ```

            - ê³ ì¹˜ê¸°ì „

                ```c
                int write(int fd, const void *buffer, unsigned size)
                {
                	check_address(buffer);
                	int write_count;
                
                	struct file *fileobj = process_get_file(fd);
                
                	if (fd == 0)
                	{
                		return 0;
                	}
                
                	if (fileobj == NULL)
                	{
                		return -1;
                	}
                	if (fileobj == STDOUT)
                	{
                		putbuf(buffer, size);
                		write_count = size;
                	}
                	else if (fileobj == 1)
                	{
                		return -1;
                	}
                	else
                	{
                
                		lock_acquire(&filesys_lock);
                		write_count = file_write(fileobj, buffer, size);
                		lock_release(&filesys_lock);
                	}
                	return write_count; // ì¶œë ¥í•œ ë°ì´í„°ì˜ byteë¥¼ ë°˜í™˜í•œë‹¤.
                }
                ```

            - ê³ ì¹œí›„

                ```c
                int write(int fd, const void *buffer, unsigned size)
                {
                	check_address(buffer);
                	int write_count;
                
                	struct file *fileobj = process_get_file(fd);
                	
                	if (fileobj == NULL)
                	{
                		return -1;
                	}
                
                	if (fileobj == STDOUT)
                	{
                		putbuf(buffer, size);
                		write_count = size;
                	}
                	else if (fileobj == STDIN)
                	{
                		return -1;
                	}
                	else
                	{
                		lock_acquire(&filesys_lock);
                		write_count = file_write(fileobj, buffer, size);
                		lock_release(&filesys_lock);
                	}
                	return write_count; // ì¶œë ¥í•œ ë°ì´í„°ì˜ byteë¥¼ ë°˜í™˜í•œë‹¤.
                }
                ```

        - syn-write

            ```c
            pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/filesys/base/syn-write:syn-write -p tests/filesys/base/child-syn-wrt:child-syn-wrt -- -q   -f run syn-write < /dev/null 2> tests/filesys/base/syn-write.errors > tests/filesys/base/syn-write.output
            perl -I../.. ../../tests/filesys/base/syn-write.ck tests/filesys/base/syn-write tests/filesys/base/syn-write.result
            FAIL tests/filesys/base/syn-write
            run: wait for child 9 of 10 returned -1 (expected 8): FAILED
            ```

            ```c
            pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/filesys/base/syn-write:syn-write -p tests/filesys/base/child-syn-wrt:child-syn-wrt -- -q   -f run syn-write < /dev/null 2> tests/filesys/base/syn-write.errors > tests/filesys/base/syn-write.output
            perl -I../.. ../../tests/filesys/base/syn-write.ck tests/filesys/base/syn-write tests/filesys/base/syn-write.result
            FAIL tests/filesys/base/syn-write
            Kernel panic in run: PANIC at ../../threads/thread.c:227 in thread_current(): assertion `is_thread(t)' failed.
            Call stack: 0x8004217ec7 0x800420711a 0x800421d15c 0x800421d406 0x800421d022 0x800421cdf3 0x4001ce 0x400f82
            Translation of call stack:
            0x0000008004217ec7: debug_panic (lib/kernel/debug.c:32)
            0x000000800420711a: thread_current (threads/thread.c:228)
            0x000000800421d15c: check_address (userprog/syscall.c:167)
            0x000000800421d406: open (userprog/syscall.c:258)
            0x000000800421d022: syscall_handler (userprog/syscall.c:103)
            0x000000800421cdf3: no_sti (userprog/syscall-entry.o:?)
            0x00000000004001ce: (unknown)
            0x0000000000400f82: (unknown)
            ```

            ```c
            root@DESKTOP-ASKR6I0:~/pintos-kaist/userprog/build# pintos -v -k -T 60 -m 20   --fs-disk=10 -p tests/filesys/base/syn-write:syn-write -p tests/filesys/base/child-syn-wrt:child-syn-wrt -- -q   -f run syn-write
            qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]
            Kernel command line: -q -f put syn-write put child-syn-wrt run syn-write
            0 ~ 9fc00 1
            100000 ~ 13e0000 1
            Pintos booting with: 
                    base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
                    ext_mem: 0x100000 ~ 0x13e0000 (Usable: 19,328 kB)
            Calibrating timer...  130,867,200 loops/s.
            hd0:0: detected 321 sector (160 kB) disk, model "QEMU HARDDISK", serial "QM00001"
            hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
            hd1:0: detected 226 sector (113 kB) disk, model "QEMU HARDDISK", serial "QM00003"
            Formatting file system...done.
            Boot complete.
            Putting 'syn-write' into the file system...
            Putting 'child-syn-wrt' into the file system...
            Executing 'syn-write':
            (syn-write) begin
            (syn-write) create "stuff"
            (syn-write) exec child 1 of 10: "child-syn-wrt 0"
            (syn-write) exec child 2 of 10: "child-syn-wrt 1"
            (syn-write) exec child 3 of 10: "child-syn-wrt 2"
            (syn-write) exec child 4 of 10: "child-syn-wrt 3"
            (syn-write) exec child 5 of 10: "child-syn-wrt 4"
            (syn-write) exec child 6 of 10: "child-syn-wrt 5"
            (syn-write) exec child 7 of 10: "child-syn-wrt 6"
            (syn-write) exec child 8 of 10: "child-syn-wrt 7"
            (syn-write) exec child 9 of 10: "child-syn-wrt 8"
            (syn-write) exec child 10 of 10: "child-syn-wrt 9"
            child-syn-wrt: exit(0)
            (syn-write) wait for child 1 of 10 returned 0 (expected 0)
            child-syn-wrt: exit(1)
            (syn-write) wait for child 2 of 10 returned 1 (expected 1)
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-wrt: exit(-1)
            Page fault at 0x18: not present error writing page in kernel context.
            child-syn-wrt: exit(-1)
            child-syn-wrt: exit(2)
            (syn-write) wait for child 3 of 10 returned 2 (expected 2)
            (syn-write) wait for child 4 of 10 returned -1 (expected 3)
            (syn-write) wait for child 4 of 10 returned -1 (expected 3): FAILED
            syn-write: exit(1)
            Execution of 'syn-write' complete.
            Timer: 149 ticks
            Thread: 59 idle ticks, 45 kernel ticks, 45 user ticks
            hd0:0: 0 reads, 0 writes
            hd0:1: 641 reads, 515 writes
            hd1:0: 226 reads, 0 writes
            Console: 1984 characters output
            Keyboard: 0 keys pressed
            Exception: 2 page faults
            Powering off...
            ```

            **read, write ë‘˜ë‹¤ ì´ìƒí•œê±°ë³´ë‹ˆ ê°™ì´ ì“°ì´ëŠ” í•¨ìˆ˜ê°€ ë¬¸ì œë‹¤.**

            - ì˜ì‹¬ 1) get_file() ì´ìƒ - ê³ ì¹ ê²Œ ì—†

                ```c
                struct file *process_get_file(int fd)
                {
                	if (fd < 0 || fd >= FDCOUNT_LIMIT)
                	{
                		return NULL;
                	}
                	struct thread *curr = thread_current();
                	return curr->fdt[fd];
                }
                ```

            - exec_children()

                í˜„ì¬ í”„ë¡œì„¸ìŠ¤ë¥¼ `fork()`í•œ í›„ ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹¤í–‰í•˜ëŠ” ê²ƒì„ 10ë²ˆ ë°˜ë³µ

                ```c
                void
                exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
                {
                  size_t i;
                
                  for (i = 0; i < child_cnt; i++) 
                    {
                      char cmd_line[128];
                      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
                      if ((pids[i] = fork (child_name))){
                        CHECK (pids[i] != PID_ERROR,
                             "exec child %zu of %zu: \\"%s\\"", i + 1, child_cnt, cmd_line);
                      } else {
                        exec (cmd_line);
                      }
                      
                    }
                }
                ```

            - wait_children() ì—¬ê¸°ì„œ ë¬¸ì œê°€ ë‚˜ëŠ”ê±°ê°™ì€ë°â€¦

                ```c
                void
                wait_children (pid_t pids[], size_t child_cnt) 
                {
                  size_t i;
                  
                  for (i = 0; i < child_cnt; i++) 
                    {
                      int status = wait (pids[i]);
                      CHECK (status == (int) i,
                             "wait for child %zu of %zu returned %d (expected %zu)",
                             i + 1, child_cnt, status, i);
                    }
                }
                ```

            - wait() syscall í™•ì¸ â†’ ë¬¸ì œì—†ìŒ

            priority ê´€ë ¨ ë‹¤ í™•ì¸ ë¬¸ì œì—†ìŒ

            wait sema ë¬¸ì œì—†ìŒ. list orderë¬¸ì œì—†ìŒ

            yieldê´€ë ¨ !!!ë¬¸ì œ ìˆìŒ!!!!  ë™ì˜ìƒ ì°ì–´ë†“

            - test_max_priority(void) ê³ ì¹˜ê¸° ì „

                ```c
                void test_max_priority(void)
                {
                	if (list_empty(&ready_list) || intr_context())
                	{
                		return;
                	}
                	int run_priority = thread_current()->priority;
                	struct list_elem *e = list_begin(&ready_list);
                	struct thread *t = list_entry(e, struct thread, elem);
                	if (run_priority <= thread_get_priority())
                	{
                		thread_yield();
                	}
                }
                ```

            - test_max_priority(void) ê³ ì¹œ í›„

                ```c
                void test_max_priority(void)
                {
                	if (list_empty(&ready_list) || intr_context())
                	{
                		return;
                	}
                	int run_priority = thread_current()->priority;
                	struct list_elem *e = list_begin(&ready_list);
                	struct thread *t = list_entry(e, struct thread, elem);
                	if (t->priority > thread_get_priority())
                	{
                		thread_yield();
                	}
                }
                ```

    - ê²°ê³¼

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/119ca5dc-d8c3-437d-aeb8-60c2c52066df/Untitled.png)

- error log

    - make ì‹¤íŒ¨: include fileë¬¸ì œ

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/282188be-815e-402b-81d1-8e6f82a333d0/Untitled.png)

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c4b69c2-da22-4bb5-ad78-b03d0e407d3f/Untitled.png)

    - kernel panic -backtraceì‚¬ìš©ë²•

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/871395c0-e7c1-43d1-ae5e-9f6e99269e53/Untitled.png)

- pml4_create()

    threads/mmu.c

    ```c
    uint64_t *
    pml4_create (void) {
    	uint64_t *pml4 = palloc_get_page (0);
    	if (pml4)
    		memcpy (pml4, base_pml4, PGSIZE);
    	return pml4;
    }
    ```

- ê³µë¶€í•œ ë‚´ìš©: ë™ë¹ˆë‚˜ system call

    https://youtu.be/PsXXjNL_ogc

    - resister ì¢…ë¥˜

        rax: ì‹œìŠ¤í…œì½œì˜ ì‹¤ì§ˆì ì¸ ë²ˆí˜¸ë¥¼ ê°€ë¥´í‚¤ëŠ” ë²ˆí˜¸ì´ì, ê·¸ ê²°ê³¼ê°€ ë‹´ê¸°ëŠ” resister

        rbx: base resister, ë©”ëª¨ë¦¬ ì§€ì • ì‹œ ì‚¬ìš©

        rcx: counter resister, ì£¼ë¡œ ë°˜ë³µë¬¸ì— ì‚¬ìš©

        rdx: data resister, ì—°ì‚°ì„ ìˆ˜í–‰í•  ë•Œ raxì™€ í•¨ê»˜ ë§ì´ ì‚¬ìš©

        ì—¬ê¸°ê¹Œì§€ê°€ ë°ì´í„° ë ˆì§€ìŠ¤í„°

        ------

        rsi: ë©”ëª¨ë¦¬ë¥¼ ì´ë™í•˜ê³  ë¹„êµí•  ë•Œ ê·¸ ì¶œë°œì§€ ì£¼ì†Œ

        rdi:  ë©”ëª¨ë¦¬ë¥¼ ì´ë™í•˜ê³  ë¹„êµí•  ë•Œ ê·¸ ëª©ì ì§€ ì£¼ì†Œ

        rbp: í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„°ë‚˜ ë³€ìˆ˜ì˜ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¬ ë•Œ ì‚¬ìš©

        rsp: stackì˜ ì‚½ì… ë° ì‚­ì œ ëª…ë ¹ì— ì˜í•´ë³€ê²½ë˜ëŠ” ìŠ¤íƒì—ì„œ ê°€ì¥ ìœ„ì— ìˆëŠ” ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¬ ë•Œ ì‚¬ìš©

        ì—¬ê¸°ê¹Œì§€ê°€ í¬ì¸í„° ë ˆì§€ìŠ¤í„°: íŠ¹ì •í•œ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” ë ˆì§€ìŠ¤í„° 4ê°€ì§€

        ------

        r8~r15 : í•¨ìˆ˜ì˜ ë§¤ê°œ ë³€ìˆ˜ë¡œ ì‚¬ìš©

        ------

    - ì‹œìŠ¤í…œì½œ ê³¼ì •

        %rax ì— ê·¸ ë²ˆí˜¸ê°€ ë‹´ê¸´ systemcallì„ ë¶€ë¥´ê²Œë¨.

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ff9b48b-84ad-480f-915e-9ab28097e825/Untitled.png)

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8e92283-53aa-42f4-8b44-dfedc7cecc6a/Untitled.png)

        syscall1: write()

        syscall60: exit()

- ê³µë¶€í•œ ë‚´ìš©: notionì‹œìŠ¤í…œì½œ ê³¼ì •

    - ì‚¬ìš©ì í”„ë¡œê·¸ë¨ì´ ì‹œìŠ¤í…œ ì½œì„ í˜¸ì¶œí•œë‹¤.

        ```c
        write (STDOUT_FILENO, buf, strlen (buf));
        ```

    - ì‚¬ìš©ì í”„ë¡œê·¸ë¨ ë¼ì´ë¸ŒëŸ¬ë¦¬(**syscall.c**)ê°€ **í•´ë‹¹ ì‹œìŠ¤í…œ ì½œì˜ ë„˜ë²„, ì¸ìë“¤, í•´ë‹¹ í”„ë¡œê·¸ë¨ì˜ ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„**ì„ ì •í•´ì§„ ìˆœì„œëŒ€ë¡œ **ë ˆì§€ìŠ¤í„°ì— ì±„ì›Œì¤€ë‹¤.** ê·¸ë¦¬ê³  `syscall` ëª…ë ¹ì–´ë¥¼ CPUì—ê²Œ ë•Œë ¤ì¤€ë‹¤. ì†Œí”„íŠ¸ì›¨ì–´ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒë˜ë©´ì„œ CPUê°€ ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜ëœë‹¤.

        - **lib/user/syscall.c**

            ```c
            __attribute__((always_inline))
            static __inline int64_t syscall (uint64_t num_, uint64_t a1_, uint64_t a2_,
            		uint64_t a3_, uint64_t a4_, uint64_t a5_, uint64_t a6_) {
            	int64_t ret;
            	register uint64_t *num asm ("rax") = (uint64_t *) num_;
            	register uint64_t *a1 asm ("rdi") = (uint64_t *) a1_;
            	register uint64_t *a2 asm ("rsi") = (uint64_t *) a2_;
            	register uint64_t *a3 asm ("rdx") = (uint64_t *) a3_;
            	register uint64_t *a4 asm ("r10") = (uint64_t *) a4_;
            	register uint64_t *a5 asm ("r8") = (uint64_t *) a5_;
            	register uint64_t *a6 asm ("r9") = (uint64_t *) a6_;
            
            	/* 3. ê°ê°ì˜ ë ˆì§€ìŠ¤í„°ì— ì°¨ë¡€ëŒ€ë¡œ ì‹œìŠ¤í…œ ì½œ ë„˜ë²„ë¶€í„° ê° ì¸ìë“¤ì„ ì €ì¥í•œë‹¤. */
            	__asm __volatile(
            			"mov %1, %%rax\\n"
            			"mov %2, %%rdi\\n"
            			"mov %3, %%rsi\\n"
            			"mov %4, %%rdx\\n"
            			"mov %5, %%r10\\n"
            			"mov %6, %%r8\\n"
            			"mov %7, %%r9\\n"
            			"syscall\\n"    // 4. ì €ì¥ í›„ syscall instructionì„ ë•Œë¦°ë‹¤. ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜.
            			: "=a" (ret)
            			: "g" (num), "g" (a1), "g" (a2), "g" (a3), "g" (a4), "g" (a5), "g" (a6)
            			: "cc", "memory");
            	return ret;
            }
            
            // asm volatile( asms : output : input : clober )
            // <http://wiki.kldp.org/KoreanDoc/html/EmbeddedKernel-KLDP/app3.basic.html>
            
            ....
            /* 1. í•´ë‹¹ ì‹œìŠ¤í…œ ì½œì„ ì°¾ê³  */
            int write (int fd, const void *buffer, unsigned size) {
            	return syscall3 (SYS_WRITE, fd, buffer, size);
            }
            ...
            /* 2. í˜•ì‹ì— ë§ê²Œ ë³€í™˜ */
            #define syscall3(NUMBER, ARG0, ARG1, ARG2) ( \\
            		syscall(((uint64_t) NUMBER), \\
            			((uint64_t) ARG0), \\
            			((uint64_t) ARG1), \\
            			((uint64_t) ARG2), 0, 0, 0))
            ```

    - **userprog/syscall-entry.S**

        **Previllege Levelì„ ì»¤ë„ ëª¨ë“œ(Ring 0)ìœ¼ë¡œ ì˜¬ë¦°ë‹¤.** ì´ ë•Œ ì›ë˜ Caller ì‚¬ìš©ì ìŠ¤íƒ í¬ì¸í„°ë¥¼ RBXì— ì €ì¥í•´ë‘”ë‹¤.

        ```c
        #include "threads/loader.h"
        .text
        .globl syscall_entry
        .type syscall_entry, @function
        syscall_entry:
        	movq %rbx, temp1(%rip)
        	movq %r12, temp2(%rip)     /* callee saved registers */
        	movq %rsp, %rbx            /* Store userland rsp    */
        	movabs $tss, %r12  // í•´ë‹¹ ì»¤ë„ í”„ë¡œì„¸ìŠ¤ì˜ TSSì˜ ì£¼ì†Œë¥¼ ë°›ì•„ì˜¨ë‹¤.
        	movq (%r12), %r12
        	movq 4(%r12), %rsp 
          // TSSì— ì €ì¥ë˜ì–´ ìˆë˜ RSP0(ì»¤ë„ ìŠ¤íƒ ì‹œì‘ì£¼ì†Œ)ì˜ ì£¼ì†Œë¥¼ RSPë¡œ ì˜®ê¸´ë‹¤.
        ```

        **CPUì™€ OSê°€** ìë™ìœ¼ë¡œ ì¸í„°ëŸ½íŠ¸ ë˜ê¸° ì „ ì¸í„°ëŸ½íŠ¸ ë‹¹í•œ í”„ë¡œì„¸ìŠ¤(ì»¤ë„ì´ë“  ì‚¬ìš©ìë“ )ì˜ **Contextë¥¼ í”„ë¡œì„¸ìŠ¤ ìì‹ ì˜ ì»¤ë„ ìŠ¤íƒì—** **ì €ì¥**í•´ë‘”ë‹¤. ì´ë¥¼ í†µí•´ ì¸í„°ëŸ½íŠ¸ê°€ ëë‚˜ë©´ ë‹¤ì‹œ ì¸í„°ëŸ½íŠ¸ ëœ Taskë¡œ ë˜ëŒì•„ì˜¬ ìˆ˜ ìˆë‹¤.

        ì¼ë‹¨ ì´ ë°‘ 5ê°œ ë ˆì§€ìŠ¤í„° ê°’ì€ **CPUê°€ push**í•´ì£¼ëŠ” ë ˆì§€ìŠ¤í„° ê°’ì´ë‹¤.

        1. %ss
        2. %rsp
        3. %eflags
        4. %cs
        5. %rip

        `RIP`ë¥¼ í†µí•´ ì¸í„°ëŸ½íŠ¸ í›„ ë‹¤ì‹œ ë˜ëŒì•„ê°€ì•¼ í•˜ëŠ” ì¸ìŠ¤íŠ¸ëŸ­ì…˜ì˜ ì£¼ì†Œë¥¼ ì•Œ ìˆ˜ ìˆë‹¤. ë˜í•œ `RSP`ëŠ” ì»¤ë„ ìŠ¤ë ˆë“œì˜ ìŠ¤íƒ ìµœìƒë‹¨ì„ ê°€ë¦¬í‚¨ë‹¤(so we can return to the exact chain of function calls when the interrupt happened).

        ```c
        	/* Now we are in the kernel stack ì—¬ê¸°ì„œ ì»¤ë„ ìŠ¤íƒìœ¼ë¡œ ë°”ë€ë‹¤. */
        	/* ì—¬ê¸°ì„œë¶€í„° ìœ ì € í”„ë¡œì„¸ìŠ¤ì˜ ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„ì„ ì»¤ë„ ìŠ¤íƒì— ìˆœì„œëŒ€ë¡œ pushí•œë‹¤. */
        	push $(SEL_UDSEG)      /* if->ss, ìœ ì € ìŠ¤íƒ ë©”ëª¨ë¦¬ ê³µê°„ ì£¼ì†Œ */
        	push %rbx              /* if->rsp, RBXì— ëŒì•„ê°€ì•¼ í•  ìœ ì € ë©”ëª¨ë¦¬ì˜ RSP ê°’ì„ ì €ì¥í•œë‹¤. */
        	push %r11              /* if->eflags */
        	push $(SEL_UCSEG)      /* if->cs, ìœ ì € ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸ ë©”ëª¨ë¦¬ ì‹œì‘ ì£¼ì†Œ */
        	push %rcx              /* if->rip, RCXì— ëŒì•„ê°€ì•¼ í•  ë‹¤ìŒ PC ê°’(RIP)ì„ ì €ì¥í•œë‹¤. */
        	subq $16, %rsp         /* skip error_code, vec_no */
        ```

        **OS(intr_enrty)ê°€** ì»¤ë„ ìŠ¤íƒì— ë˜ ì¶”ê°€ì ì¸ ë ˆì§€ìŠ¤í„° ê°’ì„ ë‹´ì•„ì¤€ë‹¤.

        ```c
        	push $(SEL_UDSEG)      /* if->ds */
        	push $(SEL_UDSEG)      /* if->es */
        	push %rax
        	movq temp1(%rip), %rbx  /* ì¸ìë“¤ë„ ì»¤ë„ ìŠ¤íƒì— pushí•œë‹¤. */
        	push %rbx
        	pushq $0
        	push %rdx
        	push %rbp
        	push %rdi
        	push %rsi
        	push %r8
        	push %r9
        	push %r10
        	pushq $0 /* skip r11 */
        	movq temp2(%rip), %r12
        	push %r12
        	push %r13
        	push %r14
        	push %r15
        ```

        <aside> ğŸ’¡ ì¦‰, ë‹¤ì‹œ ë§í•´ ì¸í„°ëŸ½íŠ¸ ì‹œ ì¸í„°ëŸ½íŠ¸ ë‹¹í•œ í”„ë¡œì„¸ìŠ¤ëŠ” ì¸í„°ëŸ½íŠ¸ ë‹¹í•˜ê¸° ì§ì „ CPU ë ˆì§€ìŠ¤í„°ì— ë‹´ê¸´ ì •ë³´ë“¤ì„ ìì‹ ì˜ ì»¤ë„ ìŠ¤ë ˆë“œ ìŠ¤íƒì— ë‹´ëŠ”ë‹¤.

        </aside>

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c174134-be85-48ac-a4b9-2711eade1c5c/Untitled.png)

        ì»¤ë„ ìŠ¤íƒì— í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ì˜ ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„ì„ ì°¨ê³¡ì°¨ê³¡ ìŒ“ì•˜ìœ¼ë©´, RDIë¥¼ RSPì™€ ê°™ì€ ê°’ìœ¼ë¡œ ë§ì¶°ì¤Œìœ¼ë¡œì¨ ë°”ë¡œ ì „ê¹Œì§€ ìš°ë¦¬ê°€ ìŒ“ì€ ì»¤ë„ ìŠ¤íƒì˜ í¬ì¸í„°ë¥¼ ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„ í•¨ìˆ˜(`void intr_handler(struct intr_frame *frame)`)ì˜ argumentë¡œ ë„£ì–´ì¤€ë‹¤.

        ```c
        	movq %rsp, %rdi  
        	// ì´ì œ rdiëŠ” rspê°€ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¨ë‹¤. 
          // ì¦‰, ì•ìœ¼ë¡œ CALLí•  í•¨ìˆ˜ì˜ ì²« ë²ˆì§¸ ì¸ìê°€ 
          // ìŠ¤íƒì— ìŒ“ì—¬ ìˆëŠ” ë°ì´í„°(ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„)ì˜ ì‹œì‘ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¨ë‹¤.
        check_intr:
        	btsq $9, %r11          /* Check whether we recover the interrupt */
        	jnb no_sti
        	sti                    /* restore interrupt */
        ```

        ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„ìœ¼ë¡œ ì¸ìë¥¼ ì„¤ì •í–ˆìœ¼ë©´ ì´ì œ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ë¥¼ ë¶€ë¥¸ë‹¤.

        ```c
        no_sti:
        	movabs $syscall_handler, %r12   
        	call *%r12             // ì‹œìŠ¤í…œ ì½œ í•¸ë“¤ëŸ¬ë¥¼ ë¶€ë¥¸ë‹¤!
        ```

        ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ê°€ ì‘ì—…ì„ ì²˜ë¦¬í•œ í›„, ì•„ê¹Œ ì»¤ë„ ìŠ¤íƒì— ìš°ë¦¬ê°€ ìŒ“ì•˜ë˜ ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„ì— ëŒ€í•œ ì •ë³´ë“¤ì„ ë‹¤ ë ˆì§€ìŠ¤í„°ì— ì§‘ì–´ë„£ìœ¼ë©´ì„œ ìŠ¤íƒì„ ì§€ì›Œì¤€ë‹¤. CPUê°€ ìŒ“ì•˜ë˜ ì›ë˜ Callerì˜ ë ˆì§€ìŠ¤í„° ê°’ë“¤ì„ ë‹¤ì‹œ ì›ë³µí•˜ëŠ” ê³¼ì •ì´ë‹¤.

        ```c
        	popq %r15
        	popq %r14
        	popq %r13
        	popq %r12
        	popq %r11
        	popq %r10
        	popq %r9
        	popq %r8
        	popq %rsi
        	popq %rdi
        	popq %rbp
        	popq %rdx
        	popq %rcx
        	popq %rbx
        	popq %rax
        	addq $32, %rsp
        	popq %rcx              /* if->rip */
        	addq $8, %rsp
        	popq %r11              /* if->eflags */
        	popq %rsp              /* if->rsp */
        ```

        - Callerë¡œ ë˜ëŒì•„ê°„ë‹¤.

        ```c
        	sysretq        // ë¦¬í„´.
        
        .section .data
        .globl temp1
        temp1:
        .quad	0
        .globl temp2
        temp2:
        .quad	0
        ```

    <aside> ğŸ’¡ **ì‹œìŠ¤í…œ ì½œ ì—”íŠ¸ë¦¬ì™€ do_iret()ì˜ ì°¨ì´ëŠ”?** do_iret()ì€ ì¸í„°ëŸ½íŠ¸ í”„ë ˆì„ì„ ë ˆì§€ìŠ¤í„°ì— ë„£ì–´ ì‹¤í–‰ì‹œí‚¤ê³  ë‚˜ë©´ ë‹¤ì‹œ ê·¸ ì´ì „ í”„ë¡œì„¸ìŠ¤ë¡œ ë˜ëŒì•„ì˜¤ì§€ ì•ŠëŠ”ë‹¤.

    </aside>

    - ì‹œìŠ¤í…œ ì½œ í•¸ë“¤ëŸ¬ëŠ” ì‹œìŠ¤í…œ ì½œ ë„˜ë²„ë¥¼ í™•ì¸í•´ ì‹œìŠ¤í…œ ì½œì˜ ì¢…ë¥˜ë¥¼ í™•ì¸í•œ í›„, í•´ë‹¹ ì‹œìŠ¤í…œ ì½œì— ë§ëŠ” í•¨ìˆ˜ í˜¹ì€ ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.

        - **userprog/syscall.c**

            ```c
            /* syscall_handlerì˜ ì¸ìëŠ” í•˜ë‚˜. ê·¸ ì¸ìëŠ” rdiì—ì„œ ê°€ì ¸ì˜¨ë‹¤. 
               */
            void syscall_handler (struct intr_frame *f UNUSED) {
            	// TODO: Your implementation goes here.
            	char *f_copy;
            
            	switch(f->R.rax) {
            		case SYS_HALT:
            			halt();
            			break;
            		case SYS_EXIT:
            			exit(f->R.rdi);
            			break;
            		case SYS_CREATE:
            			f->R.rax = create(f->R.rdi, f->R.rsi);
            			break;
            ...
            }
            ```

    - ë¦¬í„´ê°’ì„ RAX ë ˆì§€ìŠ¤í„°ì— ì €ì¥í•œ ë‹¤ìŒ ì‚¬ìš©ì í”„ë¡œê·¸ë¨ì— ëŒë ¤ì¤€ë‹¤. ì»¤ë„ì—ì„œ êµ¬ì²´ì ìœ¼ë¡œ ì–´ë–»ê²Œ ëŒë ¤ì£¼ëŠ”ì§€ëŠ” ëª°ê² ìŒ.

        - **lib/user/syscall.c**

            ```c
            __attribute__((always_inline))
            static __inline int64_t syscall (uint64_t num_, uint64_t a1_, uint64_t a2_,
            		uint64_t a3_, uint64_t a4_, uint64_t a5_, uint64_t a6_) {
            	int64_t ret;
            	register uint64_t *num asm ("rax") = (uint64_t *) num_;
            	register uint64_t *a1 asm ("rdi") = (uint64_t *) a1_;
            	register uint64_t *a2 asm ("rsi") = (uint64_t *) a2_;
            	register uint64_t *a3 asm ("rdx") = (uint64_t *) a3_;
            	register uint64_t *a4 asm ("r10") = (uint64_t *) a4_;
            	register uint64_t *a5 asm ("r8") = (uint64_t *) a5_;
            	register uint64_t *a6 asm ("r9") = (uint64_t *) a6_;
            
            	__asm __volatile(
            			"mov %1, %%rax\\n"
            			"mov %2, %%rdi\\n"
            			"mov %3, %%rsi\\n"
            			"mov %4, %%rdx\\n"
            			"mov %5, %%r10\\n"
            			"mov %6, %%r8\\n"
            			"mov %7, %%r9\\n"
            			"syscall\\n"    
            			: "=a" (ret)  // ë¦¬í„´ê°’ì„ retì´ë¼ëŠ” ë³€ìˆ˜ì— ë„£ê³ 
            			: "g" (num), "g" (a1), "g" (a2), "g" (a3), "g" (a4), "g" (a5), "g" (a6)
            			: "cc", "memory");
            	return ret;  // ë¦¬í„´í•œë‹¤.
            }
            
            ....
            
            int write (int fd, const void *buffer, unsigned size) {
            	return syscall3 (SYS_WRITE, fd, buffer, size);  // ë¦¬í„´ëœë‹¤.
            }
            ```

    x86ê³¼ëŠ” ë‹¤ë¥´ê²Œ x86_64 ì‹œìŠ¤í…œì—ì„œëŠ” `syscall`ì´ë¼ëŠ” íŠ¹ë³„í•œ ëª…ë ¹ì–´ë¥¼ ì œê³µí•œë‹¤. x86ì—ì„œëŠ” ê·¸ëƒ¥ ì¸í„°ëŸ½íŠ¸ ë²ˆí˜¸ê°€ int 0x80ì´ë‹¤. `syscall` ëª…ë ¹ì–´ëŠ” ì‹œìŠ¤í…œ ì½œ í•¸ë“¤ëŸ¬ë¥¼ ë¶€ë¥¼ ìˆ˜ ìˆëŠ” ê°€ì¥ ë¹ ë¥¸ ë°©ë²•ì´ë‹¤.

    ì‚¬ìš©ì í”„ë¡œê·¸ë¨ì€ syscall ëª…ë ¹ì–´ë¥¼ í†µí•´ ì‹œìŠ¤í…œ ì½œì„ ë³´ë‚¼ ìˆ˜ ìˆë‹¤. ì´ ë•Œ ë‹¤ë¥¸ í•¨ìˆ˜ë“¤ì„ í˜¸ì¶œí•  ë•Œì™€ ë¹„ìŠ·í•˜ê²Œ ì¸ìë“¤ê³¼ ë¦¬í„´ê°’ì´ ë ˆì§€ìŠ¤í„°ì— ì €ì¥ë˜ëŠ”ë°, ë”± ë‘ ê°€ì§€ê°€ ë‹¤ë¥´ë‹¤.

    - `%rax`ì—ëŠ” **ì‹œìŠ¤í…œ ì½œ ë„˜ë²„**ê°€ ì €ì¥ëœë‹¤(ë³´í†µì˜ í•¨ìˆ˜ë¼ë©´ ì´ ìë¦¬ì— calleeì˜ ë°˜í™˜ê°’ì„ ì €ì¥í•œë‹¤).
    - **4ë²ˆì§¸ ì¸ì**ëŠ” `%rcx`ê°€ ì•„ë‹Œ `**%r10`ì—** ì €ì¥ëœë‹¤(ì›ë˜ ë³´í†µì˜ í•¨ìˆ˜ë¼ë©´  `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8` ê·¸ë¦¬ê³  `%r9`ì— ì €ì¥ëœë‹¤).

    ì‹œìŠ¤í…œ ì½œì„ ë¶€ë¥¸ ì‚¬ìš©ì í•¨ìˆ˜ì˜ ë ˆì§€ìŠ¤í„° ê°’ì€  `struct intr_frame`ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

    ê·¸ë¦¬ê³  ë¦¬í„´ê°’ì´ ìˆëŠ” ì‹œìŠ¤í…œ ì½œì˜ ê²½ìš° ê·¸ ë¦¬í„´ê°’ì„ í•´ë‹¹ êµ¬ì¡°ì²´ì˜ `rax`ë¥¼ ìˆ˜ì •í•´ì„œ ì»¤ë„ì´ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

- ì°¸ê³  ë¸”ë¡œê·¸

    https://woonys.tistory.com/entry/PintOS-Project-2-User-Program-3-System-Callì •ê¸€ì‚¬ê´€í•™êµ-65ì¼ì°¨-TIL

- ê·¸ ì™¸

    - **x86-64 Calling Convention**

        x86-64 í˜¸ì¶œ ê·œì•½ì€ í•¨ìˆ˜ í˜¸ì¶œ ë°©ì‹ì„ ì •ì˜í•˜ëŠ” ê·œì¹™ ì„¸íŠ¸ì…ë‹ˆë‹¤. í˜¸ì¶œìì™€ í”¼í˜¸ì¶œì ê°„ì˜ ì¸ì ì „ë‹¬, ìŠ¤íƒ ë° ë ˆì§€ìŠ¤í„° ì‚¬ìš© ë° ê´€ë¦¬, ë°˜í™˜ ê°’ ì²˜ë¦¬ ë“±ì„ í¬í•¨í•©ë‹ˆë‹¤. ì´ ê·œì•½ì€ x86-64 ì•„í‚¤í…ì²˜ì—ì„œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì— í•„ìˆ˜ì ì¸ ë¶€ë¶„ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.

    - ELF

        ELF ë°”ì´ë„ˆë¦¬(=ELF ì‹¤í–‰íŒŒì¼)ë“¤ì„ ë¡œë“œí•˜ê³  í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤

        ELFëŠ” ë§ì€ ìš´ì˜ì²´ì œì—ì„œ ëª©ì  íŒŒì¼, ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬, ê·¸ë¦¬ê³  ì‹¤í–‰ íŒŒì¼ë“¤ì„ ìœ„í•´ ì‚¬ìš©ë˜ëŠ” íŒŒì¼ í¬ë§·

    - GDT

        GDTëŠ” Global Descriptor Tableì˜ ì•½ìë¡œ, x86 ì•„í‚¤í…ì²˜ì—ì„œ ë©”ëª¨ë¦¬ ë³´í˜¸ ë° ê°€ìƒ ë©”ëª¨ë¦¬ ê´€ë¦¬ì— ì‚¬ìš©ë˜ëŠ” ë°ì´í„° êµ¬ì¡°ì…ë‹ˆë‹¤. GDTëŠ” ë©”ëª¨ë¦¬ì— ì €ì¥ëœ ì„¸ê·¸ë¨¼íŠ¸ ë””ìŠ¤í¬ë¦½í„°ì˜ ë°°ì—´ë¡œ, ê° ë””ìŠ¤í¬ë¦½í„°ëŠ” íŠ¹ì • ì„¸ê·¸ë¨¼íŠ¸ì˜ ë²”ìœ„ì™€ ì†ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” ì •ë³´ë¥¼ ë‹´ê³  ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ìš´ì˜ì²´ì œëŠ” ê°ê°ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ì ‘ê·¼ ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ ì˜ì—­ì„ ì œí•œí•˜ê³ , í”„ë¡œì„¸ìŠ¤ê°„ì˜ ì¶©ëŒì„ ë°©ì§€í•˜ë©°, ê°€ìƒ ë©”ëª¨ë¦¬ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤. GDTëŠ” ìš´ì˜ì²´ì œì—ì„œ ì´ˆê¸°í™”ë˜ê³  ê´€ë¦¬ë˜ë©°, ì‚¬ìš©ì í”„ë¡œì„¸ìŠ¤ëŠ” GDTì— ì§ì ‘ ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

    - TSS

        Task-State Segment (TSS)ì€ x86 ì•„í‚¤í…ì²˜ì—ì„œ ì‚¬ìš©ë˜ì—ˆë˜ íƒœìŠ¤í¬ ìŠ¤ìœ„ì¹­ì„ ìœ„í•œ ì„¸ê·¸ë¨¼íŠ¸ì´ë‹¤. ê·¸ëŸ¬ë‚˜ x86-64ì—ì„œëŠ” íƒœìŠ¤í¬ ìŠ¤ìœ„ì¹­ì´ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ”ë‹¤. ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³  TSSëŠ” ë§ ìŠ¤ìœ„ì¹­ ì¤‘ ìŠ¤íƒ í¬ì¸í„°ë¥¼ ì°¾ê¸° ìœ„í•´ ì—¬ì „íˆ ì‚¬ìš©ëœë‹¤.ì´ëŠ” ìœ ì € í”„ë¡œì„¸ìŠ¤ê°€ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì— ì§„ì…í•  ë•Œ, í•˜ë“œì›¨ì–´ëŠ” tssì—ê²Œ ì»¤ë„ì˜ ìŠ¤íƒ í¬ì¸í„°ë¥¼ ì°¾ì•„ë‹¬ë¼ê³  ìš”ì²­í•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

    - Execution information

        "Execution information"ì€ í”„ë¡œê·¸ë¨ ì‹¤í–‰ ë„ì¤‘ì— ìƒì„±ë˜ëŠ” ì •ë³´ë¡œ, í”„ë¡œì„¸ìŠ¤ê°€ ë©”ëª¨ë¦¬ì— ì˜¬ë¼ê°€ ì‹¤í–‰ë˜ë©´ì„œ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ì •ë³´ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ ì •ë³´ì—ëŠ” í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ CPU ë ˆì§€ìŠ¤í„° ê°’, ìŠ¤íƒ í¬ì¸í„°, í”„ë¡œê·¸ë¨ ì¹´ìš´í„° ê°’ ë“±ì´ í¬í•¨

    - ECF(Exceptional contol flow): ì˜ˆì™¸ì ì¸ íë¦„

        í”„ë¡œì„¸ì„œì—ì„œ ì „ì›ì„ ì²˜ìŒ ê³µê¸‰í•˜ëŠ” ì‹œì ë¶€í„° ì „ì›ì„ ëŒ ë•Œê¹Œì§€ **í”„ë¡œê·¸ë¨ ì¹´ìš´í„°ëŠ” ì—°ì†ëœ ê°’ì„ A0,A1, . . ., An-1ê°€ì •**í•œë‹¤.

        ì´ë•Œ, ì¸ìŠ¤íŠ¸ëŸ­ì…˜ Ikì— ëŒ€ì‘ë˜ëŠ” ì£¼ì†Œê°€ Akì´ë‹¤.  Akì—ì„œ  Ak+1ë¡œì˜ ì „í™˜ì€ **ì œì–´ì´ë™**ì´ë¼ê³  ë¶€ë¥¸ë‹¤. ì´ëŸ¬í•œ ì œì–´

        ì¼ë°˜ì ì¸ í”„ë¡œê·¸ë¨ì˜ íë¦„ì€ ëª…ë ¹ì–´ë“¤ì´ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì˜ˆì™¸ì ì¸ ìƒí™©ì´ ë°œìƒí•˜ë©´, ì˜ˆë¥¼ ë“¤ì–´ ë””ë°”ì´ìŠ¤ ì˜¤ë¥˜, ì‹œìŠ¤í…œ ì½œ ìš”ì²­, ì¸í„°ëŸ½íŠ¸ ë“±ì´ ë°œìƒí•˜ë©´ í”„ë¡œê·¸ë¨ì˜ ì œì–´ íë¦„ì€ ì¼ì‹œì ìœ¼ë¡œ ì˜ˆì™¸ì ì¸ ìƒí™©ìœ¼ë¡œ ì „í™˜

    - ê°€ìƒë©”ëª¨ë¦¬ë€?

        ë©”ì¸ ë©”ëª¨ë¦¬ì˜ ì¶”ìƒí™”. ê° í”„ë¡œì„¸ìŠ¤ì— í•˜ë‚˜ì˜ í¬ê³  í†µí•©ëœ, ì‚¬ì  ì£¼ì†Œê³µê°„ì„ ì œê³µí•˜ëŠ” ê²ƒ.

        1. ë©”ì¸ ë©”ëª¨ë¦¬ ë‚´ í™œì„±í™” ì˜ì—­ë§Œ ìœ ì§€â†’ë©”ì¸ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©
        2. ê° í”„ë¡œì„¸ìŠ¤ì— í†µì¼ëœ ì£¼ì†Œê³µê°„ì„ ì œê³µâ†’ ë©”ëª¨ë¦¬ ê´€ë¦¬ ë‹¨ìˆœí™”
        3. ê° í”„ë¡œì„¸ìŠ¤ì˜ ì£¼ì†Œê³µê°„ì„ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì— ì˜í•œ ì†ìƒìœ¼ë¡œë¶€í„° ë³´í˜¸.

    [22. í˜ì´ì§•(Paging)ê³¼ í˜ì´ì§€ í…Œì´ë¸”(Page table) (tistory.com)](https://ddongwon.tistory.com/49)